defmodule Jidoka.Tools.Registry do
  @moduledoc """
  Registry for discovering and listing available Jido tool actions.

  This module provides a central registry for all tools that can be
  invoked by the LLM or other agents. Tools are automatically registered
  at compile time.

  ## Examples

      # List all available tools
      tools = Jidoka.Tools.Registry.list_tools()

      # Find a specific tool
      {:ok, tool} = Jidoka.Tools.Registry.find_tool("read_file")

      # Get tools by category
      filesystem_tools = Jidoka.Tools.Registry.list_tools(category: "filesystem")

  """

  @type tool_info :: %{
          name: String.t(),
          module: module(),
          description: String.t(),
          category: String.t(),
          tags: [String.t()],
          schema: keyword()
        }

  # Compile-time tool registry
  @tools [
    # Core tools
    {Jidoka.Tools.ReadFile, :read_file, "filesystem"},
    {Jidoka.Tools.SearchCode, :search_code, "search"},
    {Jidoka.Tools.AnalyzeFunction, :analyze_function, "analysis"},
    {Jidoka.Tools.ListFiles, :list_files, "filesystem"},
    {Jidoka.Tools.GetDefinition, :get_definition, "analysis"}
  ]

  @doc """
  Lists all available tools.

  ## Options

  * `:category` - Filter by category (optional)
  * `:tags` - Filter by tags (optional)

  ## Returns

  List of tool info maps
  """
  @spec list_tools(keyword()) :: [tool_info()]
  def list_tools(opts \\ []) do
    category_filter = Keyword.get(opts, :category)
    tags_filter = Keyword.get(opts, :tags)

    @tools
    |> Enum.map(&tool_info/1)
    |> Enum.filter(fn tool ->
      category_check(category_filter, tool) and tags_check(tags_filter, tool)
    end)
  end

  @doc """
  Finds a tool by name.

  ## Returns

  * `{:ok, tool_info}` - Tool found
  * `{:error, :not_found}` - Tool not found
  """
  @spec find_tool(String.t()) :: {:ok, tool_info()} | {:error, :not_found}
  def find_tool(name) when is_binary(name) do
    @tools
    |> Enum.find(fn {module, _action_name, _category} ->
      get_tool_name(module) == name
    end)
    |> case do
      nil ->
        {:error, :not_found}

      entry ->
        {:ok, tool_info(entry)}
    end
  end

  @doc """
  Gets tool names by category.
  """
  @spec tools_by_category(String.t()) :: [String.t()]
  def tools_by_category(category) when is_binary(category) do
    @tools
    |> Enum.filter(fn {_module, _name, cat} -> cat == category end)
    |> Enum.map(fn {module, _name, _cat} -> get_tool_name(module) end)
  end

  @doc """
  Returns all available categories.
  """
  @spec categories() :: [String.t()]
  def categories do
    @tools
    |> Enum.map(fn {_module, _name, category} -> category end)
    |> Enum.uniq()
    |> Enum.sort()
  end

  @doc """
  Checks if a tool exists.
  """
  @spec tool_exists?(String.t()) :: boolean()
  def tool_exists?(name) when is_binary(name) do
    case find_tool(name) do
      {:ok, _} -> true
      _ -> false
    end
  end

  # ============================================================================
  # Private Helpers
  # ============================================================================

  defp tool_info({module, _action_name, category}) do
    %{
      name: get_tool_name(module),
      module: module,
      description: get_tool_description(module),
      category: category,
      tags: get_tool_tags(module),
      schema: get_tool_schema(module)
    }
  end

  defp get_tool_name(module) do
    case get_jido_attribute(module, :name) do
      nil -> module |> Module.split() |> List.last() |> Macro.underscore()
      name when is_atom(name) -> Atom.to_string(name)
      name when is_binary(name) -> name
    end
  rescue
    _ -> module |> Module.split() |> List.last() |> Macro.underscore()
  end

  defp get_tool_description(module) do
    case get_jido_attribute(module, :description) do
      nil -> "No description available"
      desc when is_binary(desc) -> desc
    end
  rescue
    _ -> "No description available"
  end

  defp get_tool_tags(module) do
    case get_jido_attribute(module, :tags) do
      nil -> []
      tags when is_list(tags) -> Enum.map(tags, &to_string/1)
    end
  rescue
    _ -> []
  end

  defp get_tool_schema(module) do
    case get_jido_attribute(module, :schema) do
      nil -> []
      schema when is_list(schema) -> schema
    end
  rescue
    _ -> []
  end

  defp get_jido_attribute(module, key) do
    cond do
      # Try calling the function on the module (generated by use macro)
      function_exported?(module, key, 0) ->
        apply(module, key, [])

      # Fall back to reading module attribute directly
      true ->
        Module.get_attribute(module, :__jido__, [])
        |> Keyword.get(key)
    end
  end

  defp category_check(nil, _tool), do: true
  defp category_check(category, tool), do: tool.category == category

  defp tags_check(nil, _tool), do: true
  defp tags_check(tags, tool) when is_list(tags) do
    Enum.all?(tags, fn tag -> tag in tool.tags end)
  end
end
