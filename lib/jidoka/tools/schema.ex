defmodule Jidoka.Tools.Schema do
  @moduledoc """
  Generates OpenAI-compatible function calling schemas from Jido Actions.

  This module converts Jido Action schemas into the format expected by
  LLM function calling APIs (OpenAI, Anthropic, etc.).
  """

  @type openai_schema :: %{
          type: String.t(),
          properties: map(),
          required: [String.t()]
        }

  @type function_schema :: %{
          name: String.t(),
          description: String.t(),
          parameters: openai_schema()
        }

  @doc """
  Converts a Jido Action module to an OpenAI-compatible function schema.
  """
  @spec to_openai_schema(module()) :: function_schema()
  def to_openai_schema(module) when is_atom(module) do
    action_name = get_action_name(module)
    description = get_action_description(module)
    parameters = build_parameters_schema(module)

    %{
      name: action_name,
      description: description,
      parameters: parameters
    }
  end

  @doc """
  Generates OpenAI schemas for all registered tools.

  Returns a list of function schema maps.
  """
  @spec all_tool_schemas() :: [function_schema()]
  def all_tool_schemas do
    Jidoka.Tools.Registry.list_tools()
    |> Enum.map(fn tool -> to_openai_schema(tool.module) end)
  end

  @doc """
  Converts a schema map to JSON string.
  """
  @spec to_json(function_schema() | [function_schema()]) :: String.t()
  def to_json(schema) when is_map(schema) do
    Jason.encode!(schema)
  end

  def to_json(schemas) when is_list(schemas) do
    Jason.encode!(schemas)
  end

  @doc """
  Generates parameter descriptions for documentation.

  Returns a human-readable list of parameters with their types,
  descriptions, and whether they're required.
  """
  @spec describe_parameters(module()) :: String.t()
  def describe_parameters(module) when is_atom(module) do
    schema = get_action_schema(module)

    lines = ["Parameters:"]

    param_lines =
      Enum.map(schema, fn {name, opts} ->
        type = Keyword.get(opts, :type)
        required = Keyword.get(opts, :required, false)
        doc = Keyword.get(opts, :doc, "")

        req_str = if required, do: "required", else: "optional"
        "- #{name} (#{type}, #{req_str}) #{doc}"
      end)

    (lines ++ param_lines)
    |> Enum.join("\n")
  end

  # ============================================================================
  # Private Helpers
  # ============================================================================

  defp get_action_name(module) do
    # Try to get the name from the module's __jido__ attribute or use module name
    case get_jido_attribute(module, :name) do
      nil -> module |> Module.split() |> List.last() |> Macro.underscore()
      name when is_atom(name) -> Atom.to_string(name)
      name when is_binary(name) -> name
    end
  rescue
      _ -> module |> Module.split() |> List.last() |> Macro.underscore()
  end

  defp get_action_description(module) do
    case get_jido_attribute(module, :description) do
      nil -> "No description available"
      desc when is_binary(desc) -> desc
    end
  rescue
      _ -> "No description available"
  end

  defp get_action_schema(module) do
    case get_jido_attribute(module, :schema) do
      nil -> []
      schema when is_list(schema) -> schema
    end
  rescue
      _ -> []
  end

  defp get_jido_attribute(module, key) do
    # The use Jido.Action macro stores attributes in module attributes
    # We try to read them via the module's own accessor functions first
    cond do
      # Try calling the function on the module (generated by use macro)
      function_exported?(module, key, 0) ->
        apply(module, key, [])

      # Fall back to reading module attribute directly
      true ->
        Module.get_attribute(module, :__jido__, [])
        |> Keyword.get(key)
    end
  end

  defp build_parameters_schema(module) do
    schema = get_action_schema(module)

    properties = build_properties(schema)
    required = build_required_list(schema)

    %{
      type: "object",
      properties: properties,
      required: required
    }
  end

  defp build_properties(schema) do
    schema
    |> Enum.map(fn {name, opts} ->
      prop_schema = %{
        "type" => type_to_json_type(Keyword.get(opts, :type)),
        "description" => Keyword.get(opts, :doc, "#{name} parameter")
      }

      # Add enum if there are constraints
      prop_schema =
        case Keyword.get(opts, :values) do
          nil -> prop_schema
          values -> Map.put(prop_schema, "enum", values)
        end

      # Return as {key, value} tuple for Map.new
      {Atom.to_string(name), prop_schema}
    end)
    |> Map.new()
  end

  defp build_required_list(schema) do
    schema
    |> Enum.filter(fn {_name, opts} ->
      Keyword.get(opts, :required, false)
    end)
    |> Enum.map(fn {name, _opts} -> Atom.to_string(name) end)
  end

  defp type_to_json_type(:string), do: "string"
  defp type_to_json_type(:integer), do: "integer"
  defp type_to_json_type(:float), do: "number"
  defp type_to_json_type(:boolean), do: "boolean"
  defp type_to_json_type(:map), do: "object"
  defp type_to_json_type(:list), do: "array"
  defp type_to_json_type(:atom), do: "string"
  defp type_to_json_type(_), do: "string"
end
