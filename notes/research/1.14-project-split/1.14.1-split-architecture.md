# JidoCode Core Library Architecture

## Executive Summary

JidoCode is a sophisticated agentic coding assistant built in Elixir, combining powerful LLM-driven capabilities with a multi-agent system. This document outlines the architecture of **JidoCode_Core**—a headless, client-agnostic library that encapsulates all core agentic functionality. The core provides a well-defined **Client API** based on Phoenix PubSub events, enabling any frontend (TUI, web, API, custom clients) to interact with the agentic system through a unified interface.

The primary architectural goal is to establish **JidoCode_Core** as a standalone, reusable engine. All communication with clients happens through a formal **Client API** that leverages Elixir message passing and Phoenix PubSub for asynchronous event notifications. This approach ensures the core remains entirely agnostic to client implementation details, focusing solely on session management, agent execution, tool orchestration, and memory integration.

## Current Architecture Analysis

The existing JidoCode application (as it exists) combines core agentic logic with presentation concerns. A deep analysis reveals a system built with Elixir's concurrency and fault-tolerance primitives, organized around a supervision tree with specialized agents. The primary components include session management, LLM agents, a comprehensive tool framework, and supporting modules for configuration, memory, and reasoning.

The core agentic functionality is encapsulated within modules responsible for session management (`Session`), agent orchestration (`LLMAgent`), tool execution (`Tools.*`), configuration management, memory systems, and reasoning capabilities. These components communicate through Phoenix PubSub, forming a loosely coupled, event-driven architecture that inherently supports separation from presentation concerns.

## Proposed Core Library Architecture

The proposed architecture focuses on **JidoCode_Core** as a standalone library with a well-defined Client API.

### **JidoCode_Core**: Core Agentic Engine

This library encapsulates all essential, non-client-specific logic of JidoCode:

- **Session Management**: Creating, managing, and persisting session states, including project paths, configurations, and associated data
- **Agent Orchestration**: Managing the lifecycle and execution of LLM agents
- **Tool System**: Providing the framework for defining, registering, and securely executing tools
- **Configuration Management**: Handling global and project-specific settings, LLM provider configurations, and API key management
- **Memory and Reasoning**: Integrating the memory subsystem and various reasoning modes
- **Security**: Enforcing path validation, command allowlisting, and sandboxing for tool execution
- **Client API**: The public interface that clients use to interact with the core

### Client Consumption Model

Clients (TUI, web, API, custom applications) consume **JidoCode_Core** through:

1. **Direct Function Calls**: For commands (send message, start session, etc.)
2. **Phoenix PubSub Events**: For receiving async updates from the core

This decoupling enables:
- **Multiple Simultaneous Clients**: TUI, web, and API can all connect to the same core instance
- **Technology Agnostic Clients**: Clients can be written in any language that supports PubSub or can bridge to it
- **Independent Evolution**: Core and clients evolve independently without breaking changes

## The Client API

The **Client API** is the formal contract between **JidoCode_Core** and any consuming client. This API provides comprehensive access to core functionalities while abstracting internal implementation details.

### Primary Design Principles

1. **Completeness**: Exposes all necessary functions for clients to fully utilize JidoCode
2. **Simplicity**: Intuitive function signatures with clear behavior
3. **Decoupling**: Prevents clients from directly accessing internal state
4. **Asynchronous**: PubSub-based notifications avoid blocking clients
5. **Serializable Data**: Uses simple, serializable formats across the API boundary

### Session Management API

```elixir
# Start a new session
JidoCode.Core.start_session(opts :: keyword()) :: {:ok, Session.t()} | {:error, term()}

# Stop a session
JidoCode.Core.stop_session(session_id :: String.t()) :: :ok | {:error, term()}

# List active sessions
JidoCode.Core.list_sessions() :: [Session.t()]

# Get session details
JidoCode.Core.get_session(session_id :: String.t()) :: {:ok, Session.t()} | {:error, :not_found}

# Update session configuration
JidoCode.Core.set_session_config(session_id :: String.t(), config :: map()) :: {:ok, Session.t()} | {:error, term()}

# Set session language
JidoCode.Core.set_session_language(session_id :: String.t(), language :: String.t() | atom()) :: {:ok, Session.t()} | {:error, term()}
```

### Agent Interaction API

```elixir
# Send a message to the LLM agent
JidoCode.Core.send_message(session_id :: String.t(), message :: String.t(), opts :: keyword()) :: :ok | {:error, term()}

# Cancel in-progress message
JidoCode.Core.cancel_message(session_id :: String.t(), message_id :: String.t()) :: :ok | {:error, term()}
```

### Tool System API

```elixir
# List available tools
JidoCode.Core.list_tools(session_id :: String.t()) :: [Tool.Schema.t()]

# Get specific tool schema
JidoCode.Core.get_tool_schema(tool_name :: String.t()) :: {:ok, Tool.Schema.t()} | {:error, :not_found}
```

### Configuration API

```elixir
# Get global settings
JidoCode.Core.get_global_settings() :: map()

# Update global settings
JidoCode.Core.update_global_settings(changes :: map()) :: {:ok, map()} | {:error, term()}

# List available LLM providers
JidoCode.Core.list_available_providers() :: [String.t()]

# List models for provider
JidoCode.Core.list_models_for_provider(provider :: String.t()) :: [String.t()]
```

### Event Subscription (via Phoenix PubSub)

Clients subscribe to topics to receive async events:

#### Agent Events (`"agent:{session_id}"`)

```elixir
# LLM streaming response
{:llm_stream_chunk, %{content: String.t(), message_id: String.t()}}

# Final LLM response
{:llm_response, %{content: String.t(), message_id: String.t(), metadata: map()}}

# Agent status update
{:agent_status, %{status: :idle | :processing | :error | :unconfigured, message: String.t() | nil}}

# Reasoning step
{:reasoning_step, %{step: String.t(), status: :pending | :active | :complete}}
```

#### Tool Events (`"agent:{session_id}"`)

```elixir
# Tool call initiated
{:tool_call, %{call_id: String.t(), tool_name: String.t(), params: map(), timestamp: DateTime.t()}}

# Tool result
{:tool_result, %{call_id: String.t(), result: term(), timestamp: DateTime.t()}}

# Tool error
{:tool_error, %{call_id: String.t(), error: term(), timestamp: DateTime.t()}}
```

#### Session Events (`"session"`)

```elixir
# Session started
{:session_started, Session.t()}

# Session stopped
{:session_stopped, %{session_id: String.t()}}

# Session updated
{:session_updated, Session.t()}
```

#### Configuration Events (`"config"`)

```elixir
# Global config updated
{:global_config_updated, map()}
```

## Refactoring Plan

### Phase 1: Core Isolation and API Definition

**Objective 1.1: Identify and Tag Core Modules**

Classify all modules as "Core" (belonging to JidoCode_Core) or "Client-Specific".

**Core Modules**:
- Session management (`session.ex`, `session_supervisor.ex`, `session_registry.ex`)
- Agent logic (`agents/llm_agent.ex`, `agent_supervisor.ex`)
- Tool system (`tools/` directory)
- Configuration (`settings.ex`, `config.ex`)
- Memory and reasoning (`memory/`, `reasoning/` directories)
- Knowledge graph (`knowledge_graph/`)
- Commands (`commands.ex`)
- Error handling (`error.ex`, `error_formatter.ex`)
- Utilities (`utils/`, `language.ex`, `pubsub_helpers.ex`, `pubsub_topics.ex`, `rate_limit.ex`)
- Telemetry (`telemetry/`)

**Client-Specific Modules** (to be removed or moved to separate repos):
- All TUI-related code
- Any UI-specific formatting or display logic

**Objective 1.2: Define the Client API**

Formalize the public interface for **JidoCode_Core** including:
- Function signatures, parameter types, and return values
- PubSub event structures
- Data structure definitions

**Objective 1.3: Create JidoCode_Core Library Skeleton**

- Set up a new Mix project for **JidoCode_Core**
- Move core modules under the `JidoCode.Core` namespace
- Implement public API functions
- Configure dependencies

### Phase 2: Implement and Test JidoCode_Core

**Objective 2.1: Decouple Core from Client Dependencies**

- Audit core modules for any client-specific dependencies
- Remove or abstract such dependencies

**Objective 2.2: Implement Core Logic Independently**

- Ensure core modules function correctly via the Client API
- Refactor as needed for stateless operation or proper parameter passing

**Objective 2.3: Develop Comprehensive Tests**

- Write unit tests for all core modules
- Develop integration tests for the Client API
- Test PubSub event emissions
- Mock external dependencies

### Phase 3: Documentation and Examples

**Objective 3.1: Create Client Integration Guide**

- Document how to connect to the core
- Provide examples in multiple languages (Elixir, JavaScript, Python)
- Show PubSub subscription patterns

**Objective 3.2: Create Example Clients**

- Simple CLI client example
- Example HTTP/WebSocket API server
- Reference implementations for common patterns

## Impact and Benefits

### Enhanced Modularity and Reusability

**JidoCode_Core** becomes a standalone, reusable agentic engine. Developers can:
- Integrate into custom web applications (Phoenix LiveView, React, etc.)
- Build desktop applications
- Create IDE plugins (VS Code, IntelliJ)
- Orchestrate agents in headless backend systems

### Improved Testability

The **JidoCode_Core** library can be unit and integration tested in isolation:
- Tests exercise business logic through direct API calls
- PubSub events are verified for correctness
- Faster feedback loops during development

### Enhanced Maintainability and Evolvability

Clear separation between core and clients:
- Core changes don't break clients (API stability)
- Clients can be updated independently
- Reduced regression risk

### Extensibility and Ecosystem Growth

A well-documented **Client API** acts as an invitation for contribution:
- Third-party developers can build clients
- Community can contribute specialized toolsets
- Lower barrier to entry for contributors

### Clear Separation of Concerns

- **Core** focuses on "what"—agentic logic, data processing, state management
- **Clients** focus on "how"—presentation, user interaction, visual feedback

## Conclusion

The **JidoCode_Core** architecture establishes a powerful, headless agentic coding assistant engine. By defining a clear **Client API** based on Phoenix PubSub, the core becomes a reusable component that can power diverse interfaces—TUI, web, API, IDE plugins, or custom applications.

This separation is more than code reorganization; it's a strategic realignment that transforms JidoCode into a true platform for agentic coding assistance. The **Client API** ensures the core remains decoupled from any specific implementation, enabling the community to build diverse interfaces while leveraging the same robust underlying engine.

The effort invested in this architecture will yield long-term benefits: a more robust, flexible, and widely adoptable JidoCode platform ready to adapt to evolving user needs and technological landscapes.
