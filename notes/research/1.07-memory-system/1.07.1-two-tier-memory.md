# Two-Tier Memory System Design for JidoCode

## Integrating with the Jido Ontology Set

This design document describes a two-tier memory architecture for JidoCode's LLMAgent that **directly uses** the existing Jido ontology modules rather than creating parallel memory classes. The architecture separates ephemeral working memory (short-term, in-process) from persistent semantic memory (long-term, triple store backed), with intelligent promotion mechanisms.

---

## Ontology Integration Summary

Your existing ontology already provides the complete foundation for long-term memory:

| Ontology Module | Memory-Relevant Classes | Role in Memory System |
|-----------------|------------------------|----------------------|
| **jido-core** | `MemoryItem`, `Evidence`, `Justification`, `ConfidenceLevel`, `SourceType` | Base class for all persisted memories; confidence and provenance tracking |
| **jido-knowledge** | `Fact`, `Assumption`, `Hypothesis`, `Discovery`, `Risk`, `Unknown` | Memory type classification for learned knowledge |
| **jido-decision** | `Decision`, `Alternative`, `TradeOff`, `ArchitecturalDecision` | Captures decision rationale and alternatives considered |
| **jido-task** | `Task`, `Milestone`, `Plan` | Work tracking that contextualizes memory |
| **jido-convention** | `Convention`, `CodingStandard`, `AgentRule` | Remembered standards and rules |
| **jido-error** | `Error`, `Bug`, `RootCause`, `LessonLearned` | Error patterns and solutions |
| **jido-session** | `WorkSession`, `SessionStatus`, `SessionPhase` | Session scoping for memories |
| **jido-agent** | `Agent`, `AgentRole`, `Capability` | Agent identity and memory permissions |
| **jido-code** | `CodeConcept`, `ElixirModule`, `SourceFile` | Code artifacts that memories reference |
| **jido-project** | `Project`, `Repository`, `Module`, `Domain` | Project scoping for memories |

**Key Insight**: `jido:MemoryItem` and its subclasses (`Fact`, `Assumption`, `Hypothesis`, `Discovery`, `Risk`, `Unknown`, `Decision`, `Task`, `Convention`, `Error`, `LessonLearned`) already define the taxonomy for long-term memory. The existing properties (`assertedBy`, `assertedIn`, `hasConfidence`, `hasSourceType`, `derivedFrom`, `supersededBy`) provide full provenance tracking.

---

## Architecture Overview

```
┌──────────────────────────────────────────────────────────────────────────┐
│                         JidoCode Session (Unique ID)                      │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │                    LLMAgent GenServer                               │  │
│  │  ┌──────────────────────────────────────────────────────────────┐  │  │
│  │  │                    SHORT-TERM MEMORY                          │  │  │
│  │  │                  (Elixir Process State)                       │  │  │
│  │  │  ┌─────────────┐  ┌──────────────┐  ┌────────────────────┐   │  │  │
│  │  │  │ Conversation │  │   Working    │  │    Pending         │   │  │  │
│  │  │  │   Buffer     │  │   Context    │  │    MemoryItems     │   │  │  │
│  │  │  │  (messages)  │  │  (scratch)   │  │  (pre-promotion)   │   │  │  │
│  │  │  └─────────────┘  └──────────────┘  └────────────────────┘   │  │  │
│  │  │                                                               │  │  │
│  │  │  [Access Tracker]  [Importance Scorer]  [Token Budget Mgr]   │  │  │
│  │  └──────────────────────────────────────────────────────────────┘  │  │
│  │                              │                                      │  │
│  │                              ▼ promotion                            │  │
│  │  ┌──────────────────────────────────────────────────────────────┐  │  │
│  │  │                   PROMOTION ENGINE                            │  │  │
│  │  │   • Implicit signals (access frequency, recency)              │  │  │
│  │  │   • Agent self-determination (remember/forget tools)          │  │  │
│  │  │   • Type inference (Fact vs Hypothesis vs Discovery...)       │  │  │
│  │  └──────────────────────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────────┐
│                         LONG-TERM MEMORY                                  │
│                    (Triple Store per Session)                             │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │   Uses Existing Jido Ontology Classes:                              │  │
│  │                                                                      │  │
│  │   jido:MemoryItem (base)                                            │  │
│  │      ├── jido:Fact              "The project uses Phoenix 1.7"      │  │
│  │      ├── jido:Assumption        "User prefers explicit type specs"  │  │
│  │      ├── jido:Hypothesis        "This bug might be a race cond."    │  │
│  │      ├── jido:Discovery         "Found undocumented API endpoint"   │  │
│  │      ├── jido:Risk              "Migration may break old clients"   │  │
│  │      ├── jido:Unknown           "License status of dep unclear"     │  │
│  │      ├── jido:Decision          "Chose GenServer over Agent"        │  │
│  │      ├── jido:Task              "Implement user auth flow"          │  │
│  │      ├── jido:Convention        "Use @moduledoc in all modules"     │  │
│  │      ├── jido:LessonLearned     "Always check ETS table exists"     │  │
│  │      └── jido:Error/Bug         "Timeout on large file uploads"     │  │
│  │                                                                      │  │
│  │   With Properties: assertedBy, assertedIn, hasConfidence,           │  │
│  │                    hasSourceType, derivedFrom, supersededBy         │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘
```

---

## Short-Term Memory Data Model

Short-term memory is ephemeral Elixir state within the LLMAgent GenServer. It holds:

1. **Conversation Buffer** - Recent messages (sliding window)
2. **Working Context** - Extracted semantic scratchpad
3. **Pending MemoryItems** - Candidates awaiting promotion decision
4. **Access Log** - Tracks usage patterns for importance scoring

### Core Container

```elixir
defmodule JidoCode.Memory.ShortTerm do
  @moduledoc """
  Session-scoped working memory container.
  All data is ephemeral and tied to the GenServer lifecycle.
  """

  alias __MODULE__.{ConversationBuffer, WorkingContext, PendingMemories, AccessLog}

  @type t :: %__MODULE__{
    session_id: String.t(),
    conversation: ConversationBuffer.t(),
    context: WorkingContext.t(),
    pending: PendingMemories.t(),
    access_log: AccessLog.t(),
    token_budget: token_budget(),
    created_at: DateTime.t()
  }

  @type token_budget :: %{
    total: pos_integer(),
    conversation: pos_integer(),
    context: pos_integer()
  }

  defstruct [
    :session_id,
    :conversation,
    :context,
    :pending,
    :access_log,
    :token_budget,
    :created_at
  ]

  @default_budget %{total: 32_000, conversation: 20_000, context: 12_000}

  def new(session_id, opts \\ []) do
    budget = Keyword.get(opts, :token_budget, @default_budget)
    
    %__MODULE__{
      session_id: session_id,
      conversation: ConversationBuffer.new(budget.conversation),
      context: WorkingContext.new(budget.context),
      pending: PendingMemories.new(),
      access_log: AccessLog.new(),
      token_budget: budget,
      created_at: DateTime.utc_now()
    }
  end
end
```

### Conversation Buffer

```elixir
defmodule JidoCode.Memory.ShortTerm.ConversationBuffer do
  @moduledoc """
  Sliding window message buffer with token-aware eviction.
  Evicted messages become candidates for promotion to long-term memory.
  """

  @type message :: %{
    id: String.t(),
    role: :user | :assistant | :system | :tool,
    content: String.t(),
    timestamp: DateTime.t(),
    token_count: pos_integer(),
    tool_calls: [map()] | nil,
    metadata: map()
  }

  @type t :: %__MODULE__{
    messages: :queue.queue(message()),
    current_tokens: pos_integer(),
    max_tokens: pos_integer()
  }

  defstruct messages: :queue.new(), current_tokens: 0, max_tokens: 20_000

  def new(max_tokens), do: %__MODULE__{max_tokens: max_tokens}

  @doc """
  Adds message, returns {updated_buffer, evicted_messages}.
  Evicted messages should be evaluated for promotion.
  """
  def add(%__MODULE__{} = buffer, message) do
    new_tokens = buffer.current_tokens + message.token_count
    
    if new_tokens > buffer.max_tokens do
      {evicted, remaining_queue, freed_tokens} = evict_oldest(buffer.messages, message.token_count)
      
      updated = %{buffer | 
        messages: :queue.in(message, remaining_queue),
        current_tokens: buffer.current_tokens - freed_tokens + message.token_count
      }
      
      {updated, evicted}
    else
      {%{buffer | 
        messages: :queue.in(message, buffer.messages),
        current_tokens: new_tokens
      }, []}
    end
  end

  defp evict_oldest(queue, tokens_needed) do
    evict_oldest(queue, tokens_needed, [], 0)
  end

  defp evict_oldest(queue, tokens_needed, evicted, freed) when freed >= tokens_needed do
    {Enum.reverse(evicted), queue, freed}
  end

  defp evict_oldest(queue, tokens_needed, evicted, freed) do
    case :queue.out(queue) do
      {{:value, msg}, rest} ->
        evict_oldest(rest, tokens_needed, [msg | evicted], freed + msg.token_count)
      {:empty, _} ->
        {Enum.reverse(evicted), queue, freed}
    end
  end

  def to_list(%__MODULE__{messages: q}), do: :queue.to_list(q)
end
```

### Working Context (Semantic Scratchpad)

Working context stores extracted understanding about the current session - not yet committed to long-term memory but informing the agent's behavior.

```elixir
defmodule JidoCode.Memory.ShortTerm.WorkingContext do
  @moduledoc """
  Semantic working memory - the agent's scratchpad for current understanding.
  Items here may be promoted to long-term memory based on importance.
  """

  @type context_key ::
    :active_file |
    :project_root |
    :primary_language |
    :framework |
    :current_task |
    :user_intent |
    :discovered_patterns |
    :active_errors |
    :pending_questions |
    :file_relationships

  @type context_item :: %{
    key: context_key(),
    value: term(),
    source: :inferred | :explicit | :tool,
    confidence: float(),          # Maps to jido:ConfidenceLevel
    access_count: non_neg_integer(),
    first_seen: DateTime.t(),
    last_accessed: DateTime.t(),
    suggested_type: memory_type() | nil  # For promotion
  }

  # Maps to jido:MemoryItem subclasses
  @type memory_type ::
    :fact |
    :assumption |
    :hypothesis |
    :discovery |
    :risk |
    :unknown |
    :decision |
    :convention |
    :lesson_learned

  @type t :: %__MODULE__{
    items: %{context_key() => context_item()},
    current_tokens: pos_integer(),
    max_tokens: pos_integer()
  }

  defstruct items: %{}, current_tokens: 0, max_tokens: 12_000

  def new(max_tokens), do: %__MODULE__{max_tokens: max_tokens}

  @doc """
  Updates context, inferring memory type for potential promotion.
  """
  def put(%__MODULE__{} = ctx, key, value, opts \\ []) do
    now = DateTime.utc_now()
    source = Keyword.get(opts, :source, :inferred)
    confidence = Keyword.get(opts, :confidence, 0.7)
    suggested_type = Keyword.get(opts, :memory_type, infer_memory_type(key, source))
    
    item = case Map.get(ctx.items, key) do
      nil ->
        %{
          key: key,
          value: value,
          source: source,
          confidence: confidence,
          access_count: 1,
          first_seen: now,
          last_accessed: now,
          suggested_type: suggested_type
        }
      existing ->
        %{existing |
          value: value,
          access_count: existing.access_count + 1,
          last_accessed: now,
          confidence: max(existing.confidence, confidence),
          suggested_type: suggested_type || existing.suggested_type
        }
    end
    
    %{ctx | items: Map.put(ctx.items, key, item)}
  end

  @doc """
  Retrieves context, updating access tracking.
  """
  def get(%__MODULE__{} = ctx, key) do
    case Map.get(ctx.items, key) do
      nil -> {ctx, nil}
      item ->
        updated = %{item | access_count: item.access_count + 1, last_accessed: DateTime.utc_now()}
        {%{ctx | items: Map.put(ctx.items, key, updated)}, item.value}
    end
  end

  # Infer which jido:MemoryItem subclass this should become
  defp infer_memory_type(:framework, :tool), do: :fact
  defp infer_memory_type(:primary_language, :tool), do: :fact
  defp infer_memory_type(:project_root, :tool), do: :fact
  defp infer_memory_type(:user_intent, :inferred), do: :assumption
  defp infer_memory_type(:discovered_patterns, _), do: :discovery
  defp infer_memory_type(:active_errors, _), do: nil  # Not promoted, ephemeral
  defp infer_memory_type(:pending_questions, _), do: :unknown
  defp infer_memory_type(_, _), do: nil
end
```

### Pending Memories (Pre-Promotion Queue)

```elixir
defmodule JidoCode.Memory.ShortTerm.PendingMemories do
  @moduledoc """
  Staging area for memory items awaiting promotion decision.
  Items here are structured as proto-MemoryItems aligned with the ontology.
  """

  alias JidoCode.Memory.ShortTerm.WorkingContext

  @type pending_item :: %{
    id: String.t(),
    content: String.t(),
    memory_type: WorkingContext.memory_type(),
    confidence: float(),
    source_type: :user | :agent | :tool | :external_document,
    evidence: [String.t()],           # References to supporting data
    rationale: String.t() | nil,
    suggested_by: :implicit | :agent,  # How it got here
    importance_score: float(),
    created_at: DateTime.t(),
    access_count: non_neg_integer()
  }

  @type t :: %__MODULE__{
    items: %{String.t() => pending_item()},
    agent_decisions: [pending_item()]  # Explicitly marked by agent
  }

  defstruct items: %{}, agent_decisions: []

  def new, do: %__MODULE__{}

  @doc """
  Adds an item from implicit pattern detection.
  """
  def add_implicit(%__MODULE__{} = pending, item) do
    %{pending | items: Map.put(pending.items, item.id, item)}
  end

  @doc """
  Adds an item from agent self-determination (remember tool).
  These bypass threshold checks.
  """
  def add_agent_decision(%__MODULE__{} = pending, item) do
    %{pending | agent_decisions: [item | pending.agent_decisions]}
  end

  @doc """
  Returns all items ready for promotion (above threshold + agent decisions).
  """
  def ready_for_promotion(%__MODULE__{} = pending, threshold \\ 0.6) do
    implicit = pending.items
      |> Map.values()
      |> Enum.filter(&(&1.importance_score >= threshold))
    
    implicit ++ pending.agent_decisions
  end

  @doc """
  Clears promoted items from pending.
  """
  def clear_promoted(%__MODULE__{} = pending, promoted_ids) do
    %{pending |
      items: Map.drop(pending.items, promoted_ids),
      agent_decisions: []
    }
  end
end
```

---

## Long-Term Memory: Using the Jido Ontology

Long-term memory **directly uses** the existing Jido ontology classes. No new OWL classes are needed - we simply instantiate the existing `jido:MemoryItem` subclasses.

### Memory Type Mapping

| Short-term suggested_type | Jido OWL Class | When to use |
|---------------------------|----------------|-------------|
| `:fact` | `jido:Fact` | Verified information from tools or user confirmation |
| `:assumption` | `jido:Assumption` | Unverified beliefs held for working purposes |
| `:hypothesis` | `jido:Hypothesis` | Testable theories about behavior or bugs |
| `:discovery` | `jido:Discovery` | Newly uncovered important information |
| `:risk` | `jido:Risk` | Identified potential negative outcomes |
| `:unknown` | `jido:Unknown` | Explicitly acknowledged knowledge gaps |
| `:decision` | `jido:Decision` / `jido:ArchitecturalDecision` | Committed choices with alternatives |
| `:convention` | `jido:Convention` / `jido:CodingStandard` | Standards and rules to follow |
| `:lesson_learned` | `jido:LessonLearned` | Actionable knowledge from errors |

### Triple Store Adapter

```elixir
defmodule JidoCode.Memory.LongTerm.TripleStoreAdapter do
  @moduledoc """
  Adapter for persisting MemoryItems to triple_store using the Jido ontology.
  Each session has its own isolated store.
  """

  @jido_ns "https://jido.ai/ontology#"

  @type memory_input :: %{
    id: String.t(),
    content: String.t(),
    memory_type: atom(),
    confidence: float(),
    source_type: atom(),
    session_id: String.t(),
    agent_id: String.t() | nil,
    project_id: String.t() | nil,
    evidence_refs: [String.t()],
    rationale: String.t() | nil,
    created_at: DateTime.t()
  }

  @doc """
  Persists a memory item as RDF triples using the Jido ontology.
  """
  def persist(%{} = memory, session_id) do
    subject = memory_uri(memory.id)
    rdf_type = memory_type_to_class(memory.memory_type)
    
    triples = [
      # Core type assertion
      {subject, rdf_type_uri(), rdf_type},
      
      # Content (jido:summary for main content)
      {subject, prop("summary"), literal(memory.content)},
      
      # Confidence mapping
      {subject, prop("hasConfidence"), confidence_individual(memory.confidence)},
      
      # Source type
      {subject, prop("hasSourceType"), source_type_individual(memory.source_type)},
      
      # Session scoping (jido:assertedIn -> jido:WorkSession)
      {subject, prop("assertedIn"), session_uri(session_id)},
      
      # Timestamp
      {subject, prop("hasTimestamp"), literal(memory.created_at, :datetime)}
    ]
    
    # Optional properties
    triples = if memory.agent_id do
      [{subject, prop("assertedBy"), agent_uri(memory.agent_id)} | triples]
    else
      triples
    end
    
    triples = if memory.project_id do
      [{subject, prop("appliesToProject"), project_uri(memory.project_id)} | triples]
    else
      triples
    end
    
    triples = if memory.rationale do
      [{subject, prop("rationale"), literal(memory.rationale)} | triples]
    else
      triples
    end
    
    # Evidence references
    evidence_triples = Enum.map(memory.evidence_refs, fn ref ->
      evidence_uri = "#{@jido_ns}evidence_#{:crypto.hash(:sha256, ref) |> Base.encode16(case: :lower) |> String.slice(0..15)}"
      {subject, prop("derivedFrom"), evidence_uri}
    end)
    
    all_triples = triples ++ evidence_triples
    
    store = get_or_create_store(session_id)
    updated_store = Enum.reduce(all_triples, store, &TripleStore.add(&2, &1))
    persist_store(session_id, updated_store)
    
    {:ok, memory.id}
  end

  @doc """
  Queries memories by type for a session.
  """
  def query_by_type(session_id, memory_type, opts \\ []) do
    store = get_store(session_id)
    rdf_type = memory_type_to_class(memory_type)
    limit = Keyword.get(opts, :limit, 20)
    
    # Query pattern: ?s rdf:type jido:MemoryType
    pattern = {:_subject, rdf_type_uri(), rdf_type}
    
    subjects = TripleStore.query(store, pattern)
    |> Enum.take(limit)
    |> Enum.map(&elem(&1, 0))
    
    Enum.map(subjects, &load_memory(store, &1))
  end

  @doc """
  Queries all memories for a session, optionally filtered.
  """
  def query_all(session_id, opts \\ []) do
    store = get_store(session_id)
    min_confidence = Keyword.get(opts, :min_confidence, nil)
    limit = Keyword.get(opts, :limit, 50)
    
    # Get all subjects that are subclasses of MemoryItem
    memory_types = [:fact, :assumption, :hypothesis, :discovery, :risk, 
                    :unknown, :decision, :convention, :lesson_learned]
    
    subjects = memory_types
    |> Enum.flat_map(fn type ->
      pattern = {:_s, rdf_type_uri(), memory_type_to_class(type)}
      TripleStore.query(store, pattern) |> Enum.map(&elem(&1, 0))
    end)
    |> Enum.uniq()
    
    memories = Enum.map(subjects, &load_memory(store, &1))
    
    memories = if min_confidence do
      Enum.filter(memories, &(&1.confidence >= min_confidence))
    else
      memories
    end
    
    Enum.take(memories, limit)
  end

  @doc """
  Marks a memory as superseded by another.
  """
  def supersede(session_id, old_memory_id, new_memory_id) do
    store = get_store(session_id)
    
    triple = {
      memory_uri(old_memory_id),
      prop("supersededBy"),
      memory_uri(new_memory_id)
    }
    
    updated = TripleStore.add(store, triple)
    persist_store(session_id, updated)
  end

  @doc """
  Records access to a memory (for importance tracking).
  """
  def record_access(session_id, memory_id) do
    # Implementation: update access count and timestamp
    # Could use a separate access log or update in place
    :ok
  end

  # URI helpers
  defp memory_uri(id), do: "#{@jido_ns}memory_#{id}"
  defp session_uri(id), do: "#{@jido_ns}session_#{id}"
  defp agent_uri(id), do: "#{@jido_ns}agent_#{id}"
  defp project_uri(id), do: "#{@jido_ns}project_#{id}"
  defp prop(name), do: "#{@jido_ns}#{name}"
  defp rdf_type_uri, do: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"

  # Map internal types to Jido OWL classes
  defp memory_type_to_class(:fact), do: "#{@jido_ns}Fact"
  defp memory_type_to_class(:assumption), do: "#{@jido_ns}Assumption"
  defp memory_type_to_class(:hypothesis), do: "#{@jido_ns}Hypothesis"
  defp memory_type_to_class(:discovery), do: "#{@jido_ns}Discovery"
  defp memory_type_to_class(:risk), do: "#{@jido_ns}Risk"
  defp memory_type_to_class(:unknown), do: "#{@jido_ns}Unknown"
  defp memory_type_to_class(:decision), do: "#{@jido_ns}Decision"
  defp memory_type_to_class(:architectural_decision), do: "#{@jido_ns}ArchitecturalDecision"
  defp memory_type_to_class(:convention), do: "#{@jido_ns}Convention"
  defp memory_type_to_class(:coding_standard), do: "#{@jido_ns}CodingStandard"
  defp memory_type_to_class(:lesson_learned), do: "#{@jido_ns}LessonLearned"
  defp memory_type_to_class(:error), do: "#{@jido_ns}Error"
  defp memory_type_to_class(:bug), do: "#{@jido_ns}Bug"

  # Map confidence float to jido:ConfidenceLevel individuals
  defp confidence_individual(c) when c >= 0.8, do: "#{@jido_ns}High"
  defp confidence_individual(c) when c >= 0.5, do: "#{@jido_ns}Medium"
  defp confidence_individual(_), do: "#{@jido_ns}Low"

  # Map source types to jido:SourceType individuals
  defp source_type_individual(:user), do: "#{@jido_ns}UserSource"
  defp source_type_individual(:agent), do: "#{@jido_ns}AgentSource"
  defp source_type_individual(:tool), do: "#{@jido_ns}ToolSource"
  defp source_type_individual(:external_document), do: "#{@jido_ns}ExternalDocumentSource"

  defp literal(value), do: {:literal, value}
  defp literal(value, :datetime), do: {:literal, DateTime.to_iso8601(value), "xsd:dateTime"}

  # Store management (session-isolated)
  defp get_or_create_store(session_id) do
    JidoCode.Memory.LongTerm.StoreManager.get_or_create(session_id)
  end

  defp get_store(session_id) do
    JidoCode.Memory.LongTerm.StoreManager.get(session_id)
  end

  defp persist_store(session_id, store) do
    JidoCode.Memory.LongTerm.StoreManager.persist(session_id, store)
  end

  defp load_memory(store, subject) do
    # Load all properties for a memory subject
    props = TripleStore.query(store, {subject, :_p, :_o})
    
    %{
      id: extract_id(subject),
      content: find_prop(props, "summary"),
      memory_type: find_type(props),
      confidence: confidence_to_float(find_prop(props, "hasConfidence")),
      source_type: source_to_atom(find_prop(props, "hasSourceType")),
      session_id: extract_id(find_prop(props, "assertedIn")),
      timestamp: find_prop(props, "hasTimestamp"),
      rationale: find_prop(props, "rationale")
    }
  end

  defp extract_id(uri) when is_binary(uri) do
    uri |> String.split("_") |> List.last()
  end

  defp find_prop(props, name) do
    target = prop(name)
    case Enum.find(props, fn {_s, p, _o} -> p == target end) do
      {_, _, {:literal, value}} -> value
      {_, _, {:literal, value, _type}} -> value
      {_, _, value} -> value
      nil -> nil
    end
  end

  defp find_type(props) do
    type_uri = rdf_type_uri()
    case Enum.find(props, fn {_s, p, _o} -> p == type_uri end) do
      {_, _, class_uri} -> class_to_atom(class_uri)
      nil -> :unknown
    end
  end

  defp class_to_atom(uri) do
    uri
    |> String.replace(@jido_ns, "")
    |> Macro.underscore()
    |> String.to_atom()
  end

  defp confidence_to_float("#{@jido_ns}High"), do: 0.9
  defp confidence_to_float("#{@jido_ns}Medium"), do: 0.6
  defp confidence_to_float("#{@jido_ns}Low"), do: 0.3
  defp confidence_to_float(_), do: 0.5

  defp source_to_atom("#{@jido_ns}UserSource"), do: :user
  defp source_to_atom("#{@jido_ns}AgentSource"), do: :agent
  defp source_to_atom("#{@jido_ns}ToolSource"), do: :tool
  defp source_to_atom("#{@jido_ns}ExternalDocumentSource"), do: :external_document
  defp source_to_atom(_), do: :agent
end
```

---

## Promotion Engine

The promotion engine combines **implicit signals** (access patterns, recency) with **agent self-determination** (explicit remember commands).

### Importance Scoring

```elixir
defmodule JidoCode.Memory.Promotion.ImportanceScorer do
  @moduledoc """
  Calculates importance scores for promotion decisions.
  Score components:
  - Recency: How recently was this accessed?
  - Frequency: How often has it been accessed?
  - Confidence: How confident are we in this information?
  - Type salience: Is this type inherently important?
  """

  @recency_weight 0.2
  @frequency_weight 0.3
  @confidence_weight 0.25
  @salience_weight 0.25

  @frequency_cap 10

  # Memory types with inherent high salience
  @high_salience_types [:decision, :architectural_decision, :convention, 
                        :coding_standard, :lesson_learned, :risk]

  def score(item) do
    recency = recency_score(item.last_accessed)
    frequency = frequency_score(item.access_count)
    confidence = item.confidence
    salience = salience_score(item.suggested_type)
    
    (@recency_weight * recency) +
    (@frequency_weight * frequency) +
    (@confidence_weight * confidence) +
    (@salience_weight * salience)
  end

  defp recency_score(last_accessed) do
    minutes_ago = DateTime.diff(DateTime.utc_now(), last_accessed, :minute)
    # Decay: full score at 0 mins, ~0.5 at 60 mins, ~0.1 at 5 hours
    1 / (1 + minutes_ago / 30)
  end

  defp frequency_score(access_count) do
    min(access_count / @frequency_cap, 1.0)
  end

  defp salience_score(nil), do: 0.3
  defp salience_score(type) when type in @high_salience_types, do: 1.0
  defp salience_score(:fact), do: 0.7
  defp salience_score(:discovery), do: 0.8
  defp salience_score(:hypothesis), do: 0.5
  defp salience_score(:assumption), do: 0.4
  defp salience_score(_), do: 0.3
end
```

### Promotion Engine

```elixir
defmodule JidoCode.Memory.Promotion.Engine do
  @moduledoc """
  Evaluates short-term memory for promotion to long-term storage.
  Runs periodically and on session events (pause, close).
  """

  alias JidoCode.Memory.{ShortTerm, LongTerm}
  alias JidoCode.Memory.Promotion.ImportanceScorer

  @promotion_threshold 0.6

  @doc """
  Evaluates all pending items and context for promotion.
  Returns list of items ready to promote.
  """
  def evaluate(%ShortTerm{} = memory) do
    # Score all context items
    context_candidates = memory.context.items
    |> Enum.map(fn {_key, item} ->
      build_candidate(item, :implicit)
    end)
    |> Enum.filter(&(&1.suggested_type != nil))  # Only promotable types
    
    # Get pending items (already scored)
    pending_ready = ShortTerm.PendingMemories.ready_for_promotion(
      memory.pending, 
      @promotion_threshold
    )
    
    # Combine and sort by importance
    (context_candidates ++ pending_ready)
    |> Enum.filter(&(&1.importance_score >= @promotion_threshold))
    |> Enum.sort_by(& &1.importance_score, :desc)
  end

  @doc """
  Executes promotion for a list of candidates.
  """
  def promote(candidates, session_id, opts \\ []) do
    agent_id = Keyword.get(opts, :agent_id)
    project_id = Keyword.get(opts, :project_id)
    
    Enum.each(candidates, fn candidate ->
      memory_input = %{
        id: candidate.id || generate_id(),
        content: format_content(candidate),
        memory_type: candidate.suggested_type,
        confidence: candidate.confidence,
        source_type: candidate.source_type,
        session_id: session_id,
        agent_id: agent_id,
        project_id: project_id,
        evidence_refs: candidate.evidence || [],
        rationale: candidate.rationale,
        created_at: DateTime.utc_now()
      }
      
      LongTerm.TripleStoreAdapter.persist(memory_input, session_id)
    end)
  end

  defp build_candidate(context_item, source) do
    %{
      id: nil,
      content: context_item.value,
      suggested_type: context_item.suggested_type,
      confidence: context_item.confidence,
      source_type: map_source(context_item.source),
      evidence: [],
      rationale: nil,
      suggested_by: source,
      importance_score: ImportanceScorer.score(context_item),
      created_at: context_item.first_seen,
      access_count: context_item.access_count
    }
  end

  defp map_source(:explicit), do: :user
  defp map_source(:tool), do: :tool
  defp map_source(_), do: :agent

  defp format_content(%{value: v}) when is_binary(v), do: v
  defp format_content(%{value: v, key: k}), do: "#{k}: #{inspect(v)}"
  defp format_content(%{content: c}), do: c

  defp generate_id do
    :crypto.strong_rand_bytes(16) |> Base.encode16(case: :lower)
  end
end
```

---

## Agent Memory Tools

The LLM can explicitly manage its memory through Jido actions:

### Remember Tool (Agent Self-Determination)

```elixir
defmodule JidoCode.Memory.Tools.Remember do
  @moduledoc """
  Tool for the LLM to explicitly persist a memory.
  Uses jido:AgentSource and bypasses importance threshold.
  """

  use Jido.Action,
    name: "remember",
    description: """
    Persist important information to long-term memory.
    Use when you discover something valuable for future sessions:
    - Project facts (framework, dependencies, architecture)
    - User preferences and coding style
    - Successful solutions to problems
    - Important patterns or conventions
    - Risks or known issues
    """,
    schema: [
      content: [type: :string, required: true, doc: "What to remember"],
      type: [
        type: {:in, [:fact, :assumption, :hypothesis, :discovery, 
                     :risk, :unknown, :decision, :convention, :lesson_learned]},
        default: :fact,
        doc: "Type of memory (maps to Jido ontology class)"
      ],
      confidence: [
        type: :float, 
        default: 0.8,
        doc: "Confidence level (0.0-1.0, maps to jido:ConfidenceLevel)"
      ],
      rationale: [type: :string, doc: "Why this is worth remembering"]
    ]

  def run(params, context) do
    pending_item = %{
      id: generate_id(),
      content: params.content,
      suggested_type: params.type,
      confidence: params.confidence,
      source_type: :agent,
      evidence: [],
      rationale: params[:rationale],
      suggested_by: :agent,
      importance_score: 1.0,  # Bypass threshold
      created_at: DateTime.utc_now(),
      access_count: 1
    }
    
    # Add to agent decisions (will be promoted immediately)
    JidoCode.Memory.SessionServer.add_agent_memory_decision(
      context.session_id,
      pending_item
    )
    
    {:ok, %{
      remembered: true, 
      memory_type: params.type,
      id: pending_item.id
    }}
  end

  defp generate_id do
    :crypto.strong_rand_bytes(12) |> Base.encode16(case: :lower)
  end
end
```

### Recall Tool (Query Long-Term Memory)

```elixir
defmodule JidoCode.Memory.Tools.Recall do
  @moduledoc """
  Tool for querying long-term memory.
  Agent must have jido:CanQueryMemory capability.
  """

  use Jido.Action,
    name: "recall",
    description: """
    Search long-term memory for relevant information.
    Use to retrieve previously learned facts, decisions, patterns, or lessons.
    """,
    schema: [
      query: [type: :string, doc: "Natural language query or keywords"],
      type: [
        type: {:in, [:all, :fact, :assumption, :hypothesis, :discovery,
                     :risk, :decision, :convention, :lesson_learned]},
        default: :all,
        doc: "Filter by memory type"
      ],
      min_confidence: [type: :float, default: 0.5],
      limit: [type: :integer, default: 10]
    ]

  def run(params, context) do
    results = if params.type == :all do
      JidoCode.Memory.LongTerm.TripleStoreAdapter.query_all(
        context.session_id,
        min_confidence: params.min_confidence,
        limit: params.limit
      )
    else
      JidoCode.Memory.LongTerm.TripleStoreAdapter.query_by_type(
        context.session_id,
        params.type,
        limit: params.limit
      )
    end
    
    # Record access for all retrieved memories
    Enum.each(results, fn mem ->
      JidoCode.Memory.LongTerm.TripleStoreAdapter.record_access(
        context.session_id, 
        mem.id
      )
    end)
    
    {:ok, %{
      memories: results,
      count: length(results)
    }}
  end
end
```

### Forget Tool (Supersede Memory)

```elixir
defmodule JidoCode.Memory.Tools.Forget do
  @moduledoc """
  Tool for marking memories as superseded.
  Uses jido:supersededBy property rather than hard delete.
  """

  use Jido.Action,
    name: "forget",
    description: """
    Mark a memory as superseded (soft delete).
    The memory remains for provenance but won't be retrieved in normal queries.
    Use when information is outdated or incorrect.
    """,
    schema: [
      memory_id: [type: :string, required: true],
      reason: [type: :string, doc: "Why this memory is being superseded"],
      replacement_id: [type: :string, doc: "ID of memory that supersedes this"]
    ]

  def run(params, context) do
    if params[:replacement_id] do
      JidoCode.Memory.LongTerm.TripleStoreAdapter.supersede(
        context.session_id,
        params.memory_id,
        params.replacement_id
      )
    end
    
    # Could also add a "superseded" timestamp triple
    
    {:ok, %{
      forgotten: true,
      memory_id: params.memory_id,
      reason: params[:reason]
    }}
  end
end
```

---

## Session Server Integration

```elixir
defmodule JidoCode.Memory.SessionServer do
  @moduledoc """
  Per-session GenServer managing the two-tier memory system.
  """

  use GenServer, restart: :transient

  alias JidoCode.Memory.{ShortTerm, Promotion}

  defstruct [:session_id, :memory, :project_id, :agent_id]

  @promotion_interval_ms 30_000  # Check every 30 seconds

  # Client API

  def start_link(opts) do
    session_id = Keyword.fetch!(opts, :session_id)
    GenServer.start_link(__MODULE__, opts, name: via(session_id))
  end

  def add_message(session_id, message) do
    GenServer.call(via(session_id), {:add_message, message})
  end

  def update_context(session_id, key, value, opts \\ []) do
    GenServer.call(via(session_id), {:update_context, key, value, opts})
  end

  def get_context(session_id, key) do
    GenServer.call(via(session_id), {:get_context, key})
  end

  def add_agent_memory_decision(session_id, pending_item) do
    GenServer.cast(via(session_id), {:agent_memory_decision, pending_item})
  end

  def assemble_context(session_id, opts \\ []) do
    GenServer.call(via(session_id), {:assemble_context, opts})
  end

  def force_promotion(session_id) do
    GenServer.call(via(session_id), :force_promotion)
  end

  # Server Callbacks

  @impl true
  def init(opts) do
    session_id = Keyword.fetch!(opts, :session_id)
    project_id = Keyword.get(opts, :project_id)
    agent_id = Keyword.get(opts, :agent_id)
    
    schedule_promotion()
    
    {:ok, %__MODULE__{
      session_id: session_id,
      memory: ShortTerm.new(session_id),
      project_id: project_id,
      agent_id: agent_id
    }}
  end

  @impl true
  def handle_call({:add_message, message}, _from, state) do
    {updated_conv, evicted} = ShortTerm.ConversationBuffer.add(
      state.memory.conversation,
      message
    )
    
    # Evicted messages could be analyzed for memories
    # (This is where message summarization could happen)
    
    updated_memory = %{state.memory | conversation: updated_conv}
    {:reply, {:ok, length(evicted)}, %{state | memory: updated_memory}}
  end

  @impl true
  def handle_call({:update_context, key, value, opts}, _from, state) do
    updated_context = ShortTerm.WorkingContext.put(
      state.memory.context,
      key,
      value,
      opts
    )
    updated_memory = %{state.memory | context: updated_context}
    {:reply, :ok, %{state | memory: updated_memory}}
  end

  @impl true
  def handle_call({:get_context, key}, _from, state) do
    {updated_context, value} = ShortTerm.WorkingContext.get(
      state.memory.context,
      key
    )
    updated_memory = %{state.memory | context: updated_context}
    result = if value, do: {:ok, value}, else: {:error, :not_found}
    {:reply, result, %{state | memory: updated_memory}}
  end

  @impl true
  def handle_call({:assemble_context, opts}, _from, state) do
    # Combine short-term and long-term memory for LLM context
    token_budget = Keyword.get(opts, :token_budget, 30_000)
    query_hint = Keyword.get(opts, :query_hint)
    
    # Get conversation history
    conversation = ShortTerm.ConversationBuffer.to_list(state.memory.conversation)
    
    # Get working context
    working = state.memory.context.items
    |> Enum.map(fn {k, v} -> {k, v.value} end)
    |> Map.new()
    
    # Query long-term memory (if query hint provided)
    long_term = if query_hint do
      JidoCode.Memory.LongTerm.TripleStoreAdapter.query_all(
        state.session_id,
        limit: 10
      )
    else
      JidoCode.Memory.LongTerm.TripleStoreAdapter.query_all(
        state.session_id,
        min_confidence: 0.7,
        limit: 5
      )
    end
    
    context = %{
      conversation: conversation,
      working_context: working,
      long_term_memories: long_term
    }
    
    {:reply, {:ok, context}, state}
  end

  @impl true
  def handle_call(:force_promotion, _from, state) do
    run_promotion(state)
    {:reply, :ok, state}
  end

  @impl true
  def handle_cast({:agent_memory_decision, item}, state) do
    updated_pending = ShortTerm.PendingMemories.add_agent_decision(
      state.memory.pending,
      item
    )
    updated_memory = %{state.memory | pending: updated_pending}
    
    # Immediately promote agent decisions
    Promotion.Engine.promote([item], state.session_id,
      agent_id: state.agent_id,
      project_id: state.project_id
    )
    
    {:noreply, %{state | memory: updated_memory}}
  end

  @impl true
  def handle_info(:run_promotion, state) do
    run_promotion(state)
    schedule_promotion()
    {:noreply, state}
  end

  @impl true
  def terminate(_reason, state) do
    # Final promotion on shutdown
    run_promotion(state)
    :ok
  end

  # Private

  defp run_promotion(state) do
    candidates = Promotion.Engine.evaluate(state.memory)
    
    if candidates != [] do
      Promotion.Engine.promote(candidates, state.session_id,
        agent_id: state.agent_id,
        project_id: state.project_id
      )
    end
  end

  defp schedule_promotion do
    Process.send_after(self(), :run_promotion, @promotion_interval_ms)
  end

  defp via(session_id) do
    {:via, Registry, {JidoCode.Memory.SessionRegistry, session_id}}
  end
end
```

---

## Supervision Tree

```elixir
defmodule JidoCode.Memory.Supervisor do
  use Supervisor

  def start_link(opts) do
    Supervisor.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    children = [
      # Registry for session lookup
      {Registry, keys: :unique, name: JidoCode.Memory.SessionRegistry},
      
      # Long-term store manager
      JidoCode.Memory.LongTerm.StoreManager,
      
      # Dynamic supervisor for sessions
      {DynamicSupervisor,
        strategy: :one_for_one,
        name: JidoCode.Memory.SessionSupervisor,
        max_children: 1000}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end
end
```

---

## Module Structure

```
lib/jido_code/memory/
├── memory.ex                      # Public API facade
├── supervisor.ex                  # Top-level supervisor
│
├── short_term/
│   ├── short_term.ex             # Container struct
│   ├── conversation_buffer.ex    # Sliding window messages
│   ├── working_context.ex        # Semantic scratchpad
│   ├── pending_memories.ex       # Pre-promotion staging
│   └── access_log.ex             # Usage tracking
│
├── long_term/
│   ├── triple_store_adapter.ex   # Jido ontology ↔ triple_store
│   ├── store_manager.ex          # Session-isolated store lifecycle
│   └── query.ex                  # Advanced query patterns
│
├── promotion/
│   ├── engine.ex                 # Evaluation and promotion logic
│   └── importance_scorer.ex      # Scoring algorithm
│
├── session_server.ex             # Per-session GenServer
│
└── tools/
    ├── remember.ex               # Agent self-determination
    ├── recall.ex                 # Query long-term memory
    └── forget.ex                 # Supersede memories
```

---

## Key Differences from Original Design

| Aspect | Original Design | Revised Design |
|--------|-----------------|----------------|
| **Ontology** | Created new `jmem:` namespace with parallel classes | Uses existing `jido:` classes directly |
| **Memory types** | `EpisodicMemory`, `SemanticMemory`, `ProceduralMemory` | `Fact`, `Assumption`, `Hypothesis`, `Discovery`, etc. from jido-knowledge |
| **Confidence** | Custom `jmem:confidence` decimal property | Uses `jido:hasConfidence` → `jido:ConfidenceLevel` (High/Medium/Low) |
| **Source tracking** | Custom `jmem:extractedBy` | Uses `jido:hasSourceType` → `jido:SourceType` |
| **Session scoping** | Custom `jmem:Session` class | Uses `jido:WorkSession` from jido-session |
| **Agent attribution** | Custom properties | Uses `jido:assertedBy` → `jido:Agent` |
| **Supersession** | Custom `jmem:supersedes` | Uses `jido:supersededBy` from jido-core |

---

## Summary

This revised design **eliminates the parallel ontology** and directly leverages your existing Jido OWL classes:

1. **Short-term memory** remains ephemeral Elixir state (conversation buffer, working context, pending items)
2. **Long-term memory** instantiates `jido:MemoryItem` subclasses (`Fact`, `Assumption`, `Hypothesis`, `Discovery`, `Risk`, `Unknown`, `Decision`, `Convention`, `LessonLearned`, etc.)
3. **Promotion** uses importance scoring (recency, frequency, confidence, type salience) plus agent self-determination via the `remember` tool
4. **Provenance** uses existing properties: `assertedBy`, `assertedIn`, `hasConfidence`, `hasSourceType`, `derivedFrom`, `supersededBy`
5. **Session isolation** scopes memories using `jido:assertedIn` → `jido:WorkSession`

The triple_store adapter maps Elixir data structures to/from RDF triples using your existing ontology URIs, ensuring full semantic interoperability with the rest of the JidoCode knowledge graph.
