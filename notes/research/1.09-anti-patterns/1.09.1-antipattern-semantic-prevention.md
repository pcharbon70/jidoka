# Semantic Prevention System for Elixir Code Smells in JidoCode

An LLM-based coding assistant generating Elixir code must avoid **35 documented code smells** spanning process anti-patterns, design flaws, and low-level issues. This report presents a hybrid prevention architecture combining pre-generation SPARQL queries against a project ontology, prompt-based rules during generation, and post-generation semantic validation—integrating with existing Credo static analysis to create a comprehensive smell prevention pipeline.

## Complete Elixir code smells catalog and detectability matrix

The canonical Elixir Code Smells catalog (Vegi & Valente, EMSE 2023) documents **23 Elixir-specific smells** and **12 traditional smells** adapted for functional programming. Critical for JidoCode is understanding which smells can be prevented at which stage.

### Design-related smells (14 total)

| Smell | Description | Detectability | Prevention Stage |
|-------|-------------|---------------|------------------|
| **GenServer Envy** | Using Task/Agent beyond intended purpose | Semantic | Pre-generation context |
| **Agent Obsession** | Agent access scattered across modules | Semantic | Post-generation SPARQL |
| **Unsupervised Process** | Long-running processes outside supervision trees | Semantic | Post-generation SPARQL |
| **Large Messages** | Processes exchanging huge structures frequently | Runtime-only | Prompt warning only |
| **Unrelated Multi-Clause Function** | Too many unrelated patterns in one function | AST | Credo + Prompt |
| **Complex Extractions in Clauses** | Pattern-matching overload in function heads | AST | Credo + Prompt |
| **Using Exceptions for Control-Flow** | Libraries forcing exception handling vs tuples | AST | Prompt rules |
| **Untested Polymorphic Behaviors** | Protocol implementations without guards | Semantic | Prompt rules |
| **Code Organization by Process** | Unnecessary GenServer for pure computation | Semantic | Post-generation SPARQL |
| **Large Code Generation by Macros** | Macro expansions creating excessive code | AST | Prompt rules |
| **Data Manipulation by Migration** | Mixing schema changes with data transforms | AST | Prompt rules |
| **Using App Configuration for Libraries** | Application.get_env in library code | AST | Credo (ApplicationConfigInModuleAttribute) |
| **Compile-time Global Configuration** | Module attributes evaluating config at compile time | AST | Credo + Prompt |
| **"Use" Instead of "Import"** | Overusing `use` when `import` suffices | AST | Prompt rules |

### Low-level concern smells (9 total)

| Smell | Description | Detectability | Prevention Stage |
|-------|-------------|---------------|------------------|
| **Working with Invalid Data** | Missing boundary validation | Semantic | Prompt rules |
| **Complex Branching** | Deep conditional nesting | AST | Credo (CyclomaticComplexity, Nesting) |
| **Complex else Clauses in with** | Flattening all errors into single else block | AST | Prompt rules |
| **Alternative Return Types** | Parameters that change return type | Semantic | Prompt rules |
| **Accessing Non-Existent Map/Struct Fields** | Dynamic access returning nil | AST | Prompt rules |
| **Speculative Assumptions** | Returning defaults when crash is appropriate | Semantic | Prompt rules |
| **Modules with Identical Names** | Duplicate module definitions | AST | Credo (potential custom check) |
| **Unnecessary Macros** | Macros where functions suffice | AST | Prompt rules |
| **Dynamic Atom Creation** | `String.to_atom(user_input)` | AST | Prompt rules (critical) |

### Traditional smells in Elixir context (12 total)

The traditional Fowler/Beck smells requiring Elixir-specific treatment: **Long Parameter List** (Credo FunctionArity), **Long Function** (Credo CyclomaticComplexity), **Large Module** (semantic), **Duplicated Code** (Credo DuplicatedCode), **Primitive Obsession** (semantic), **Feature Envy** (semantic), **Shotgun Surgery** (semantic), **Divergent Change** (semantic), **Inappropriate Intimacy** (semantic), **Speculative Generality** (semantic), **Switch Statements** (AST/prompt), and **Comments** as code (Credo TagTODO/TagFIXME).

### Detectability classification summary

**AST-detectable (15 smells)**: Can be caught by Credo or simple pattern matching during generation—these are prime candidates for prompt-based prevention.

**Semantic-detectable (13 smells)**: Require understanding relationships between modules, functions, and processes—these need SPARQL queries against the project ontology.

**Runtime-only (1 smell)**: Large Messages can only be detected through runtime monitoring and cannot be reliably prevented at generation time.

---

## OWL ontology design for Elixir code smell representation

The ontology must model Elixir's unique constructs (GenServer, Supervisor, processes) alongside standard code entities, then define smell patterns as detectable violations.

### Core class hierarchy

```turtle
@prefix ex: <http://jidocode.org/elixir-ontology#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

# Base code entities
ex:CodeEntity a owl:Class .
ex:Module a owl:Class ; rdfs:subClassOf ex:CodeEntity .
ex:Function a owl:Class ; rdfs:subClassOf ex:CodeEntity .
ex:Macro a owl:Class ; rdfs:subClassOf ex:CodeEntity .

# Elixir process abstractions
ex:ProcessAbstraction a owl:Class ; rdfs:subClassOf ex:CodeEntity .
ex:GenServer a owl:Class ; rdfs:subClassOf ex:ProcessAbstraction .
ex:Supervisor a owl:Class ; rdfs:subClassOf ex:ProcessAbstraction .
ex:DynamicSupervisor a owl:Class ; rdfs:subClassOf ex:Supervisor .
ex:Agent a owl:Class ; rdfs:subClassOf ex:ProcessAbstraction .
ex:Task a owl:Class ; rdfs:subClassOf ex:ProcessAbstraction .

# GenServer callbacks
ex:Callback a owl:Class ; rdfs:subClassOf ex:Function .
ex:HandleCall a owl:Class ; rdfs:subClassOf ex:Callback .
ex:HandleCast a owl:Class ; rdfs:subClassOf ex:Callback .
ex:HandleInfo a owl:Class ; rdfs:subClassOf ex:Callback .
ex:Init a owl:Class ; rdfs:subClassOf ex:Callback .

# Code smell hierarchy
ex:CodeSmell a owl:Class .
ex:DesignSmell a owl:Class ; rdfs:subClassOf ex:CodeSmell .
ex:ProcessSmell a owl:Class ; rdfs:subClassOf ex:CodeSmell .
ex:LowLevelSmell a owl:Class ; rdfs:subClassOf ex:CodeSmell .

# Specific smell types (instantiated when detected)
ex:UnsupervisedProcessSmell a owl:Class ; rdfs:subClassOf ex:ProcessSmell .
ex:AgentObsessionSmell a owl:Class ; rdfs:subClassOf ex:ProcessSmell .
ex:CodeOrganizationByProcessSmell a owl:Class ; rdfs:subClassOf ex:ProcessSmell .
ex:CircularDependencySmell a owl:Class ; rdfs:subClassOf ex:DesignSmell .
ex:GodModuleSmell a owl:Class ; rdfs:subClassOf ex:DesignSmell .
ex:FeatureEnvySmell a owl:Class ; rdfs:subClassOf ex:DesignSmell .
```

### Essential object properties for smell detection

```turtle
# Containment and structure
ex:containsFunction a owl:ObjectProperty ;
    rdfs:domain ex:Module ; rdfs:range ex:Function .
ex:containsMacro a owl:ObjectProperty ;
    rdfs:domain ex:Module ; rdfs:range ex:Macro .

# Call and dependency relationships
ex:calls a owl:ObjectProperty ;
    rdfs:domain ex:Function ; rdfs:range ex:Function .
ex:dependsOn a owl:ObjectProperty, owl:TransitiveProperty ;
    rdfs:domain ex:Module ; rdfs:range ex:Module .
ex:uses a owl:ObjectProperty ;
    rdfs:domain ex:Module ; rdfs:range ex:Module .

# Process-specific relationships (critical for Elixir)
ex:supervises a owl:ObjectProperty ;
    rdfs:domain ex:Supervisor ; rdfs:range ex:ProcessAbstraction .
ex:supervisedBy a owl:ObjectProperty ;
    owl:inverseOf ex:supervises .
ex:accessesAgent a owl:ObjectProperty ;
    rdfs:domain ex:Function ; rdfs:range ex:Agent .
ex:spawnsProcess a owl:ObjectProperty ;
    rdfs:domain ex:Function ; rdfs:range ex:ProcessAbstraction .
ex:sendsMessage a owl:ObjectProperty ;
    rdfs:domain ex:Function ; rdfs:range ex:ProcessAbstraction .

# Smell relationships
ex:hasSmell a owl:ObjectProperty ;
    rdfs:domain ex:CodeEntity ; rdfs:range ex:CodeSmell .
ex:affectsEntity a owl:ObjectProperty ;
    rdfs:domain ex:CodeSmell ; rdfs:range ex:CodeEntity .
```

### Data properties for metrics-based detection

```turtle
ex:functionCount a owl:DatatypeProperty ; rdfs:domain ex:Module ; rdfs:range xsd:integer .
ex:arity a owl:DatatypeProperty ; rdfs:domain ex:Function ; rdfs:range xsd:integer .
ex:clauseCount a owl:DatatypeProperty ; rdfs:domain ex:Function ; rdfs:range xsd:integer .
ex:lineCount a owl:DatatypeProperty ; rdfs:domain ex:Function ; rdfs:range xsd:integer .
ex:cyclomaticComplexity a owl:DatatypeProperty ; rdfs:domain ex:Function ; rdfs:range xsd:integer .
ex:isPublic a owl:DatatypeProperty ; rdfs:domain ex:Function ; rdfs:range xsd:boolean .
ex:modifiesState a owl:DatatypeProperty ; rdfs:domain ex:Callback ; rdfs:range xsd:boolean .
```

### SHACL shapes for constraint validation

SHACL operates under Closed World Assumption, making it ideal for detecting violations. Key shapes for Elixir smells:

```turtle
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix ex: <http://jidocode.org/elixir-ontology#> .

# Unsupervised Process Detection
ex:SupervisedProcessShape a sh:NodeShape ;
    sh:targetClass ex:GenServer, ex:Agent ;
    sh:property [
        sh:path ex:supervisedBy ;
        sh:minCount 1 ;
        sh:severity sh:Warning ;
        sh:message "Process should be under supervision tree"
    ] .

# Agent Obsession Detection (accessed from multiple modules)
ex:CentralizedAgentAccessShape a sh:NodeShape ;
    sh:targetClass ex:Agent ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "Agent accessed from {?accessCount} modules (scattered interface)" ;
        sh:severity sh:Warning ;
        sh:select """
            PREFIX ex: <http://jidocode.org/elixir-ontology#>
            SELECT $this (COUNT(DISTINCT ?module) as ?accessCount)
            WHERE {
                ?func ex:accessesAgent $this .
                ?module ex:containsFunction ?func .
            }
            GROUP BY $this
            HAVING (COUNT(DISTINCT ?module) > 1)
        """
    ] .

# Code Organization by Process (GenServer without state modification)
ex:StatelessGenServerShape a sh:NodeShape ;
    sh:targetClass ex:GenServer ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "GenServer may be used for code organization rather than state management" ;
        sh:severity sh:Info ;
        sh:select """
            PREFIX ex: <http://jidocode.org/elixir-ontology#>
            SELECT $this
            WHERE {
                $this a ex:GenServer .
                FILTER NOT EXISTS {
                    $this ex:hasCallback ?callback .
                    ?callback ex:modifiesState true .
                }
            }
        """
    ] .

# God Module Detection
ex:GodModuleShape a sh:NodeShape ;
    sh:targetClass ex:Module ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "Module has {?funcCount} public functions (threshold: 20)" ;
        sh:severity sh:Warning ;
        sh:select """
            PREFIX ex: <http://jidocode.org/elixir-ontology#>
            SELECT $this ?funcCount
            WHERE {
                $this ex:functionCount ?funcCount .
                FILTER(?funcCount > 20)
            }
        """
    ] .
```

---

## SPARQL query patterns for each detectable smell

Organized by SPARQL feature complexity, these queries run against the pre-generated project ontology.

### Simple triple patterns (basic relationship queries)

**Unsupervised Process Detection:**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?process ?processName ?module
WHERE {
    ?process a ex:GenServer .
    ?process ex:definedIn ?module .
    ?process ex:name ?processName .
    FILTER NOT EXISTS {
        ?supervisor ex:supervises ?process .
    }
}
```

**Unrelated Multi-Clause Function:**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?function ?functionName ?clauseCount
WHERE {
    ?function a ex:Function ;
              ex:name ?functionName ;
              ex:clauseCount ?clauseCount .
    FILTER(?clauseCount > 5)
}
ORDER BY DESC(?clauseCount)
```

### Aggregation patterns (COUNT, GROUP BY, HAVING)

**Agent Obsession (scattered access):**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?agent ?agentName (COUNT(DISTINCT ?module) AS ?accessingModules)
WHERE {
    ?agent a ex:Agent ;
           ex:name ?agentName .
    ?func ex:accessesAgent ?agent .
    ?module ex:containsFunction ?func .
}
GROUP BY ?agent ?agentName
HAVING (COUNT(DISTINCT ?module) > 1)
ORDER BY DESC(?accessingModules)
```

**God Module Detection:**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?module ?moduleName (COUNT(?func) AS ?funcCount)
WHERE {
    ?module a ex:Module ;
            ex:name ?moduleName ;
            ex:containsFunction ?func .
    ?func ex:isPublic true .
}
GROUP BY ?module ?moduleName
HAVING (COUNT(?func) > 20)
ORDER BY DESC(?funcCount)
```

**Feature Envy (function uses more external than internal):**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?function ?functionName ?homeModule
       (COUNT(DISTINCT ?internalCall) AS ?internal)
       (COUNT(DISTINCT ?externalCall) AS ?external)
WHERE {
    ?function a ex:Function ;
              ex:name ?functionName ;
              ex:definedIn ?homeModule .
    
    OPTIONAL {
        ?function ex:calls ?internalTarget .
        ?internalTarget ex:definedIn ?homeModule .
        BIND(?internalTarget AS ?internalCall)
    }
    
    OPTIONAL {
        ?function ex:calls ?externalTarget .
        ?externalTarget ex:definedIn ?otherModule .
        FILTER(?otherModule != ?homeModule)
        BIND(?externalTarget AS ?externalCall)
    }
}
GROUP BY ?function ?functionName ?homeModule
HAVING (COUNT(DISTINCT ?externalCall) > COUNT(DISTINCT ?internalCall) * 2)
```

### Property path patterns (transitive relationships)

**Circular Dependency Detection:**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT DISTINCT ?moduleA ?moduleB
WHERE {
    ?moduleA ex:dependsOn+ ?moduleB .
    ?moduleB ex:dependsOn+ ?moduleA .
    FILTER(STR(?moduleA) < STR(?moduleB))  # Avoid duplicate pairs
}
```

**Deep Supervision Tree (potential complexity smell):**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?rootSupervisor ?depth
WHERE {
    ?rootSupervisor a ex:Supervisor .
    FILTER NOT EXISTS { ?parent ex:supervises ?rootSupervisor }
    
    {
        SELECT ?rootSupervisor (COUNT(?intermediate) AS ?depth)
        WHERE {
            ?rootSupervisor ex:supervises+ ?intermediate .
            ?intermediate a ex:ProcessAbstraction .
        }
        GROUP BY ?rootSupervisor
    }
    FILTER(?depth > 4)
}
ORDER BY DESC(?depth)
```

### NOT EXISTS patterns (orphan/unused detection)

**Orphaned Functions (never called):**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?function ?functionName ?module
WHERE {
    ?function a ex:Function ;
              ex:name ?functionName ;
              ex:definedIn ?module ;
              ex:isPublic true .
    
    FILTER NOT EXISTS { ?function ex:isCallback true }
    FILTER NOT EXISTS { ?function ex:isEntryPoint true }
    FILTER NOT EXISTS { ?caller ex:calls ?function }
}
```

**Code Organization by Process (GenServer with no state modification):**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>

SELECT ?genserver ?name
WHERE {
    ?genserver a ex:GenServer ;
               ex:name ?name .
    
    FILTER NOT EXISTS {
        ?genserver ex:hasCallback ?callback .
        ?callback ex:modifiesState true .
    }
}
```

### CONSTRUCT queries for smell instance creation

**Generate smell instances for integration with feedback loop:**
```sparql
PREFIX ex: <http://jidocode.org/elixir-ontology#>
PREFIX smell: <http://jidocode.org/smell#>

CONSTRUCT {
    ?smellInstance a smell:UnsupervisedProcessSmell ;
                   smell:affectsProcess ?process ;
                   smell:processName ?name ;
                   smell:severity "warning" ;
                   smell:recommendation "Add to supervision tree using Supervisor or DynamicSupervisor" .
}
WHERE {
    ?process a ex:GenServer ;
             ex:name ?name .
    FILTER NOT EXISTS { ?supervisor ex:supervises ?process }
    BIND(IRI(CONCAT(STR(smell:), "unsupervised_", ENCODE_FOR_URI(?name))) AS ?smellInstance)
}
```

---

## Condensed system prompt guide for LLM smell prevention

The system prompt must be comprehensive yet concise. Research shows **anti-pattern avoidance prompts reduce code weaknesses by 59-64%**. This guide prioritizes smells LLMs commonly generate.

### High-priority smell prevention rules (include in every Elixir generation prompt)

```markdown
<elixir_code_standards>

## Process and OTP Patterns
- ALWAYS place GenServer/Agent/Task under supervision trees
- Use GenServer ONLY when you need stateful operations; pure functions don't need processes
- Encapsulate ALL Agent access in a single wrapper module with clean API
- Use `handle_call/3` for sync operations requiring response, `handle_cast/2` for async
- NEVER block in `init/1`—use `{:ok, state, {:continue, :setup}}` for async initialization

## Function Design
- Return `{:ok, result}` or `{:error, reason}` tuples, NOT exceptions for control flow
- Validate data at function boundaries with guards: `def process(data) when is_map(data)`
- Keep function clauses related—split unrelated logic into separate functions
- Pattern match in function heads, extract complex values in body only when needed
- Maximum 5 parameters per function; use keyword options or structs for more

## Safe Elixir Practices
❌ NEVER: `String.to_atom(user_input)` — atoms are never garbage collected
✅ ALWAYS: `String.to_existing_atom(input)` or use strings for dynamic values

❌ NEVER: `Application.get_env` in module attributes
✅ ALWAYS: Call configuration at runtime, not compile time

❌ NEVER: Deep nesting with case/cond inside case/cond
✅ ALWAYS: Extract to well-named helper functions or use `with` appropriately

## Module Organization
- Use `import` when you only need functions; reserve `use` for macros/behaviors
- Avoid macros when functions suffice—macros add compile-time complexity
- Libraries should accept configuration as function arguments, not Application env

</elixir_code_standards>
```

### Context-triggered warning injection

When the LLM is about to generate specific patterns, inject targeted warnings:

| Generation Context | Injected Warning |
|-------------------|------------------|
| `GenServer` module | "Ensure this GenServer is added to a supervision tree. If no state is modified, consider using a plain module instead." |
| `Agent.start` or `Agent.get/update` | "Encapsulate all Agent access in a single wrapper module to avoid scattered interface anti-pattern." |
| Multi-clause function with >3 patterns | "Verify all clauses are logically related. Consider splitting if patterns represent different concerns." |
| `with` statement | "Avoid complex else clauses. Handle each potential error specifically or let it crash." |
| `String.to_atom` | "CRITICAL: Never create atoms from user input. Use String.to_existing_atom or keep as string." |
| `Application.get_env` in `@attribute` | "Move runtime config reads out of module attributes to avoid compile-time binding." |

### DO/DON'T examples format (maximum LLM comprehension)

```markdown
## Supervision Pattern
❌ DON'T:
```elixir
# Process created without supervision
{:ok, pid} = GenServer.start_link(Counter, 0)
```

✅ DO:
```elixir
# Under DynamicSupervisor
DynamicSupervisor.start_child(MyApp.ProcessSupervisor, {Counter, 0})
```
Reason: Unsupervised processes can't be monitored, restarted, or cleanly shutdown.

## Agent Access Pattern
❌ DON'T:
```elixir
# Scattered across multiple modules
defmodule A do
  def get(agent), do: Agent.get(agent, & &1)
end
defmodule B do
  def update(agent, val), do: Agent.update(agent, fn _ -> val end)
end
```

✅ DO:
```elixir
# Centralized wrapper
defmodule StateManager do
  def get(agent), do: Agent.get(agent, & &1)
  def update(agent, val), do: Agent.update(agent, fn _ -> val end)
end
```
Reason: Encapsulation reduces maintenance burden and prevents bugs from inconsistent access patterns.
```

---

## Hybrid detection architecture integrating all approaches

The three-phase architecture ensures comprehensive smell prevention at every stage of code generation.

### Phase 1: Pre-generation context injection

Before LLM generates code, query the project ontology to understand existing patterns and inject relevant warnings.

```
┌─────────────────────────────────────────────────────────────────┐
│                    PRE-GENERATION PHASE                         │
├─────────────────────────────────────────────────────────────────┤
│  User Request: "Add a new counter GenServer"                    │
│                            │                                    │
│                            ▼                                    │
│  ┌─────────────────────────────────────────┐                   │
│  │     SPARQL Context Queries              │                   │
│  │  • Find existing supervision trees       │                   │
│  │  • Identify existing GenServer patterns  │                   │
│  │  • Check for Agent usage patterns        │                   │
│  └─────────────────────────────────────────┘                   │
│                            │                                    │
│                            ▼                                    │
│  Context Injection:                                             │
│  "Project uses DynamicSupervisor at MyApp.ProcessSupervisor.   │
│   Existing GenServers follow pattern: client API + callbacks.  │
│   Add new GenServer to supervision tree."                       │
└─────────────────────────────────────────────────────────────────┘
```

**Pre-generation SPARQL queries:**

```sparql
# Find supervision structure for context
SELECT ?supervisor ?strategy ?childCount
WHERE {
    ?supervisor a ex:Supervisor ;
                ex:hasSupervisionStrategy ?strategy .
    OPTIONAL {
        SELECT ?supervisor (COUNT(?child) AS ?childCount)
        WHERE { ?supervisor ex:supervises ?child }
        GROUP BY ?supervisor
    }
}

# Find GenServer patterns in project
SELECT ?genserver (SAMPLE(?callback) AS ?sampleCallback)
WHERE {
    ?genserver a ex:GenServer .
    ?genserver ex:hasCallback ?callback .
}
GROUP BY ?genserver
LIMIT 3
```

### Phase 2: During-generation prompt rules

The condensed smell prevention guide (from section 4) is included in the system prompt. During generation:

- LLM follows embedded rules for AST-detectable smells
- Context-triggered warnings activate based on detected patterns
- Planning phase (using `<thinking>` tags) evaluates smell potential before code output

### Phase 3: Post-generation semantic validation

After LLM produces code, update the ontology and run SPARQL smell detection queries.

```
┌─────────────────────────────────────────────────────────────────┐
│                  POST-GENERATION PHASE                          │
├─────────────────────────────────────────────────────────────────┤
│  Generated Code → AST Parser → Ontology Update                  │
│                            │                                    │
│                            ▼                                    │
│  ┌─────────────────────────────────────────┐                   │
│  │     SPARQL Smell Detection Queries      │                   │
│  │  • Unsupervised process check           │                   │
│  │  • Circular dependency detection         │                   │
│  │  • Agent obsession pattern              │                   │
│  │  • Feature envy analysis                │                   │
│  │  • God module threshold check           │                   │
│  └─────────────────────────────────────────┘                   │
│                            │                                    │
│                            ▼                                    │
│  ┌─────────────────────────────────────────┐                   │
│  │     SHACL Validation Engine             │                   │
│  │  • Run all defined constraint shapes    │                   │
│  │  • Collect violations with severity     │                   │
│  └─────────────────────────────────────────┘                   │
│                            │                                    │
│                            ▼                                    │
│  Detected Smells → Feedback Formatter → LLM Correction Loop    │
└─────────────────────────────────────────────────────────────────┘
```

### Feedback loop for LLM correction

When smells are detected, format them for maximum LLM comprehension and request correction:

```markdown
## Issue Detected
Type: Process Smell - Unsupervised Process
Location: lib/my_app/counter.ex
Severity: Warning
Rule: ex:SupervisedProcessShape

Description: GenServer `MyApp.Counter` is not under any supervision tree.

```elixir
# Current (problematic):
def start_link(initial) do
  GenServer.start_link(__MODULE__, initial)
end
```

Expected Pattern:
```elixir
# Add to existing DynamicSupervisor:
def start_link(initial) do
  DynamicSupervisor.start_child(
    MyApp.ProcessSupervisor, 
    {__MODULE__, initial}
  )
end
```

Instruction: Modify the start_link function to register this GenServer with the project's supervision tree.
```

Research shows iterative refinement with this format achieves **20%+ improvement** in first iteration, with diminishing returns after 3-5 iterations.

---

## Integration with existing Credo prevention system

### Coverage overlap analysis

| Smell Category | Credo Coverage | Gap Analysis |
|----------------|----------------|--------------|
| **Naming conventions** | ✅ Full (FunctionNames, ModuleNames, VariableNames) | None |
| **Complexity metrics** | ✅ Full (CyclomaticComplexity, Nesting, FunctionArity) | None |
| **Debug code** | ✅ Full (IExPry, IoInspect, Dbg) | None |
| **Unused operations** | ✅ Full (Unused*Operation checks) | None |
| **Duplicated code** | ⚠️ Disabled by default (DuplicatedCode) | Enable in config |
| **Module documentation** | ✅ Full (ModuleDoc) | None |
| **Style consistency** | ✅ Full (TabsOrSpaces, spacing checks) | None |
| **Compile-time config** | ✅ Full (ApplicationConfigInModuleAttribute) | None |
| **Process patterns** | ❌ None | Full gap—needs SPARQL |
| **Cross-module relationships** | ❌ Limited (ModuleDependencies disabled) | Full gap—needs SPARQL |
| **Supervision structure** | ❌ None | Full gap—needs SPARQL |
| **Agent/GenServer patterns** | ❌ None | Full gap—needs SPARQL |
| **Feature Envy** | ❌ None | Full gap—needs SPARQL |
| **God Module** | ❌ None | Full gap—needs SPARQL |

### Unified validation pipeline

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     UNIFIED VALIDATION PIPELINE                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Generated Code                                                          │
│       │                                                                  │
│       ├──────────────────────────────────────────────────────────┐      │
│       │                                                          │      │
│       ▼                                                          ▼      │
│  ┌─────────────────────┐                          ┌─────────────────┐   │
│  │   CREDO CHECKS      │                          │  AST → ONTOLOGY │   │
│  │  (AST-based)        │                          │   UPDATE        │   │
│  ├─────────────────────┤                          └────────┬────────┘   │
│  │ • CyclomaticComplex │                                   │            │
│  │ • FunctionArity     │                                   ▼            │
│  │ • Nesting           │                          ┌─────────────────┐   │
│  │ • Naming checks     │                          │ SPARQL QUERIES  │   │
│  │ • DuplicatedCode    │                          │ (Semantic)      │   │
│  │ • IoInspect/IExPry  │                          ├─────────────────┤   │
│  │ • AppConfigInModule │                          │ • CircularDeps  │   │
│  └─────────┬───────────┘                          │ • Unsupervised  │   │
│            │                                      │ • AgentObsession│   │
│            │                                      │ • FeatureEnvy   │   │
│            │                                      │ • GodModule     │   │
│            │                                      └────────┬────────┘   │
│            │                                               │            │
│            └───────────────────┬───────────────────────────┘            │
│                                │                                         │
│                                ▼                                         │
│                    ┌─────────────────────┐                              │
│                    │  ISSUE AGGREGATOR   │                              │
│                    │  & PRIORITY MAPPER  │                              │
│                    └─────────┬───────────┘                              │
│                              │                                          │
│                              ▼                                          │
│                    ┌─────────────────────┐                              │
│                    │   FEEDBACK LOOP     │                              │
│                    │   (if issues found) │                              │
│                    └─────────────────────┘                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Priority and severity alignment

Map SPARQL-detected smells to Credo-compatible severity levels:

| SPARQL Smell Detection | Credo-Equivalent Severity | Exit Code |
|------------------------|---------------------------|-----------|
| Unsupervised Process | Warning | 16 |
| Circular Dependency | Refactor | 8 |
| Agent Obsession | Design | 2 |
| Code Organization by Process | Info | 1 |
| God Module | Refactor | 8 |
| Feature Envy | Design | 2 |

### Custom Credo check template for smell integration

For smells that could benefit from Credo integration, implement custom checks:

```elixir
defmodule JidoCode.Checks.OntologySmellCheck do
  use Credo.Check,
    base_priority: :high,
    tags: [:custom, :ontology],
    explanations: [
      check: """
      Queries the project ontology for semantic code smells that
      cannot be detected through AST analysis alone.
      """
    ]

  @impl true
  def run(source_file, params) do
    # This check delegates to SPARQL queries
    # Results are cached per analysis run
    ontology_smells = JidoCode.Ontology.get_cached_smells()
    
    ontology_smells
    |> Enum.filter(&matches_file?(&1, source_file))
    |> Enum.map(&to_credo_issue(&1, source_file, params))
  end

  defp to_credo_issue(smell, source_file, params) do
    format_issue(
      source_file,
      message: smell.message,
      trigger: smell.trigger,
      line_no: smell.line,
      severity: map_severity(smell.severity)
    )
  end
end
```

### Recommended configuration additions

Add to `.credo.exs`:

```elixir
%{
  configs: [
    %{
      name: "default",
      checks: %{
        enabled: [
          # Enable disabled checks relevant to code smells
          {Credo.Check.Design.DuplicatedCode, mass_threshold: 40},
          {Credo.Check.Refactor.ABCSize, []},
          {Credo.Check.Refactor.ModuleDependencies, []},
          
          # Custom ontology-based checks
          {JidoCode.Checks.OntologySmellCheck, []},
        ]
      },
      requires: ["lib/jido_code/checks/"],
    }
  ]
}
```

---

## Conclusion

This hybrid prevention system addresses Elixir code smells at three complementary levels. **Pre-generation SPARQL queries** provide project context, ensuring the LLM understands existing patterns before generating new code. **During-generation prompt rules** prevent the 15 AST-detectable smells through explicit guidelines and DO/DON'T examples formatted for maximum LLM comprehension. **Post-generation semantic validation** catches the 13 relationship-based smells that require cross-module analysis—particularly critical for Elixir's OTP patterns like supervision trees, Agent encapsulation, and process architecture.

The key insight is that **Credo excels at local, AST-based analysis** while **SPARQL/SHACL excels at global, relationship-based analysis**. The unified pipeline leverages both: Credo handles complexity metrics, naming conventions, and style consistency, while SPARQL queries detect circular dependencies, unsupervised processes, Agent obsession, feature envy, and god modules. The feedback loop format—with structured issue descriptions, code snippets, and expected patterns—enables iterative refinement that research shows achieves 20%+ improvement per iteration.

For JidoCode implementation, prioritize: (1) implementing the core OWL ontology with process-specific classes and properties, (2) deploying the six high-value SPARQL queries (unsupervised process, circular dependency, Agent obsession, feature envy, god module, code organization by process), (3) embedding the condensed smell prevention guide in all Elixir generation prompts, and (4) building the feedback formatter to close the detection-correction loop.
