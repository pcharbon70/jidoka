# Elixir Security Prevention System for JidoCode

## ERLEF-Compliant Security Enforcement Integrated with Elixir Ontology Set

This document provides a comprehensive security prevention system for JidoCode that properly integrates with the existing Elixir ontology set at `https://w3id.org/elixir-code/`. The system prevents LLM generation of insecure code based on ERLEF Security Working Group recommendations.

---

## 1. Ontology Integration Overview

### Existing Ontology Namespaces

The security ontology extends and references the existing Elixir ontology set:

| Prefix | Namespace URI | Purpose |
|--------|--------------|---------|
| `core:` | `https://w3id.org/elixir-code/core#` | AST elements, expressions, source locations |
| `struct:` | `https://w3id.org/elixir-code/structure#` | Modules, functions, protocols, behaviours |
| `otp:` | `https://w3id.org/elixir-code/otp#` | GenServer, Supervisor, processes, ETS |
| `evo:` | `https://w3id.org/elixir-code/evolution#` | Provenance, commits, versioning |
| `sec:` | `https://w3id.org/elixir-code/security#` | **NEW** - Security vulnerabilities and patterns |

### Key Classes Referenced from Existing Ontologies

**From `core:`:**
- `core:CodeElement` - Base class for all code constructs
- `core:Expression` - Evaluable code constructs
- `core:RemoteCall` - Function call with explicit module (Module.function)
- `core:LocalCall` - Function call within current module
- `core:SourceLocation` - File/line/column location
- `core:SourceFile` - Physical source file
- `core:StringLiteral` - String values (for detecting interpolation)
- `core:AtomLiteral` - Atom values

**From `struct:`:**
- `struct:Module` - Elixir modules
- `struct:Function`, `struct:PublicFunction`, `struct:PrivateFunction` - Functions
- `struct:FunctionClause`, `struct:FunctionHead`, `struct:FunctionBody` - Function structure
- `struct:Parameter` - Function parameters
- `struct:Struct`, `struct:StructField` - Structs and fields
- `struct:ModuleAttribute` - Module attributes (@derive, @doc, etc.)
- `struct:DeriveAttribute` - @derive annotations
- `struct:Behaviour`, `struct:BehaviourImplementation` - Behaviours
- `struct:callsFunction` - Function call relationship

**From `otp:`:**
- `otp:GenServer`, `otp:GenServerImplementation` - GenServer behaviour
- `otp:Supervisor`, `otp:DynamicSupervisor` - Supervisors
- `otp:Agent`, `otp:Task` - Higher-level abstractions
- `otp:Process` - BEAM processes
- `otp:supervisedBy`, `otp:supervises` - Supervision relationships
- `otp:GenServerCallback`, `otp:InitCallback`, `otp:HandleCallCallback` - Callbacks
- `otp:ETSTable` - ETS tables

---

## 2. Security Ontology (elixir-security.ttl)

```turtle
@prefix sec: <https://w3id.org/elixir-code/security#> .
@prefix core: <https://w3id.org/elixir-code/core#> .
@prefix struct: <https://w3id.org/elixir-code/structure#> .
@prefix otp: <https://w3id.org/elixir-code/otp#> .
@prefix evo: <https://w3id.org/elixir-code/evolution#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .

# =============================================================================
# Ontology Declaration
# =============================================================================

<https://w3id.org/elixir-code/security> a owl:Ontology ;
    owl:versionIRI <https://w3id.org/elixir-code/security/1.0.0> ;
    owl:versionInfo "1.0.0" ;
    owl:imports <https://w3id.org/elixir-code/core> ,
                <https://w3id.org/elixir-code/structure> ,
                <https://w3id.org/elixir-code/otp> ;
    dc:title "Elixir Code Security Ontology"@en ;
    dc:description """Security ontology for detecting and preventing vulnerabilities
    in Elixir code. Based on ERLEF Security Working Group recommendations for
    secure coding and deployment hardening, and web application security best
    practices for BEAM applications."""@en ;
    dc:creator "JidoCode Security Prevention System" ;
    dc:date "2025-01-01"^^xsd:date ;
    dcterms:license <https://creativecommons.org/licenses/by/4.0/> ;
    rdfs:seeAlso <https://security.erlef.org/> .

# =============================================================================
# Security Vulnerability Classes
# =============================================================================

sec:SecurityVulnerability a owl:Class ;
    rdfs:label "Security Vulnerability"@en ;
    rdfs:comment """Base class for all security vulnerabilities detected in 
    Elixir code. Each vulnerability links to affected code elements via 
    the existing ontology classes."""@en ;
    rdfs:subClassOf core:CodeElement .

# -----------------------------------------------------------------------------
# Injection Vulnerabilities
# -----------------------------------------------------------------------------

sec:InjectionVulnerability a owl:Class ;
    rdfs:label "Injection Vulnerability"@en ;
    rdfs:comment "Vulnerabilities allowing injection of malicious content."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:SQLInjection a owl:Class ;
    rdfs:label "SQL Injection"@en ;
    rdfs:comment """SQL injection via string interpolation in queries.
    ERLEF WEB-004, WEB-005. OWASP A03:2021."""@en ;
    rdfs:subClassOf sec:InjectionVulnerability ;
    sec:erlefId "WEB-004" ;
    sec:owaspCategory "A03:2021-Injection" ;
    sec:severity "CRITICAL" .

sec:CommandInjection a owl:Class ;
    rdfs:label "Command Injection"@en ;
    rdfs:comment """OS command injection via :os.cmd or shell execution.
    ERLEF BEAM-010, BEAM-011. OWASP A03:2021."""@en ;
    rdfs:subClassOf sec:InjectionVulnerability ;
    sec:erlefId "BEAM-010" ;
    sec:owaspCategory "A03:2021-Injection" ;
    sec:severity "CRITICAL" .

sec:CodeInjection a owl:Class ;
    rdfs:label "Code Injection"@en ;
    rdfs:comment """Remote code execution via Code.eval_* or file:script.
    ERLEF BEAM-008, BEAM-009. OWASP A03:2021."""@en ;
    rdfs:subClassOf sec:InjectionVulnerability ;
    sec:erlefId "BEAM-008" ;
    sec:owaspCategory "A03:2021-Injection" ;
    sec:severity "CRITICAL" .

sec:XSSVulnerability a owl:Class ;
    rdfs:label "XSS Vulnerability"@en ;
    rdfs:comment """Cross-site scripting via raw/1 or unescaped output.
    ERLEF WEB-001, WEB-002, WEB-003. OWASP A03:2021."""@en ;
    rdfs:subClassOf sec:InjectionVulnerability ;
    sec:erlefId "WEB-001" ;
    sec:owaspCategory "A03:2021-Injection" ;
    sec:severity "CRITICAL" .

# -----------------------------------------------------------------------------
# Deserialization Vulnerabilities
# -----------------------------------------------------------------------------

sec:DeserializationVulnerability a owl:Class ;
    rdfs:label "Deserialization Vulnerability"@en ;
    rdfs:comment "Vulnerabilities from unsafe deserialization of data."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:AtomExhaustion a owl:Class ;
    rdfs:label "Atom Exhaustion"@en ;
    rdfs:comment """Denial of service via atom table exhaustion from dynamic 
    atom creation. Atoms are never garbage collected. ERLEF BEAM-001 to BEAM-005.
    OWASP A05:2021."""@en ;
    rdfs:subClassOf sec:DeserializationVulnerability ;
    sec:erlefId "BEAM-001" ;
    sec:owaspCategory "A05:2021-Security Misconfiguration" ;
    sec:severity "HIGH" .

sec:UnsafeBinaryToTerm a owl:Class ;
    rdfs:label "Unsafe Binary To Term"@en ;
    rdfs:comment """RCE via :erlang.binary_to_term without [:safe] option.
    Can deserialize and execute arbitrary functions. ERLEF BEAM-006, BEAM-007.
    OWASP A08:2021."""@en ;
    rdfs:subClassOf sec:DeserializationVulnerability ;
    sec:erlefId "BEAM-006" ;
    sec:owaspCategory "A08:2021-Software and Data Integrity Failures" ;
    sec:severity "CRITICAL" .

sec:XXEVulnerability a owl:Class ;
    rdfs:label "XXE Vulnerability"@en ;
    rdfs:comment """XML External Entity injection via xmerl parsers.
    ERLEF BEAM-018. OWASP A05:2021."""@en ;
    rdfs:subClassOf sec:DeserializationVulnerability ;
    sec:erlefId "BEAM-018" ;
    sec:owaspCategory "A05:2021-Security Misconfiguration" ;
    sec:severity "HIGH" .

# -----------------------------------------------------------------------------
# Authentication & Session Vulnerabilities
# -----------------------------------------------------------------------------

sec:AuthenticationVulnerability a owl:Class ;
    rdfs:label "Authentication Vulnerability"@en ;
    rdfs:comment "Vulnerabilities in authentication mechanisms."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:SessionVulnerability a owl:Class ;
    rdfs:label "Session Vulnerability"@en ;
    rdfs:comment """Session management vulnerabilities including fixation,
    missing encryption, and missing timeout. ERLEF WEB-010 to WEB-013."""@en ;
    rdfs:subClassOf sec:AuthenticationVulnerability ;
    sec:erlefId "WEB-010" ;
    sec:owaspCategory "A07:2021-Identification and Authentication Failures" ;
    sec:severity "HIGH" .

sec:CSRFVulnerability a owl:Class ;
    rdfs:label "CSRF Vulnerability"@en ;
    rdfs:comment """Cross-site request forgery from missing protection.
    ERLEF WEB-006, WEB-007. OWASP A01:2021."""@en ;
    rdfs:subClassOf sec:AuthenticationVulnerability ;
    sec:erlefId "WEB-006" ;
    sec:owaspCategory "A01:2021-Broken Access Control" ;
    sec:severity "HIGH" .

sec:WebSocketHijacking a owl:Class ;
    rdfs:label "WebSocket Hijacking"@en ;
    rdfs:comment """WebSocket connection hijacking from disabled origin checking
    without token authentication. ERLEF WEB-008."""@en ;
    rdfs:subClassOf sec:AuthenticationVulnerability ;
    sec:erlefId "WEB-008" ;
    sec:owaspCategory "A07:2021-Identification and Authentication Failures" ;
    sec:severity "HIGH" .

# -----------------------------------------------------------------------------
# Authorization Vulnerabilities
# -----------------------------------------------------------------------------

sec:AuthorizationVulnerability a owl:Class ;
    rdfs:label "Authorization Vulnerability"@en ;
    rdfs:comment "Missing or inadequate authorization checks."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:MissingAuthorizationCheck a owl:Class ;
    rdfs:label "Missing Authorization Check"@en ;
    rdfs:comment """Missing server-side authorization in controllers or LiveView
    handlers. ERLEF WEB-009, WEB-020. OWASP A01:2021."""@en ;
    rdfs:subClassOf sec:AuthorizationVulnerability ;
    sec:erlefId "WEB-009" ;
    sec:owaspCategory "A01:2021-Broken Access Control" ;
    sec:severity "CRITICAL" .

sec:MassAssignment a owl:Class ;
    rdfs:label "Mass Assignment"@en ;
    rdfs:comment """Overly permissive changeset allowing unintended field updates.
    ERLEF WEB-017. OWASP A01:2021."""@en ;
    rdfs:subClassOf sec:AuthorizationVulnerability ;
    sec:erlefId "WEB-017" ;
    sec:owaspCategory "A01:2021-Broken Access Control" ;
    sec:severity "HIGH" .

# -----------------------------------------------------------------------------
# Cryptographic Vulnerabilities
# -----------------------------------------------------------------------------

sec:CryptographicVulnerability a owl:Class ;
    rdfs:label "Cryptographic Vulnerability"@en ;
    rdfs:comment "Vulnerabilities in cryptographic operations."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:TimingAttack a owl:Class ;
    rdfs:label "Timing Attack"@en ;
    rdfs:comment """Variable-time comparison of secrets via pattern matching.
    ERLEF BEAM-015. OWASP A02:2021."""@en ;
    rdfs:subClassOf sec:CryptographicVulnerability ;
    sec:erlefId "BEAM-015" ;
    sec:owaspCategory "A02:2021-Cryptographic Failures" ;
    sec:severity "MEDIUM" .

sec:TLSMisconfiguration a owl:Class ;
    rdfs:label "TLS Misconfiguration"@en ;
    rdfs:comment """Missing certificate verification in SSL/TLS connections.
    ERLEF BEAM-016, BEAM-017. OWASP A02:2021."""@en ;
    rdfs:subClassOf sec:CryptographicVulnerability ;
    sec:erlefId "BEAM-016" ;
    sec:owaspCategory "A02:2021-Cryptographic Failures" ;
    sec:severity "CRITICAL" .

# -----------------------------------------------------------------------------
# Information Disclosure Vulnerabilities
# -----------------------------------------------------------------------------

sec:InformationDisclosure a owl:Class ;
    rdfs:label "Information Disclosure"@en ;
    rdfs:comment "Unintended exposure of sensitive information."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:SecretInStacktrace a owl:Class ;
    rdfs:label "Secret in Stacktrace"@en ;
    rdfs:comment """Secrets exposed in stacktraces via function arguments.
    ERLEF BEAM-012. OWASP A01:2021."""@en ;
    rdfs:subClassOf sec:InformationDisclosure ;
    sec:erlefId "BEAM-012" ;
    sec:owaspCategory "A01:2021-Broken Access Control" ;
    sec:severity "HIGH" .

sec:SecretInIntrospection a owl:Class ;
    rdfs:label "Secret in Introspection"@en ;
    rdfs:comment """Secrets visible via :sys.get_state or similar introspection
    on GenServer state. Missing format_status/2. ERLEF BEAM-013."""@en ;
    rdfs:subClassOf sec:InformationDisclosure ;
    sec:erlefId "BEAM-013" ;
    sec:owaspCategory "A01:2021-Broken Access Control" ;
    sec:severity "HIGH" .

sec:MissingDeriveInspect a owl:Class ;
    rdfs:label "Missing Derive Inspect"@en ;
    rdfs:comment """Structs with sensitive fields missing @derive {Inspect, except: [...]}.
    ERLEF BEAM-014."""@en ;
    rdfs:subClassOf sec:InformationDisclosure ;
    sec:erlefId "BEAM-014" ;
    sec:owaspCategory "A01:2021-Broken Access Control" ;
    sec:severity "HIGH" .

sec:SensitiveDataInLogs a owl:Class ;
    rdfs:label "Sensitive Data in Logs"@en ;
    rdfs:comment """Unfiltered sensitive parameters in Phoenix logs.
    Missing :filter_parameters configuration. ERLEF WEB-016."""@en ;
    rdfs:subClassOf sec:InformationDisclosure ;
    sec:erlefId "WEB-016" ;
    sec:owaspCategory "A09:2021-Security Logging and Monitoring Failures" ;
    sec:severity "HIGH" .

# -----------------------------------------------------------------------------
# Configuration Vulnerabilities
# -----------------------------------------------------------------------------

sec:ConfigurationVulnerability a owl:Class ;
    rdfs:label "Configuration Vulnerability"@en ;
    rdfs:comment "Security issues from misconfiguration."@en ;
    rdfs:subClassOf sec:SecurityVulnerability .

sec:DistributionExposed a owl:Class ;
    rdfs:label "Distribution Exposed"@en ;
    rdfs:comment """Erlang distribution (EPMD) exposed on public interfaces.
    ERLEF BEAM-019, BEAM-020. OWASP A05:2021."""@en ;
    rdfs:subClassOf sec:ConfigurationVulnerability ;
    sec:erlefId "BEAM-019" ;
    sec:owaspCategory "A05:2021-Security Misconfiguration" ;
    sec:severity "CRITICAL" .

sec:MissingSecurityHeaders a owl:Class ;
    rdfs:label "Missing Security Headers"@en ;
    rdfs:comment """Missing CSP, HSTS, or other security headers.
    ERLEF WEB-014, WEB-015. OWASP A05:2021."""@en ;
    rdfs:subClassOf sec:ConfigurationVulnerability ;
    sec:erlefId "WEB-014" ;
    sec:owaspCategory "A05:2021-Security Misconfiguration" ;
    sec:severity "MEDIUM" .

sec:MissingRateLimiting a owl:Class ;
    rdfs:label "Missing Rate Limiting"@en ;
    rdfs:comment """No rate limiting on authentication or sensitive endpoints.
    ERLEF WEB-021. OWASP A04:2021."""@en ;
    rdfs:subClassOf sec:ConfigurationVulnerability ;
    sec:erlefId "WEB-021" ;
    sec:owaspCategory "A04:2021-Insecure Design" ;
    sec:severity "MEDIUM" .

# =============================================================================
# Insecure Function Pattern Registry
# =============================================================================

sec:InsecureFunctionPattern a owl:Class ;
    rdfs:label "Insecure Function Pattern"@en ;
    rdfs:comment """Registry of known insecure function call patterns.
    Used for AST-based detection during and after code generation."""@en .

# Atom Exhaustion Patterns
sec:Pattern_StringToAtom a sec:InsecureFunctionPattern ;
    rdfs:label "String.to_atom/1 Pattern"@en ;
    sec:functionSignature "String.to_atom/1" ;
    sec:moduleAtom "Elixir.String" ;
    sec:functionAtom "to_atom" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:AtomExhaustion ;
    sec:secureAlternative "String.to_existing_atom/1 or lookup map" ;
    sec:severity "HIGH" .

sec:Pattern_ListToAtom a sec:InsecureFunctionPattern ;
    rdfs:label "List.to_atom/1 Pattern"@en ;
    sec:functionSignature "List.to_atom/1" ;
    sec:moduleAtom "Elixir.List" ;
    sec:functionAtom "to_atom" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:AtomExhaustion ;
    sec:secureAlternative "List.to_existing_atom/1" ;
    sec:severity "HIGH" .

sec:Pattern_ErlangBinaryToAtom a sec:InsecureFunctionPattern ;
    rdfs:label ":erlang.binary_to_atom Pattern"@en ;
    sec:functionSignature ":erlang.binary_to_atom/1" ;
    sec:moduleAtom "erlang" ;
    sec:functionAtom "binary_to_atom" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:AtomExhaustion ;
    sec:secureAlternative ":erlang.binary_to_existing_atom/2" ;
    sec:severity "HIGH" .

sec:Pattern_ModuleConcat a sec:InsecureFunctionPattern ;
    rdfs:label "Module.concat with user input Pattern"@en ;
    sec:functionSignature "Module.concat/1" ;
    sec:moduleAtom "Elixir.Module" ;
    sec:functionAtom "concat" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:AtomExhaustion ;
    sec:secureAlternative "Module.safe_concat/1 or allowlist validation" ;
    sec:severity "HIGH" .

# Code Injection Patterns
sec:Pattern_CodeEvalString a sec:InsecureFunctionPattern ;
    rdfs:label "Code.eval_string Pattern"@en ;
    sec:functionSignature "Code.eval_string/1" ;
    sec:moduleAtom "Elixir.Code" ;
    sec:functionAtom "eval_string" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:CodeInjection ;
    sec:secureAlternative "Embedded sandbox (Lua via luerl)" ;
    sec:severity "CRITICAL" .

sec:Pattern_CodeEvalFile a sec:InsecureFunctionPattern ;
    rdfs:label "Code.eval_file Pattern"@en ;
    sec:functionSignature "Code.eval_file/1" ;
    sec:moduleAtom "Elixir.Code" ;
    sec:functionAtom "eval_file" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:CodeInjection ;
    sec:secureAlternative "Avoid on untrusted input" ;
    sec:severity "CRITICAL" .

sec:Pattern_FileScript a sec:InsecureFunctionPattern ;
    rdfs:label ":file.script Pattern"@en ;
    sec:functionSignature ":file.script/1" ;
    sec:moduleAtom "file" ;
    sec:functionAtom "script" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:CodeInjection ;
    sec:secureAlternative "Avoid on untrusted input" ;
    sec:severity "CRITICAL" .

# Command Injection Patterns
sec:Pattern_OsCmd a sec:InsecureFunctionPattern ;
    rdfs:label ":os.cmd Pattern"@en ;
    sec:functionSignature ":os.cmd/1" ;
    sec:moduleAtom "os" ;
    sec:functionAtom "cmd" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:CommandInjection ;
    sec:secureAlternative "System.cmd/3 with args as list" ;
    sec:severity "CRITICAL" .

sec:Pattern_SystemShell a sec:InsecureFunctionPattern ;
    rdfs:label "System.shell Pattern"@en ;
    sec:functionSignature "System.shell/1" ;
    sec:moduleAtom "Elixir.System" ;
    sec:functionAtom "shell" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:CommandInjection ;
    sec:secureAlternative "System.cmd/3 with args as list" ;
    sec:severity "CRITICAL" .

# Deserialization Patterns
sec:Pattern_BinaryToTerm a sec:InsecureFunctionPattern ;
    rdfs:label ":erlang.binary_to_term/1 Pattern"@en ;
    sec:functionSignature ":erlang.binary_to_term/1" ;
    sec:moduleAtom "erlang" ;
    sec:functionAtom "binary_to_term" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:UnsafeBinaryToTerm ;
    sec:secureAlternative ":erlang.binary_to_term(data, [:safe]) or Plug.Crypto.non_executable_binary_to_term/2" ;
    sec:severity "CRITICAL" .

# XSS Patterns
sec:Pattern_Raw a sec:InsecureFunctionPattern ;
    rdfs:label "Phoenix.HTML.raw/1 Pattern"@en ;
    sec:functionSignature "Phoenix.HTML.raw/1" ;
    sec:moduleAtom "Elixir.Phoenix.HTML" ;
    sec:functionAtom "raw" ;
    sec:arity 1 ;
    sec:triggersVulnerability sec:XSSVulnerability ;
    sec:secureAlternative "Default template escaping" ;
    sec:severity "CRITICAL" .

# =============================================================================
# Security Context Classes
# =============================================================================

sec:SecurityContext a owl:Class ;
    rdfs:label "Security Context"@en ;
    rdfs:comment """A context in which security-sensitive code is being generated.
    Used to trigger context-specific warnings."""@en .

sec:AuthenticationContext a owl:Class ;
    rdfs:label "Authentication Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:DatabaseQueryContext a owl:Class ;
    rdfs:label "Database Query Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:FileOperationContext a owl:Class ;
    rdfs:label "File Operation Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:CryptographicContext a owl:Class ;
    rdfs:label "Cryptographic Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:UserInputContext a owl:Class ;
    rdfs:label "User Input Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:APIEndpointContext a owl:Class ;
    rdfs:label "API Endpoint Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:WebSocketContext a owl:Class ;
    rdfs:label "WebSocket Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

sec:LiveViewContext a owl:Class ;
    rdfs:label "LiveView Context"@en ;
    rdfs:subClassOf sec:SecurityContext .

# =============================================================================
# Data Flow and Taint Tracking
# =============================================================================

sec:DataSource a owl:Class ;
    rdfs:label "Data Source"@en ;
    rdfs:comment "Origin point of data in the application."@en .

sec:UntrustedSource a owl:Class ;
    rdfs:label "Untrusted Source"@en ;
    rdfs:comment """A source of untrusted data: HTTP params, headers, 
    user uploads, external APIs, etc."""@en ;
    rdfs:subClassOf sec:DataSource .

sec:TrustedSource a owl:Class ;
    rdfs:label "Trusted Source"@en ;
    rdfs:comment "A source of trusted data: constants, config, validated data."@en ;
    rdfs:subClassOf sec:DataSource .

sec:SensitiveSink a owl:Class ;
    rdfs:label "Sensitive Sink"@en ;
    rdfs:comment """A code location where untrusted data reaching it 
    creates a vulnerability: SQL queries, shell commands, etc."""@en .

# =============================================================================
# Object Properties
# =============================================================================

# Linking vulnerabilities to code elements (using existing ontology classes)
sec:affectsModule a owl:ObjectProperty ;
    rdfs:label "affects module"@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range struct:Module .

sec:affectsFunction a owl:ObjectProperty ;
    rdfs:label "affects function"@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range struct:Function .

sec:affectsFunctionClause a owl:ObjectProperty ;
    rdfs:label "affects function clause"@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range struct:FunctionClause .

sec:atSourceLocation a owl:ObjectProperty ;
    rdfs:label "at source location"@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range core:SourceLocation .

sec:involvesCall a owl:ObjectProperty ;
    rdfs:label "involves call"@en ;
    rdfs:comment "Links vulnerability to the specific function call."@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range core:RemoteCall .

sec:involvesLocalCall a owl:ObjectProperty ;
    rdfs:label "involves local call"@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range core:LocalCall .

# Pattern matching
sec:triggersVulnerability a owl:ObjectProperty ;
    rdfs:label "triggers vulnerability"@en ;
    rdfs:domain sec:InsecureFunctionPattern ;
    rdfs:range sec:SecurityVulnerability .

sec:matchesPattern a owl:ObjectProperty ;
    rdfs:label "matches pattern"@en ;
    rdfs:domain core:RemoteCall ;
    rdfs:range sec:InsecureFunctionPattern .

# Data flow properties
sec:receivesDataFrom a owl:ObjectProperty ;
    rdfs:label "receives data from"@en ;
    rdfs:domain core:Expression ;
    rdfs:range sec:DataSource .

sec:flowsTo a owl:ObjectProperty ;
    rdfs:label "flows to"@en ;
    rdfs:comment "Data flow from one expression to another."@en ;
    rdfs:domain core:Expression ;
    rdfs:range core:Expression .

sec:reachesSink a owl:ObjectProperty ;
    rdfs:label "reaches sink"@en ;
    rdfs:domain sec:UntrustedSource ;
    rdfs:range sec:SensitiveSink .

# OTP security relationships
sec:genServerHandlesSensitiveData a owl:ObjectProperty ;
    rdfs:label "GenServer handles sensitive data"@en ;
    rdfs:domain otp:GenServerImplementation ;
    rdfs:range struct:StructField .

sec:missingFormatStatus a owl:ObjectProperty ;
    rdfs:label "missing format_status"@en ;
    rdfs:comment "GenServer with sensitive state but no format_status/2."@en ;
    rdfs:domain otp:GenServerImplementation ;
    rdfs:range sec:SecretInIntrospection .

# Authorization relationships
sec:requiresAuthorization a owl:ObjectProperty ;
    rdfs:label "requires authorization"@en ;
    rdfs:domain struct:Function ;
    rdfs:range sec:AuthorizationVulnerability .

sec:hasAuthorizationCheck a owl:ObjectProperty ;
    rdfs:label "has authorization check"@en ;
    rdfs:domain struct:Function ;
    rdfs:range core:LocalCall .

# Context detection
sec:activatesContext a owl:ObjectProperty ;
    rdfs:label "activates context"@en ;
    rdfs:domain struct:Module ;
    rdfs:range sec:SecurityContext .

# =============================================================================
# Data Properties
# =============================================================================

# Vulnerability metadata
sec:erlefId a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "ERLEF ID"@en ;
    rdfs:comment "Identifier from ERLEF Security Working Group recommendations."@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range xsd:string .

sec:owaspCategory a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "OWASP category"@en ;
    rdfs:domain sec:SecurityVulnerability ;
    rdfs:range xsd:string .

sec:severity a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "severity"@en ;
    rdfs:comment "CRITICAL, HIGH, MEDIUM, LOW"@en ;
    rdfs:range xsd:string .

sec:detectability a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "detectability"@en ;
    rdfs:comment "AST, Semantic, Config, Runtime"@en ;
    rdfs:range xsd:string .

sec:secureAlternative a owl:DatatypeProperty ;
    rdfs:label "secure alternative"@en ;
    rdfs:comment "Recommended secure pattern to use instead."@en ;
    rdfs:range xsd:string .

# Function pattern properties
sec:functionSignature a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "function signature"@en ;
    rdfs:comment "Module.function/arity format."@en ;
    rdfs:domain sec:InsecureFunctionPattern ;
    rdfs:range xsd:string .

sec:moduleAtom a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "module atom"@en ;
    rdfs:domain sec:InsecureFunctionPattern ;
    rdfs:range xsd:string .

sec:functionAtom a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "function atom"@en ;
    rdfs:domain sec:InsecureFunctionPattern ;
    rdfs:range xsd:string .

# Taint tracking
sec:isTainted a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "is tainted"@en ;
    rdfs:comment "Expression contains untrusted data."@en ;
    rdfs:domain core:Expression ;
    rdfs:range xsd:boolean .

sec:containsInterpolation a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "contains interpolation"@en ;
    rdfs:comment "String contains #{} interpolation."@en ;
    rdfs:domain core:StringLiteral ;
    rdfs:range xsd:boolean .

# Sensitive field markers
sec:isSensitiveField a owl:DatatypeProperty, owl:FunctionalProperty ;
    rdfs:label "is sensitive field"@en ;
    rdfs:comment "Field contains sensitive data (password, token, etc.)."@en ;
    rdfs:domain struct:StructField ;
    rdfs:range xsd:boolean .

# =============================================================================
# OWL Axioms
# =============================================================================

# Vulnerability types are disjoint
[] a owl:AllDisjointClasses ;
    owl:members (
        sec:InjectionVulnerability
        sec:DeserializationVulnerability
        sec:AuthenticationVulnerability
        sec:AuthorizationVulnerability
        sec:CryptographicVulnerability
        sec:InformationDisclosure
        sec:ConfigurationVulnerability
    ) .

# Injection subtypes are disjoint
[] a owl:AllDisjointClasses ;
    owl:members (
        sec:SQLInjection
        sec:CommandInjection
        sec:CodeInjection
        sec:XSSVulnerability
    ) .

# Data sources are disjoint
[] a owl:AllDisjointClasses ;
    owl:members (
        sec:UntrustedSource
        sec:TrustedSource
    ) .

# Every vulnerability has a severity
sec:SecurityVulnerability rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty sec:severity ;
    owl:cardinality 1
] .
```

---

## 3. Security SHACL Shapes (elixir-security-shapes.ttl)

```turtle
@prefix secsh: <https://w3id.org/elixir-code/security-shapes#> .
@prefix sec: <https://w3id.org/elixir-code/security#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix core: <https://w3id.org/elixir-code/core#> .
@prefix struct: <https://w3id.org/elixir-code/structure#> .
@prefix otp: <https://w3id.org/elixir-code/otp#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .

# =============================================================================
# Shapes Graph Declaration
# =============================================================================

<https://w3id.org/elixir-code/security-shapes> a owl:Ontology ;
    owl:versionInfo "1.0.0" ;
    dc:title "Elixir Security SHACL Shapes"@en ;
    dc:description """SHACL shapes for detecting security vulnerabilities in 
    Elixir code knowledge graphs. Based on ERLEF Security Working Group 
    recommendations."""@en .

# =============================================================================
# Atom Exhaustion Detection Shapes
# =============================================================================

secsh:AtomCreationShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "Atom Creation Detection"@en ;
    sh:description "Detects calls to functions that create atoms from strings."@en ;
    sh:sparql [
        sh:message "BEAM-001: Potential atom exhaustion via {?funcSig}. Use String.to_existing_atom/1 or a lookup map instead."@en ;
        sh:severity sh:Violation ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            PREFIX sec: <https://w3id.org/elixir-code/security#>
            
            SELECT $this ?funcSig ?module ?line
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name ?moduleName .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName ?funcName .
                ?funcRef struct:arity ?arity .
                
                BIND(CONCAT(?moduleName, ".", ?funcName, "/", STR(?arity)) AS ?funcSig)
                
                FILTER(?funcSig IN (
                    "String.to_atom/1",
                    "List.to_atom/1",
                    "Module.concat/1",
                    "Module.concat/2"
                ))
                
                OPTIONAL {
                    $this core:hasSourceLocation ?loc .
                    ?loc core:inSourceFile ?file .
                    ?file core:filePath ?module .
                    ?loc core:startLine ?line .
                }
            }
        """
    ] .

secsh:ErlangAtomCreationShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "Erlang Atom Creation Detection"@en ;
    sh:sparql [
        sh:message "BEAM-001: Potential atom exhaustion via Erlang function. Use binary_to_existing_atom/2 instead."@en ;
        sh:severity sh:Violation ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this ?funcSig
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name ?moduleName .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName ?funcName .
                ?funcRef struct:arity ?arity .
                
                BIND(CONCAT(":", ?moduleName, ".", ?funcName, "/", STR(?arity)) AS ?funcSig)
                
                FILTER(
                    (?moduleName = "erlang" && ?funcName = "binary_to_atom" && ?arity = 1) ||
                    (?moduleName = "erlang" && ?funcName = "binary_to_atom" && ?arity = 2) ||
                    (?moduleName = "erlang" && ?funcName = "list_to_atom" && ?arity = 1)
                )
            }
        """
    ] .

# =============================================================================
# Code Injection Detection Shapes
# =============================================================================

secsh:CodeEvalShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "Code Evaluation Detection"@en ;
    sh:description "Detects dangerous code evaluation functions."@en ;
    sh:sparql [
        sh:message "BEAM-008: CRITICAL - Code evaluation detected ({?funcSig}). This allows remote code execution. Use embedded sandbox instead."@en ;
        sh:severity sh:Violation ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this ?funcSig
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name ?moduleName .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName ?funcName .
                
                FILTER(?moduleName = "Code")
                FILTER(STRSTARTS(?funcName, "eval_"))
                
                BIND(CONCAT(?moduleName, ".", ?funcName) AS ?funcSig)
            }
        """
    ] .

# =============================================================================
# Command Injection Detection Shapes
# =============================================================================

secsh:OsCmdShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "OS Command Detection"@en ;
    sh:sparql [
        sh:message "BEAM-010: CRITICAL - :os.cmd detected. Use System.cmd/3 with arguments as a list instead."@en ;
        sh:severity sh:Violation ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name "os" .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName "cmd" .
            }
        """
    ] .

secsh:SystemShellShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "System Shell Detection"@en ;
    sh:sparql [
        sh:message "BEAM-010: System.shell detected. Use System.cmd/3 with arguments as a list instead."@en ;
        sh:severity sh:Warning ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name "System" .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName "shell" .
            }
        """
    ] .

# =============================================================================
# Unsafe Deserialization Shapes
# =============================================================================

secsh:UnsafeBinaryToTermShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "Unsafe binary_to_term Detection"@en ;
    sh:sparql [
        sh:message "BEAM-006: CRITICAL - :erlang.binary_to_term/1 without [:safe] option. Use binary_to_term(data, [:safe]) or Plug.Crypto.non_executable_binary_to_term/2."@en ;
        sh:severity sh:Violation ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name "erlang" .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName "binary_to_term" .
                ?funcRef struct:arity 1 .
            }
        """
    ] .

# =============================================================================
# XSS Detection Shapes
# =============================================================================

secsh:RawHtmlShape a sh:NodeShape ;
    sh:targetClass core:RemoteCall ;
    sh:name "Raw HTML Detection"@en ;
    sh:sparql [
        sh:message "WEB-001: Phoenix.HTML.raw/1 detected. Ensure input is not user-controlled or properly sanitized."@en ;
        sh:severity sh:Warning ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this ?module ?line
            WHERE {
                $this a core:RemoteCall .
                $this core:refersToModule ?modRef .
                ?modRef core:name ?moduleName .
                $this struct:callsFunction ?funcRef .
                ?funcRef struct:functionName "raw" .
                ?funcRef struct:arity 1 .
                
                FILTER(?moduleName IN ("Phoenix.HTML", "Phoenix.HTML.Raw"))
                
                OPTIONAL {
                    $this core:hasSourceLocation ?loc .
                    ?loc core:inSourceFile ?file .
                    ?file core:filePath ?module .
                    ?loc core:startLine ?line .
                }
            }
        """
    ] .

# =============================================================================
# GenServer Security Shapes
# =============================================================================

secsh:GenServerMissingFormatStatusShape a sh:NodeShape ;
    sh:targetClass otp:GenServerImplementation ;
    sh:name "GenServer Missing format_status Detection"@en ;
    sh:description "Detects GenServers with sensitive state but no format_status/2 callback."@en ;
    sh:sparql [
        sh:message "BEAM-013: GenServer module {?moduleName} may handle sensitive data but lacks format_status/2 callback. Secrets may be exposed via :sys.get_state/1."@en ;
        sh:severity sh:Warning ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            PREFIX otp: <https://w3id.org/elixir-code/otp#>
            PREFIX sec: <https://w3id.org/elixir-code/security#>
            
            SELECT $this ?moduleName
            WHERE {
                $this a otp:GenServerImplementation .
                $this struct:belongsTo ?module .
                ?module struct:moduleName ?moduleName .
                
                # Check for sensitive-looking fields in state struct
                ?module struct:containsStruct ?struct .
                ?struct struct:hasField ?field .
                ?field struct:fieldName ?fieldName .
                
                FILTER(REGEX(?fieldName, "(password|secret|key|token|credential|api_key|private)", "i"))
                
                # No format_status callback
                FILTER NOT EXISTS {
                    ?module struct:containsFunction ?func .
                    ?func struct:functionName "format_status" .
                    ?func struct:arity 2 .
                }
            }
        """
    ] .

# =============================================================================
# Struct Security Shapes
# =============================================================================

secsh:StructMissingDeriveInspectShape a sh:NodeShape ;
    sh:targetClass struct:Struct ;
    sh:name "Struct Missing @derive Inspect Detection"@en ;
    sh:sparql [
        sh:message "BEAM-014: Struct has sensitive field '{?fieldName}' but no @derive {Inspect, except: [...]}. Sensitive data may be exposed in logs/errors."@en ;
        sh:severity sh:Warning ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this ?fieldName ?moduleName
            WHERE {
                $this a struct:Struct .
                $this struct:hasField ?field .
                ?field struct:fieldName ?fieldName .
                
                # Sensitive field patterns
                FILTER(REGEX(?fieldName, "(password|secret|token|key|credential|ssn|credit_card|api_key)", "i"))
                
                # Get module name for context
                ?module struct:containsStruct $this .
                ?module struct:moduleName ?moduleName .
                
                # No @derive Inspect annotation
                FILTER NOT EXISTS {
                    ?module struct:hasAttribute ?deriveAttr .
                    ?deriveAttr a struct:DeriveAttribute .
                    ?deriveAttr struct:attributeValue ?val .
                    FILTER(CONTAINS(?val, "Inspect"))
                }
            }
        """
    ] .

# =============================================================================
# LiveView Authorization Shape
# =============================================================================

secsh:LiveViewMissingAuthShape a sh:NodeShape ;
    sh:targetClass struct:Module ;
    sh:name "LiveView Missing Authorization Detection"@en ;
    sh:sparql [
        sh:message "WEB-020: LiveView module {?moduleName} has handle_event but may lack authorization checks. Verify authorization in both mount/3 and handle_event/3."@en ;
        sh:severity sh:Info ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX core: <https://w3id.org/elixir-code/core#>
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            
            SELECT $this ?moduleName
            WHERE {
                $this a struct:Module .
                $this struct:moduleName ?moduleName .
                
                # Uses Phoenix.LiveView
                $this struct:usesModule ?liveView .
                ?liveView struct:moduleName "Phoenix.LiveView" .
                
                # Has handle_event
                $this struct:containsFunction ?func .
                ?func struct:functionName "handle_event" .
                
                # Note: This is informational - semantic authorization check
                # would require more complex analysis
            }
        """
    ] .

# =============================================================================
# Process Supervision Shape  
# =============================================================================

secsh:UnsupervisedProcessShape a sh:NodeShape ;
    sh:targetClass otp:GenServerImplementation ;
    sh:name "Unsupervised GenServer Detection"@en ;
    sh:description "Detects GenServer implementations not under supervision."@en ;
    sh:sparql [
        sh:message "OTP-001: GenServer {?moduleName} may not be under supervision. Place all GenServers in supervision tree for fault tolerance."@en ;
        sh:severity sh:Info ;
        sh:prefixes secsh: ;
        sh:select """
            PREFIX struct: <https://w3id.org/elixir-code/structure#>
            PREFIX otp: <https://w3id.org/elixir-code/otp#>
            
            SELECT $this ?moduleName
            WHERE {
                $this a otp:GenServerImplementation .
                $this struct:belongsTo ?module .
                ?module struct:moduleName ?moduleName .
                
                # No supervision relationship found
                FILTER NOT EXISTS {
                    ?supervisor otp:supervises ?process .
                    ?process otp:implementsOTPBehaviour $this .
                }
            }
        """
    ] .

# =============================================================================
# Validation Result Shape
# =============================================================================

secsh:SecurityVulnerabilityShape a sh:NodeShape ;
    sh:targetClass sec:SecurityVulnerability ;
    sh:name "Security Vulnerability Validation"@en ;
    sh:property [
        sh:path sec:severity ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:in ("CRITICAL" "HIGH" "MEDIUM" "LOW") ;
        sh:message "Security vulnerability must have valid severity"@en
    ] ;
    sh:property [
        sh:path sec:erlefId ;
        sh:maxCount 1 ;
        sh:datatype xsd:string ;
        sh:pattern "^(BEAM|WEB)-[0-9]{3}$" ;
        sh:message "ERLEF ID must match pattern BEAM-NNN or WEB-NNN"@en
    ] .
```

---

## 4. SPARQL Query Patterns for Security Detection

These queries use the actual property names and class names from your Elixir ontology set.

### 4.1 Direct Insecure Function Usage Queries

```sparql
# Q1: Detect all atom creation patterns
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX sec: <https://w3id.org/elixir-code/security#>

SELECT ?call ?moduleName ?funcName ?arity ?filePath ?line
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?modRef .
    ?modRef core:name ?moduleName .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName ?funcName .
    ?funcRef struct:arity ?arity .
    
    # Match insecure atom creation patterns
    VALUES (?moduleName ?funcName ?arity) {
        ("String" "to_atom" 1)
        ("List" "to_atom" 1)
        ("Module" "concat" 1)
        ("Module" "concat" 2)
        ("erlang" "binary_to_atom" 1)
        ("erlang" "binary_to_atom" 2)
        ("erlang" "list_to_atom" 1)
    }
    
    OPTIONAL {
        ?call core:hasSourceLocation ?loc .
        ?loc core:inSourceFile ?file .
        ?file core:filePath ?filePath .
        ?loc core:startLine ?line .
    }
}
ORDER BY ?filePath ?line
```

```sparql
# Q2: Detect Code.eval_* patterns (RCE risk)
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?call ?funcName ?inModule ?filePath ?line
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?modRef .
    ?modRef core:name "Code" .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName ?funcName .
    
    FILTER(STRSTARTS(?funcName, "eval_"))
    
    # Get containing module
    ?call core:hasParent+ ?body .
    ?clause struct:hasBody ?body .
    ?func struct:hasClause ?clause .
    ?func struct:belongsTo ?module .
    ?module struct:moduleName ?inModule .
    
    OPTIONAL {
        ?call core:hasSourceLocation ?loc .
        ?loc core:inSourceFile ?file .
        ?file core:filePath ?filePath .
        ?loc core:startLine ?line .
    }
}
```

```sparql
# Q3: Detect :os.cmd and System.shell usage
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?call ?signature ?filePath ?line ?severity
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?modRef .
    ?modRef core:name ?moduleName .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName ?funcName .
    ?funcRef struct:arity ?arity .
    
    VALUES (?moduleName ?funcName ?severity) {
        ("os" "cmd" "CRITICAL")
        ("System" "shell" "HIGH")
    }
    
    BIND(CONCAT(?moduleName, ".", ?funcName, "/", STR(?arity)) AS ?signature)
    
    OPTIONAL {
        ?call core:hasSourceLocation ?loc .
        ?loc core:inSourceFile ?file .
        ?file core:filePath ?filePath .
        ?loc core:startLine ?line .
    }
}
```

```sparql
# Q4: Detect raw/1 XSS patterns
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?call ?filePath ?line ?containingFunc
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?modRef .
    ?modRef core:name ?moduleName .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName "raw" .
    ?funcRef struct:arity 1 .
    
    FILTER(?moduleName IN ("Phoenix.HTML", "Phoenix.HTML.Raw"))
    
    # Get containing function for context
    OPTIONAL {
        ?call core:hasParent+ ?body .
        ?clause struct:hasBody ?body .
        ?func struct:hasClause ?clause .
        ?func struct:functionName ?containingFunc .
    }
    
    OPTIONAL {
        ?call core:hasSourceLocation ?loc .
        ?loc core:inSourceFile ?file .
        ?file core:filePath ?filePath .
        ?loc core:startLine ?line .
    }
}
```

```sparql
# Q5: Detect binary_to_term without safe option
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?call ?filePath ?line
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?modRef .
    ?modRef core:name "erlang" .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName "binary_to_term" .
    ?funcRef struct:arity 1 .  # Arity 1 means no [:safe] option
    
    OPTIONAL {
        ?call core:hasSourceLocation ?loc .
        ?loc core:inSourceFile ?file .
        ?file core:filePath ?filePath .
        ?loc core:startLine ?line .
    }
}
```

### 4.2 Missing Security Controls Queries (NOT EXISTS patterns)

```sparql
# Q6: GenServers with sensitive state missing format_status
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX otp: <https://w3id.org/elixir-code/otp#>

SELECT ?module ?moduleName ?sensitiveField ?filePath
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    
    # Module implements GenServer
    ?module struct:implementsBehaviour ?behaviour .
    ?behaviour struct:moduleName "GenServer" .
    
    # Has struct with sensitive-looking fields
    ?module struct:containsStruct ?struct .
    ?struct struct:hasField ?field .
    ?field struct:fieldName ?sensitiveField .
    
    FILTER(REGEX(?sensitiveField, "(password|secret|key|token|credential)", "i"))
    
    # Missing format_status/2
    FILTER NOT EXISTS {
        ?module struct:containsFunction ?formatFunc .
        ?formatFunc struct:functionName "format_status" .
        ?formatFunc struct:arity 2 .
    }
    
    OPTIONAL {
        ?module core:hasSourceFile ?file .
        ?file core:filePath ?filePath .
    }
}
```

```sparql
# Q7: Structs with sensitive fields missing @derive Inspect
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?module ?moduleName ?struct ?sensitiveField
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    ?module struct:containsStruct ?struct .
    ?struct struct:hasField ?field .
    ?field struct:fieldName ?sensitiveField .
    
    # Sensitive field patterns
    FILTER(REGEX(?sensitiveField, 
        "(password|secret|token|key|credential|ssn|credit_card|api_key|private_key)", "i"))
    
    # No @derive {Inspect, except: [...]} 
    FILTER NOT EXISTS {
        ?module struct:hasAttribute ?attr .
        ?attr a struct:DeriveAttribute .
        ?attr struct:attributeValue ?val .
        FILTER(CONTAINS(?val, "Inspect"))
    }
}
```

```sparql
# Q8: LiveView modules without on_mount authentication hooks
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?module ?moduleName
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    
    # Uses Phoenix.LiveView
    ?module struct:usesModule ?liveViewMod .
    ?liveViewMod struct:moduleName "Phoenix.LiveView" .
    
    # Has handle_event that modifies data
    ?module struct:containsFunction ?handleEvent .
    ?handleEvent struct:functionName "handle_event" .
    
    # No on_mount with auth-related name
    FILTER NOT EXISTS {
        ?module struct:hasAttribute ?onMount .
        ?onMount struct:attributeName "on_mount" .
        ?onMount struct:attributeValue ?mountVal .
        FILTER(REGEX(?mountVal, "(auth|ensure|require)", "i"))
    }
}
```

```sparql
# Q9: Phoenix controllers without authorization checks
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?module ?moduleName ?action ?actionName
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    
    # Is a Phoenix controller (convention: ends with Controller)
    FILTER(STRENDS(?moduleName, "Controller"))
    
    # Has public action functions
    ?module struct:containsFunction ?action .
    ?action a struct:PublicFunction .
    ?action struct:functionName ?actionName .
    ?action struct:arity 2 .  # Controller actions take (conn, params)
    
    # No plug for authorization in the module
    FILTER NOT EXISTS {
        ?module struct:hasAttribute ?plugAttr .
        ?plugAttr struct:attributeName "plug" .
        ?plugAttr struct:attributeValue ?plugVal .
        FILTER(REGEX(?plugVal, "(authorize|ensure_auth|require_auth|check_permission)", "i"))
    }
}
```

### 4.3 Cross-Module Relationship Queries

```sparql
# Q10: Agent accessed from multiple modules (scattered interface smell)
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?agentModule (COUNT(DISTINCT ?callerModule) AS ?accessCount) 
       (GROUP_CONCAT(DISTINCT ?callerModuleName; separator=", ") AS ?callers)
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?agentModRef .
    ?agentModRef core:name ?agentModule .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName ?funcName .
    
    # Agent access functions
    FILTER(?funcName IN ("get", "update", "get_and_update", "cast"))
    
    # Get caller module
    ?call core:hasParent+ ?body .
    ?clause struct:hasBody ?body .
    ?func struct:hasClause ?clause .
    ?func struct:belongsTo ?callerModule .
    ?callerModule struct:moduleName ?callerModuleName .
}
GROUP BY ?agentModule
HAVING (COUNT(DISTINCT ?callerModule) > 1)
ORDER BY DESC(?accessCount)
```

```sparql
# Q11: Functions calling insecure functions (for call graph analysis)
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?callerModule ?callerFunc ?insecureCall ?targetFunc
WHERE {
    # Find the insecure call
    ?insecureCall a core:RemoteCall .
    ?insecureCall core:refersToModule ?modRef .
    ?modRef core:name ?targetMod .
    ?insecureCall struct:callsFunction ?targetFuncRef .
    ?targetFuncRef struct:functionName ?targetFuncName .
    ?targetFuncRef struct:arity ?targetArity .
    
    BIND(CONCAT(?targetMod, ".", ?targetFuncName, "/", STR(?targetArity)) AS ?targetFunc)
    
    # Known insecure functions
    VALUES ?targetFunc {
        "String.to_atom/1"
        "Code.eval_string/1"
        "Code.eval_string/2"
        ":os.cmd/1"
        "Phoenix.HTML.raw/1"
    }
    
    # Find containing function
    ?insecureCall core:hasParent+ ?body .
    ?clause struct:hasBody ?body .
    ?func struct:hasClause ?clause .
    ?func struct:functionName ?callerFuncName .
    ?func struct:arity ?callerArity .
    ?func struct:belongsTo ?callerMod .
    ?callerMod struct:moduleName ?callerModName .
    
    BIND(CONCAT(?callerModName, ".", ?callerFuncName, "/", STR(?callerArity)) AS ?callerFunc)
    BIND(?callerModName AS ?callerModule)
}
ORDER BY ?callerModule ?callerFunc
```

### 4.4 Aggregation Queries

```sparql
# Q12: Security issue count by severity
PREFIX sec: <https://w3id.org/elixir-code/security#>

SELECT ?severity (COUNT(?vuln) AS ?count)
WHERE {
    ?vuln a sec:SecurityVulnerability .
    ?vuln sec:severity ?severity .
}
GROUP BY ?severity
ORDER BY DESC(?count)
```

```sparql
# Q13: Modules with most security issues
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX sec: <https://w3id.org/elixir-code/security#>

SELECT ?moduleName (COUNT(?vuln) AS ?issueCount)
WHERE {
    ?vuln a sec:SecurityVulnerability .
    ?vuln sec:affectsModule ?module .
    ?module struct:moduleName ?moduleName .
}
GROUP BY ?moduleName
HAVING (COUNT(?vuln) > 0)
ORDER BY DESC(?issueCount)
LIMIT 20
```

```sparql
# Q14: Vulnerability distribution by ERLEF category
PREFIX sec: <https://w3id.org/elixir-code/security#>

SELECT ?erlefId ?vulnType (COUNT(?instance) AS ?occurrences)
WHERE {
    ?instance a ?vulnType .
    ?vulnType rdfs:subClassOf* sec:SecurityVulnerability .
    FILTER(?vulnType != sec:SecurityVulnerability)
    
    OPTIONAL { ?vulnType sec:erlefId ?erlefId }
}
GROUP BY ?erlefId ?vulnType
ORDER BY ?erlefId
```

### 4.5 CONSTRUCT Queries for Generating Vulnerability Instances

```sparql
# Q15: Generate AtomExhaustion vulnerability instances
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX sec: <https://w3id.org/elixir-code/security#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    ?vulnInstance a sec:AtomExhaustion ;
        sec:erlefId "BEAM-001" ;
        sec:severity "HIGH" ;
        sec:involvesCall ?call ;
        sec:atSourceLocation ?loc ;
        sec:affectsFunction ?func ;
        sec:affectsModule ?module ;
        sec:secureAlternative "Use String.to_existing_atom/1 or a lookup map" .
}
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule ?modRef .
    ?modRef core:name ?moduleName .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName ?funcName .
    ?funcRef struct:arity ?arity .
    
    VALUES (?moduleName ?funcName ?arity) {
        ("String" "to_atom" 1)
        ("List" "to_atom" 1)
    }
    
    ?call core:hasSourceLocation ?loc .
    
    # Get containing function and module
    ?call core:hasParent+ ?body .
    ?clause struct:hasBody ?body .
    ?func struct:hasClause ?clause .
    ?func struct:belongsTo ?module .
    
    # Generate unique IRI for vulnerability instance
    BIND(IRI(CONCAT(STR(sec:), "AtomExhaustion_", STRUUID())) AS ?vulnInstance)
}
```

---

## 5. Condensed System Prompt Security Guide (~800 words)

```markdown
## ELIXIR/BEAM SECURITY GUIDE FOR CODE GENERATION

You are generating Elixir code. Follow these ERLEF Security Working Group guidelines.

### CRITICAL - NEVER DO THESE:

**1. Never create atoms from user input** (BEAM-001)
Atoms are never garbage collected. Creating atoms from untrusted input causes denial-of-service.
-  `String.to_atom(user_input)`, `List.to_atom(input)`, `Module.concat(user_module)`
-  `:"prefix_#{user_input}"`, `~w[#{input}]a`
-  `String.to_existing_atom(input)` or lookup maps: `%{"opt_a" => :opt_a}[input]`

**2. Never evaluate user-provided code** (BEAM-008)
Full remote code execution vulnerability.
-  `Code.eval_string(user_code)`, `Code.eval_file(path)`, `:file.script(file)`
-  Use embedded sandboxes (Lua via luerl) for untrusted code

**3. Never interpolate user input into SQL** (WEB-004)
SQL injection vulnerability.
-  `Repo.query("SELECT * FROM users WHERE id = #{id}")`
-  `Repo.query("SELECT * FROM users WHERE id = $1", [id])`
-  Ecto queries: `from u in User, where: u.id == ^id`

**4. Never use raw() with user input** (WEB-001)
Cross-site scripting vulnerability.
-  `<%= raw(user_input) %>`, `html(conn, "<p>#{input}</p>")`
-  Phoenix templates auto-escape: `<%= @user_input %>`

**5. Never use :os.cmd for user input** (BEAM-010)
Command injection via shell parsing.
-  `:os.cmd('grep #{pattern} file')`
-  `System.cmd("grep", [pattern, "file"])` with args as list

**6. Never deserialize untrusted ETF without protections** (BEAM-006)
RCE via function deserialization.
-  `:erlang.binary_to_term(data)` without `[:safe]`
-  `Plug.Crypto.non_executable_binary_to_term(data, [:safe])`

### AUTHENTICATION & SESSIONS:

- Hash passwords with Bcrypt/Argon2: `Bcrypt.hash_pwd_salt(password)`
- Regenerate session on login: `configure_session(conn, renew: true)`
- Add `encryption_salt` to Plug.Session configuration
- WebSockets: keep `check_origin: true` OR implement token auth in `connect/3`
- LiveView: verify authorization in BOTH `mount/3` AND `handle_event/3`

### AUTHORIZATION PATTERNS:

**Controller:**
```elixir
def update(conn, %{"id" => id}) do
  resource = Resources.get!(id)
  if can_modify?(conn.assigns.current_user, resource) do
    # proceed
  else
    conn |> put_status(:forbidden) |> halt()
  end
end
```

**LiveView:**
```elixir
def handle_event("delete", %{"id" => id}, socket) do
  if authorized?(socket.assigns.current_user, :delete, id) do
    {:noreply, do_delete(socket, id)}
  else
    {:noreply, put_flash(socket, :error, "Not authorized")}
  end
end
```

### CRYPTOGRAPHIC OPERATIONS:

- Constant-time comparison: `Plug.Crypto.secure_compare(a, b)`
- Never pattern match on secrets: `^token` uses variable-time comparison
- Wrap secrets in closures to prevent stacktrace leakage
- Always verify TLS: include `verify: :verify_peer` in SSL options

### SENSITIVE DATA PROTECTION:

- Add `@derive {Inspect, except: [:password, :secret]}` to structs
- Implement `format_status/2` in GenServers holding sensitive state
- Configure `:filter_parameters` in Phoenix: `["password", "token", "secret"]`
- Use `redact: true` on Ecto schema fields

### INPUT VALIDATION:

- Use Ecto changesets with explicit field allowlists in `cast/3`
- Apply `validate_format/3`, `validate_length/3` for validation
- For uploads: validate content-type against allowlist

### FRAMEWORK DEFAULTS TO PRESERVE:

These Phoenix defaults provide securityensure they remain:
- `protect_from_forgery` in browser pipeline (CSRF)
- `put_secure_browser_headers` in pipelines
- Origin checking on WebSocket connections
- Template auto-escaping
- Ecto parameterized queries

### DEPENDENCIES:

- Use `comeonin` with `bcrypt_elixir` or `argon2_elixir` for passwords
- Use `Phoenix.Token` for API tokens with `max_age` option
- Run `mix deps.audit` and `mix hex.audit` regularly
```

---

## 6. Context-Triggered Security Warnings

### 6.1 Authentication Context

**Trigger:** Generating modules/functions with names containing `auth`, `login`, `session`, `password`, `credential`

```markdown
 AUTHENTICATION SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Hash passwords with Bcrypt/Argon2: `Bcrypt.hash_pwd_salt(password)`
- Use constant-time comparison: `Plug.Crypto.secure_compare/2`
- Implement rate limiting (PlugAttack or Hammer)
- Regenerate session: `configure_session(conn, renew: true)`
- Set session expiration with `max_age`

AVOID:
- Pattern matching on passwords/tokens (timing attack)
- Storing passwords in logs/errors
- Session fixation (always renew on privilege change)
```

### 6.2 Database Query Context

**Trigger:** Generating code using `Ecto`, `Repo`, SQL-related functions

```markdown
 DATABASE QUERY SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Use Ecto Query DSL with `^variable` for ALL user inputs
- Raw SQL: `Repo.query(sql, [param1, param2])`
- fragment(): use `?` placeholders: `fragment("lower(?)", ^value)`

NEVER:
- `"SELECT * FROM #{table} WHERE id = #{id}"`  SQL injection
- `fragment("#{user_input}")`  blocked at compile time for good reason
- String concatenation in query construction

SAFE PATTERNS:
```elixir
from u in User, where: u.email == ^email
Repo.query("SELECT * FROM users WHERE email = $1", [email])
from u in User, where: fragment("lower(?)", u.email) == ^String.downcase(email)
```
```

### 6.3 File Operation Context

**Trigger:** Generating code using `File`, `Path`, upload handling

```markdown
 FILE OPERATION SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Validate and sanitize all file paths from user input
- Use allowlists for permitted directories
- Prevent directory traversal: reject paths containing `..`
- For uploads: validate content-type against allowlist

AVOID:
- `File.read!(user_provided_path)` without validation
- Using user input directly in file paths
- Trusting user-provided filenames

PATH VALIDATION:
```elixir
def safe_path?(path, allowed_base) do
  expanded = Path.expand(path)
  String.starts_with?(expanded, allowed_base) and not String.contains?(path, "..")
end
```
```

### 6.4 Cryptographic Context

**Trigger:** Generating code with crypto, encryption, hashing, tokens

```markdown
 CRYPTOGRAPHIC SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Password hashing: Bcrypt or Argon2 (NOT MD5, SHA1, SHA256 alone)
- Token generation: `:crypto.strong_rand_bytes/1`
- Constant-time comparison: `Plug.Crypto.secure_compare/2`

AVOID:
- Rolling your own crypto
- MD5 or SHA1 for security purposes
- Pattern matching for secret comparison
- `:rand.uniform/1` for security contexts

SECURE PATTERNS:
```elixir
:crypto.strong_rand_bytes(32) |> Base.url_encode64()
Bcrypt.hash_pwd_salt(password)
Plug.Crypto.secure_compare(provided_token, stored_token)
```
```

### 6.5 GenServer/OTP Context

**Trigger:** Generating GenServer, Agent, or process-related code

```markdown
 OTP SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Place ALL GenServers/Agents under supervision trees
- Implement `format_status/2` if state contains sensitive data
- Use `{:continue, :setup}` for expensive init operations (not blocking)

SENSITIVE STATE PROTECTION:
```elixir
@impl true
def format_status(_reason, [_pdict, state]) do
  # Redact sensitive fields before introspection
  [data: [{'State', Map.drop(state, [:api_key, :secret])}]]
end
```

AVOID:
- Starting GenServers outside supervision
- Storing plaintext secrets in state without format_status
- Blocking operations in init/1
```

### 6.6 LiveView Context

**Trigger:** Generating Phoenix LiveView modules

```markdown
 LIVEVIEW SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Verify authorization in BOTH `mount/3` AND `handle_event/3`
- Use `on_mount` hooks for authentication
- Server-side permission checks in every handler

PATTERN:
```elixir
defmodule MyAppWeb.ResourceLive do
  use MyAppWeb, :live_view
  
  on_mount {MyAppWeb.AuthLive, :ensure_authenticated}
  
  def mount(_params, _session, socket) do
    if authorized?(socket.assigns.current_user) do
      {:ok, assign(socket, ...)}
    else
      {:ok, redirect(socket, to: "/")}
    end
  end
  
  def handle_event("delete", %{"id" => id}, socket) do
    # Re-verify authorization - UI hiding is NOT sufficient
    if can_delete?(socket.assigns.current_user, id) do
      {:noreply, do_delete(socket, id)}
    else
      {:noreply, put_flash(socket, :error, "Not authorized")}
    end
  end
end
```

AVOID:
- Auth only in plugs (not checked for WebSocket reconnects)
- Relying on UI to hide unauthorized actions
- Trusting client-provided data without server validation
```

### 6.7 WebSocket Context

**Trigger:** Generating Phoenix Socket or Channel code

```markdown
 WEBSOCKET SECURITY CONTEXT ACTIVE

REQUIREMENTS:
- Keep `check_origin: true` OR implement token authentication
- Verify user identity in `connect/3` callback
- Authorize channel joins in `join/3`
- Authorize all incoming messages

SECURE PATTERN:
```elixir
# In endpoint
socket "/socket", MyApp.UserSocket,
  websocket: [check_origin: true]

# In socket
def connect(%{"token" => token}, socket, _connect_info) do
  case Phoenix.Token.verify(MyApp.Endpoint, "user", token, max_age: 86400) do
    {:ok, user_id} -> {:ok, assign(socket, :user_id, user_id)}
    {:error, _} -> :error
  end
end

# In channel
def join("room:" <> room_id, _params, socket) do
  if authorized?(socket.assigns.user_id, room_id) do
    {:ok, socket}
  else
    {:error, %{reason: "unauthorized"}}
  end
end
```

AVOID:
- `check_origin: false` without alternative authentication
- Trusting client-provided user identity
- Skipping authorization in message handlers
```

---

## 7. Hybrid Architecture Integration

### 7.1 Pipeline Flow

```

                    JidoCode Security Prevention Pipeline                         

                                                                                   
      
                     LAYER 1: CONTEXT DETECTION (~5%)                           
                                                                                 
     User Request  Analyze for security-sensitive contexts                      
     Contexts: Auth, Database, File, Crypto, Input, API, WebSocket, LiveView     
     Output: Activate relevant context-triggered warnings                        
      
                                                                                  
      
                LAYER 2: LLM GENERATION WITH SECURITY GUIDE (~70%)               
                                                                                 
     System Prompt includes:                                                     
      Base security guide (~800 words, always active)                          
      Context-triggered warnings (dynamically injected)                        
      Project conventions from ontology queries                                 
      
                                                                                  
      
                 LAYER 3: REAL-TIME AST VALIDATION (~15%)                        
                                                                                 
     As code streams, incrementally check for:                                  
      Insecure function calls (to_atom, eval_*, raw, os:cmd)                   
      Missing safe options (binary_to_term/1)                                  
      String interpolation in SQL/shell contexts                               
     On violation: Interrupt, provide secure alternative                         
      
                                                                                  
      
              LAYER 4: SEMANTIC ONTOLOGY ANALYSIS (~7%)                          
                                                                                 
     Post-generation SPARQL queries against project ontology:                   
      Data flow: untrusted input  sensitive sinks?                            
      Missing controls: format_status, @derive Inspect?                        
      Cross-module: Agent scattered access, circular deps?                      
     Uses SHACL shapes for constraint validation                                 
      
                                                                                  
      
            LAYER 5: STATIC ANALYSIS INTEGRATION (~3%)                           
                                                                                 
     Run Sobelow on generated code:                                              
      SQL.Inject, XSS.Raw, CI.System, DOS.BinToTerm                            
      Config.CSRF, Config.HTTPS, Traversal.FileModule                          
     Aggregate with SPARQL results into unified report                           
      
                                                                                  
      
                       FEEDBACK & REMEDIATION                                    
                                                                                 
     If issues found:                                                            
     1. Generate structured feedback with ERLEF ID, location, severity          
     2. Provide secure alternative code pattern                                 
     3. Request targeted regeneration                                            
     4. Verify fix before final output                                          
      
                                                                                   

```

### 7.2 Elixir Implementation Module

```elixir
defmodule JidoCode.Security.ValidationPipeline do
  @moduledoc """
  Unified security validation pipeline integrating with the Elixir ontology set.
  
  Uses:
  - sec: https://w3id.org/elixir-code/security#
  - core: https://w3id.org/elixir-code/core#
  - struct: https://w3id.org/elixir-code/structure#
  - otp: https://w3id.org/elixir-code/otp#
  """
  
  alias JidoCode.Security.{
    ContextDetector,
    ASTValidator,
    OntologyAnalyzer,
    SobelowIntegration,
    FeedbackFormatter
  }
  
  @type validation_result :: :approved | {:warn, [issue()]} | {:block, [issue()]}
  @type issue :: %{
    source: :ast | :ontology | :sobelow,
    erlef_id: String.t() | nil,
    severity: :critical | :high | :medium | :low,
    location: %{file: String.t(), line: pos_integer()},
    message: String.t(),
    secure_alternative: String.t() | nil
  }
  
  @critical_patterns [
    # Atom exhaustion
    {"String", "to_atom", 1, "BEAM-001", "String.to_existing_atom/1 or lookup map"},
    {"List", "to_atom", 1, "BEAM-001", "List.to_existing_atom/1"},
    {"erlang", "binary_to_atom", 1, "BEAM-001", "binary_to_existing_atom/2"},
    {"erlang", "binary_to_atom", 2, "BEAM-001", "binary_to_existing_atom/2"},
    {"Module", "concat", 1, "BEAM-001", "Module.safe_concat/1"},
    {"Module", "concat", 2, "BEAM-001", "Module.safe_concat/2"},
    
    # Code injection
    {"Code", "eval_string", 1, "BEAM-008", "Embedded sandbox (Lua)"},
    {"Code", "eval_string", 2, "BEAM-008", "Embedded sandbox (Lua)"},
    {"Code", "eval_string", 3, "BEAM-008", "Embedded sandbox (Lua)"},
    {"Code", "eval_file", 1, "BEAM-008", "Avoid on untrusted input"},
    {"Code", "eval_file", 2, "BEAM-008", "Avoid on untrusted input"},
    {"Code", "eval_quoted", 2, "BEAM-008", "Avoid on untrusted input"},
    {"Code", "eval_quoted", 3, "BEAM-008", "Avoid on untrusted input"},
    {"file", "script", 1, "BEAM-009", "Avoid on untrusted input"},
    {"file", "script", 2, "BEAM-009", "Avoid on untrusted input"},
    {"file", "eval", 1, "BEAM-009", "Avoid on untrusted input"},
    {"file", "eval", 2, "BEAM-009", "Avoid on untrusted input"},
    
    # Command injection
    {"os", "cmd", 1, "BEAM-010", "System.cmd/3 with args list"},
    {"os", "cmd", 2, "BEAM-010", "System.cmd/3 with args list"},
    {"System", "shell", 1, "BEAM-010", "System.cmd/3 with args list"},
    {"System", "shell", 2, "BEAM-010", "System.cmd/3 with args list"},
    
    # Unsafe deserialization
    {"erlang", "binary_to_term", 1, "BEAM-006", "binary_to_term(data, [:safe])"},
    
    # XSS
    {"Phoenix.HTML", "raw", 1, "WEB-001", "Default template escaping"},
    {"Phoenix.HTML.Raw", "raw", 1, "WEB-001", "Default template escaping"}
  ]
  
  @doc """
  Run the full security validation pipeline on generated code.
  """
  @spec validate(String.t(), map()) :: validation_result()
  def validate(generated_code, context) do
    with {:ok, ast} <- parse_code(generated_code),
         {:ok, ast_issues} <- ASTValidator.validate(ast, @critical_patterns),
         {:ok, _} <- update_ontology(ast, context),
         {:ok, ontology_issues} <- OntologyAnalyzer.run_security_queries(context),
         {:ok, sobelow_issues} <- SobelowIntegration.analyze(generated_code) do
      
      all_issues = 
        (ast_issues ++ ontology_issues ++ sobelow_issues)
        |> Enum.sort_by(&severity_weight/1, :desc)
        |> Enum.uniq_by(&{&1.erlef_id, &1.location})
      
      determine_action(all_issues)
    else
      {:error, :parse_error, details} ->
        {:block, [%{source: :ast, severity: :critical, message: "Parse error: #{details}"}]}
    end
  end
  
  defp parse_code(code) do
    case Code.string_to_quoted(code) do
      {:ok, ast} -> {:ok, ast}
      {:error, {line, msg, _}} -> {:error, :parse_error, "Line #{line}: #{msg}"}
    end
  end
  
  defp update_ontology(ast, context) do
    # Add generated code individuals to ontology
    # This would use the SPARQL client to INSERT triples
    JidoCode.Ontology.update_from_ast(ast, context.repository_uri)
  end
  
  defp severity_weight(%{severity: :critical}), do: 4
  defp severity_weight(%{severity: :high}), do: 3
  defp severity_weight(%{severity: :medium}), do: 2
  defp severity_weight(%{severity: :low}), do: 1
  
  defp determine_action(issues) do
    cond do
      Enum.any?(issues, &(&1.severity == :critical)) ->
        {:block, issues}
      
      Enum.any?(issues, &(&1.severity in [:high, :medium])) ->
        {:warn, issues}
      
      Enum.empty?(issues) ->
        :approved
      
      true ->
        {:warn, issues}
    end
  end
end
```

### 7.3 Feedback Format

```json
{
  "validation_result": "blocked",
  "issues": [
    {
      "source": "ast",
      "erlef_id": "BEAM-001",
      "vulnerability_type": "AtomExhaustion",
      "owasp_category": "A05:2021-Security Misconfiguration",
      "severity": "HIGH",
      "detectability": "AST",
      "location": {
        "file": "lib/my_app/user_controller.ex",
        "line": 42,
        "column": 5,
        "function": "create/2"
      },
      "insecure_code": "String.to_atom(params[\"role\"])",
      "message": "Creating atoms from user input can exhaust the atom table (max 1M), crashing the VM.",
      "secure_alternative": {
        "code": "Map.get(%{\"admin\" => :admin, \"user\" => :user}, params[\"role\"], :user)",
        "explanation": "Use a lookup map to convert strings to predefined atoms safely."
      },
      "references": [
        "https://security.erlef.org/secure_coding_and_deployment_hardening#atom-exhaustion"
      ]
    }
  ],
  "suggested_regeneration": {
    "scope": "function",
    "target": "create/2",
    "instruction": "Replace atom creation from user input with lookup map pattern"
  }
}
```

---

## 8. Implementation Priorities

### Phase 1: Critical AST Patterns (Week 1-2)
**Blocks 80% of critical vulnerabilities**

1. Implement `@critical_patterns` detection in AST validator
2. Add real-time interruption on pattern match
3. Create feedback formatter with secure alternatives

### Phase 2: System Prompt Integration (Week 2-3)

1. Embed base security guide in all Elixir generation prompts
2. Implement context detector for triggered warnings
3. Build prompt injection pipeline

### Phase 3: Sobelow Integration (Week 3-4)

1. Programmatic Sobelow execution wrapper
2. Result mapping to unified feedback format
3. Issue aggregation with deduplication

### Phase 4: Ontology SPARQL Queries (Week 4-6)

1. Deploy security ontology to SPARQL endpoint
2. Implement high-priority queries:
   - Missing format_status
   - Missing @derive Inspect
   - Unsupervised processes
   - Authorization gaps
3. SHACL validation engine integration

### Phase 5: Advanced Semantic Analysis (Week 6-8)

1. Data flow tracking via ontology relationships
2. Cross-module security analysis
3. Configuration validation queries

---

## 9. ERLEF Security Rules Catalog Reference

| ID | Vulnerability | Severity | Detectability | Primary Detection |
|----|--------------|----------|---------------|-------------------|
| BEAM-001 | Atom exhaustion via String.to_atom | HIGH | AST | Pattern match |
| BEAM-002 | Atom exhaustion via interpolation | HIGH | AST | Pattern match |
| BEAM-003 | Atom exhaustion via Module.concat | HIGH | AST | Pattern match |
| BEAM-006 | RCE via binary_to_term | CRITICAL | AST | Pattern match |
| BEAM-008 | RCE via Code.eval_* | CRITICAL | AST | Pattern match |
| BEAM-010 | Command injection via os:cmd | CRITICAL | AST | Pattern match |
| BEAM-012 | Secret in stacktraces | HIGH | Semantic | SPARQL |
| BEAM-013 | Secret via introspection | HIGH | Semantic | SPARQL + SHACL |
| BEAM-014 | Missing @derive Inspect | HIGH | Semantic | SPARQL + SHACL |
| BEAM-015 | Timing attacks | MEDIUM | Semantic | SPARQL |
| BEAM-016 | TLS without verification | CRITICAL | Config | Sobelow |
| WEB-001 | XSS via raw() | CRITICAL | AST | Pattern match |
| WEB-004 | SQL injection | CRITICAL | AST + Semantic | Sobelow + SPARQL |
| WEB-006 | Missing CSRF protection | HIGH | Config | Sobelow |
| WEB-009 | Missing authorization | CRITICAL | Semantic | SPARQL |
| WEB-016 | Sensitive data in logs | HIGH | Config | Sobelow |
| WEB-017 | Mass assignment | HIGH | Semantic | SPARQL |
| WEB-020 | LiveView auth bypass | CRITICAL | Semantic | SPARQL |

---

## 10. Files to Create

Based on this document, you should create:

1. **`ontology/elixir-security.ttl`** - The security ontology (Section 2)
2. **`ontology/elixir-security-shapes.ttl`** - SHACL shapes (Section 3)
3. **`lib/jido_code/security/validation_pipeline.ex`** - Main pipeline (Section 7.2)
4. **`lib/jido_code/security/ast_validator.ex`** - AST pattern matching
5. **`lib/jido_code/security/ontology_analyzer.ex`** - SPARQL query runner
6. **`lib/jido_code/security/sobelow_integration.ex`** - Sobelow wrapper
7. **`lib/jido_code/security/context_detector.ex`** - Context detection
8. **`lib/jido_code/security/feedback_formatter.ex`** - Feedback generation
9. **`priv/prompts/security_guide.md`** - System prompt guide (Section 5)
10. **`priv/prompts/context_warnings/`** - Context-triggered warnings (Section 6)

