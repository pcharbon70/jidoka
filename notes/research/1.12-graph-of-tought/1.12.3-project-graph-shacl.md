**1\. OWL alignment with the Elixir code ontology**

Here we **reuse** your Elixir concepts instead of inventing parallel ones.

**1.1 Class-level alignment**

We treat project-graph Module, Function, and SourceFile as the _same_ as your Elixir code entities:

@prefix pg: &lt;<http://jido.ai/ontologies/project-graph#>&gt; .

@prefix elixir: &lt;<http://jido.ai/ontologies/elixir-code#>&gt; .

@prefix owl: &lt;<http://www.w3.org/2002/07/owl#>&gt; .

@prefix rdfs: &lt;<http://www.w3.org/2000/01/rdf-schema#>&gt; .

\### Class equivalences

pg:Module owl:equivalentClass elixir:Module .

pg:Function owl:equivalentClass elixir:Function .

pg:SourceFile owl:equivalentClass elixir:SourceFile .

\### Optional: link broader CodeArtifact to your code hierarchy

pg:CodeArtifact rdfs:subClassOf elixir:CodeEntity .

(Replace elixir:CodeEntity with whatever your root code concept is; or drop that axiom if you don't have one.)

**1.2 Property alignment**

If your Elixir ontology already has datatype properties like moduleName, functionName, filePath, we can align:

pg:moduleName owl:equivalentProperty elixir:moduleName .

pg:functionName owl:equivalentProperty elixir:functionName .

pg:filePath owl:equivalentProperty elixir:filePath .

If your Elixir ontology uses different names (e.g. elixir:hasModuleName), just swap them in.

**1.3 Cross-linking artifacts and Elixir entities (optional but nice)**

If you want a more explicit mapping between a "project artifact node" and a "semantic Elixir entity node", you can add:

pg:representsElixirEntity a owl:ObjectProperty ;

rdfs:domain pg:CodeArtifact ;

rdfs:range elixir:CodeEntity ;

rdfs:label "representsElixirEntity" ;

rdfs:comment "Relates a project graph CodeArtifact to the corresponding Elixir code entity." .

Then in practice:

pg:artifact_mod_invoice a pg:Module ;

pg:representsElixirEntity elixir:Module_Jido_Invoice ;

pg:moduleName "Jido.Invoice" .

This lets the GoT graph and the Elixir code ontology stay distinct but linked.

**2\. SHACL shapes for the project-graph ontology**

I'll define SHACL in a **separate shapes graph** (recommended), e.g. project-graph.shacl.ttl.

We'll validate:

- Projects
- Goals
- Tasks
- AgentRuns
- Artifacts
- ErrorReports

**2.1 Prefixes**

@prefix sh: &lt;<http://www.w3.org/ns/shacl#>&gt; .

@prefix pg: &lt;<http://jido.ai/ontologies/project-graph#>&gt; .

@prefix xsd: &lt;<http://www.w3.org/2001/XMLSchema#>&gt; .

@prefix rdfs: &lt;<http://www.w3.org/2000/01/rdf-schema#>&gt; .

@prefix pgsh: &lt;<http://jido.ai/ontologies/project-graph/shapes#>&gt; .

**2.2 Project shape**

Requirements:

- MUST have pg:hasIdentifier (1)
- MUST have pg:hasTitle (1)
- MAY have zero or more pg:hasGoal, pg:hasTask
- SHOULD have pg:hasStatus (0..1)

pgsh:ProjectShape

a sh:NodeShape ;

sh:targetClass pg:Project ;

sh:property \[

sh:path pg:hasIdentifier ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "project identifier" ;

sh:description "Every Project must have a stable identifier." ;

\] ;

sh:property \[

sh:path pg:hasTitle ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "project title" ;

sh:description "Every Project must have a title." ;

\] ;

sh:property \[

sh:path pg:hasGoal ;

sh:class pg:Goal ;

sh:minCount 0 ;

sh:name "goals" ;

\] ;

sh:property \[

sh:path pg:hasTask ;

sh:class pg:Task ;

sh:minCount 0 ;

sh:name "tasks" ;

\] ;

sh:property \[

sh:path pg:hasStatus ;

sh:class pg:Status ;

sh:maxCount 1 ;

sh:name "status" ;

\] .

**2.3 Goal shape**

Requirements:

- MUST belong to exactly 1 project (pg:goalForProject)
- MUST have identifier + title
- MUST have a status
- Optional description

pgsh:GoalShape

a sh:NodeShape ;

sh:targetClass pg:Goal ;

sh:property \[

sh:path pg:goalForProject ;

sh:class pg:Project ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "project" ;

sh:description "Every Goal must belong to exactly one Project." ;

\] ;

sh:property \[

sh:path pg:hasIdentifier ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "goal identifier" ;

\] ;

sh:property \[

sh:path pg:hasTitle ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "goal title" ;

\] ;

sh:property \[

sh:path pg:hasDescription ;

sh:datatype xsd:string ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "goal description" ;

\] ;

sh:property \[

sh:path pg:hasStatus ;

sh:class pg:Status ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "goal status" ;

\] .

**2.4 Task shape**

Requirements:

- MUST belong to 1 project (pg:taskForProject)
- Optional: refine 0..1 goal (pg:refinesGoal)
- MUST have identifier + title
- MUST have status
- MAY depend on other tasks

pgsh:TaskShape

a sh:NodeShape ;

sh:targetClass pg:Task ;

sh:property \[

sh:path pg:taskForProject ;

sh:class pg:Project ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "project" ;

\] ;

sh:property \[

sh:path pg:refinesGoal ;

sh:class pg:Goal ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "refined goal" ;

\] ;

sh:property \[

sh:path pg:hasIdentifier ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "task identifier" ;

\] ;

sh:property \[

sh:path pg:hasTitle ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "task title" ;

\] ;

sh:property \[

sh:path pg:hasDescription ;

sh:datatype xsd:string ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "task description" ;

\] ;

sh:property \[

sh:path pg:hasStatus ;

sh:class pg:Status ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "task status" ;

\] ;

sh:property \[

sh:path pg:dependsOnTask ;

sh:class pg:Task ;

sh:minCount 0 ;

sh:name "task dependencies" ;

\] ;

sh:property \[

sh:path pg:hasThought ;

sh:class pg:Thought ;

sh:minCount 0 ;

sh:name "associated thoughts" ;

\] .

**2.5 AgentRun shape**

Requirements:

- MUST apply to 1 task
- MUST have 1 runner type
- MUST have startedAt
- SHOULD have endedAt
- Optional tokenCount
- Outcomes optional but encouraged

pgsh:AgentRunShape

a sh:NodeShape ;

sh:targetClass pg:AgentRun ;

sh:property \[

sh:path pg:appliesToTask ;

sh:class pg:Task ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "task" ;

\] ;

sh:property \[

sh:path pg:usesRunnerType ;

sh:class pg:RunnerType ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "runner type" ;

\] ;

sh:property \[

sh:path pg:startedAt ;

sh:datatype xsd:dateTime ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "start time" ;

\] ;

sh:property \[

sh:path pg:endedAt ;

sh:datatype xsd:dateTime ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "end time" ;

\] ;

sh:property \[

sh:path pg:tokenCount ;

sh:datatype xsd:integer ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "token count" ;

\] ;

sh:property \[

sh:path pg:hasOutcome ;

sh:class pg:Outcome ;

sh:minCount 0 ;

sh:name "outcomes" ;

\] ;

sh:property \[

sh:path pg:hasPrimaryThought ;

sh:class pg:Thought ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "primary thought" ;

\] .

**2.6 Artifact shape (generic)**

- MUST have identifier
- SHOULD have title
- Subclass-specific shapes can refine further.

pgsh:ArtifactShape

a sh:NodeShape ;

sh:targetClass pg:Artifact ;

sh:property \[

sh:path pg:hasIdentifier ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "artifact identifier" ;

\] ;

sh:property \[

sh:path pg:hasTitle ;

sh:datatype xsd:string ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "artifact title" ;

\] .

**2.6.1 SourceFile shape**

pgsh:SourceFileShape

a sh:NodeShape ;

sh:targetClass pg:SourceFile ;

sh:property \[

sh:path pg:filePath ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "file path" ;

\] .

**2.6.2 Module shape**

pgsh:ModuleShape

a sh:NodeShape ;

sh:targetClass pg:Module ;

sh:property \[

sh:path pg:moduleName ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "module name" ;

\] .

**2.6.3 Function shape**

pgsh:FunctionShape

a sh:NodeShape ;

sh:targetClass pg:Function ;

sh:property \[

sh:path pg:functionName ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "function name" ;

\] .

**2.7 ErrorReport shape**

- MUST report error for some task
- MUST have errorMessage
- Optional errorType, errorCode

pgsh:ErrorReportShape

a sh:NodeShape ;

sh:targetClass pg:ErrorReport ;

sh:property \[

sh:path pg:reportsErrorFor ;

sh:class pg:Task ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "task with error" ;

\] ;

sh:property \[

sh:path pg:errorMessage ;

sh:datatype xsd:string ;

sh:minCount 1 ;

sh:maxCount 1 ;

sh:name "error message" ;

\] ;

sh:property \[

sh:path pg:errorType ;

sh:datatype xsd:string ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "error type" ;

\] ;

sh:property \[

sh:path pg:errorCode ;

sh:datatype xsd:string ;

sh:minCount 0 ;

sh:maxCount 1 ;

sh:name "error code" ;

\] .

**How this plugs into JidoCode**

- When the GoT orchestrator writes new individuals (Project/Goal/Task/Run/Artifact) into your RDF store:
  - You can run SHACL validation as a **guardrail** step.
- When you ingest code structure from your Elixir ontology:
  - Alignment axioms (owl:equivalentClass, owl:equivalentProperty) make those entities usable as pg:Module / pg:Function in the project-graph.
- When the planner wants context:
  - It can query across _both_ project graph and Elixir ontology seamlessly ("find all functions in modules touched by open tasks").
