# Graph-of-Thought Architecture

We'll treat:

- **CoT** and **ToT** as _pluggable JidoAi runners_
- **GoT** as: "A long-lived project reasoning graph backed by your OWL ontology"

## 0. Mental model

- **CoT runner** = "solve this _local_ coding task step-by-step"
- **ToT runner** = "explore multiple candidate plans/solutions, rank them"
- **GoT layer** = "keep a _graph_ of goals, tasks, code artifacts, decisions, and their relationships in OWL, and use that to steer all future reasoning"

So the GoT layer is basically:

An **orchestrator** + **graph store** + **schema (OWL)** that coordinates many CoT/ToT calls over time.

## 1. Core components (Elixir / Jido naming)

### 1.1 GoT orchestrator

```elixir
defmodule JidoCode.GoT.Orchestrator do
  @moduledoc """
  Top-level entrypoint for Graph-of-Thought project reasoning.
  """

  # public API
  def handle_goal(project_id, goal_spec, options \\ []) do
    # 1. Register goal in ontology
    # 2. Ask Planner for task graph
    # 3. Execute tasks with TaskExecutor
    # 4. Update GoT graph + return summary
  end
end
```

Responsibilities:

- Entry point for "big" user intents:
  - "Implement feature X"
  - "Refactor module Y"
  - "Add new Commanded aggregate Z"
- Writes/reads from the **project ontology**
- Delegates to:
  - Planner
  - TaskGraph
  - TaskExecutor

### 1.2 Project ontology / graph adapter

Backed by your OWL project ontology + Turtle persistence (e.g. via RDF.ex + chosen store).

```elixir
defmodule JidoCode.GoT.ProjectGraph do
  @moduledoc """
  Adapter over the OWL project ontology (TBox + ABox) to manage the GoT graph.
  """

  # Goal / Task / Artifact nodes
  def create_goal(project_id, goal_spec), do: ...
  def create_task(project_id, goal_id, task_spec), do: ...
  def link_task_dependency(task_id, depends_on_task_id), do: ...
  def attach_artifact(task_id, artifact_spec), do: ...
  def attach_decision(task_id, decision_spec), do: ...

  # Query
  def fetch_open_tasks(project_id), do: ...
  def fetch_related_artifacts(module_path), do: ...
end
```

This is where OWL comes in:

- Ontology classes (TBox):
  - Project, Goal, Task, SubTask,
  - CodeArtifact, TestArtifact, Decision, AgentRun, Error, Hypothesis, etc.
- Object properties:
  - hasTask, dependsOnTask, implements, touchesModule,
    hasStatus, derivedFromThought, precedesTask, conflictsWith, etc.

Each **thought** at GoT level is an individual in the ontology.

### 1.3 TaskGraph model (in-memory view)

You'll want an in-memory representation of the **task dependency graph** derived from / synchronized with OWL.

```elixir
defmodule JidoCode.GoT.TaskGraph do
  @moduledoc """
  In-memory task graph backed by the OWL project ontology.
  """

  def build_from_project(project_id) do
    # query ProjectGraph and build a DAG/graph of tasks
  end

  def ready_tasks(graph) do
    # tasks with all dependencies satisfied
  end

  def mark_task_completed(graph, task_id), do: ...
end
```

This is your "working graph" while orchestrating; the truth lives in the ontology.

### 1.4 Planner (GoT → ToT / CoT bridge)

Planner takes a **goal** and uses CoT/ToT to produce a **task graph**.

```elixir
defmodule JidoCode.GoT.Planner do
  alias JidoAi.{CotRunner, TotRunner}

  def plan_goal(project_id, goal_id, goal_spec) do
    # 1. Get project context & ontology info
    context = JidoCode.ContextBuilder.build(project_id)

    # 2. Use ToT runner to propose multiple decompositions
    candidates =
      TotRunner.run(:planning, %{
        goal: goal_spec,
        context: context,
        ontology_snippets: ...
      })

    # 3. Optionally call CoT/ToT again as judge for best candidate
    best_plan = select_best_plan(candidates, context)

    # 4. Persist plan as Task individuals in the ontology via ProjectGraph
    ProjectGraph.materialize_plan(project_id, goal_id, best_plan)
  end
end
```

Planner uses:

- **Ontology** to guide planning:
  - Already-known modules
  - Existing aggregates/entities
  - Architectural constraints (e.g. "Use Ash + Commanded conventions")
- **ToT runner** to:
  - Explore several candidate decompositions
  - Possibly several architectural variants
- **CoT runner** for:
  - Local reasoning when transforming the chosen plan into concrete tasks & dependencies

### 1.5 TaskExecutor (GoT → agent/runner execution)

```elixir
defmodule JidoCode.GoT.TaskExecutor do
  alias JidoAi.{CotRunner, TotRunner}

  def execute_ready_tasks(project_id, graph) do
    for task <- TaskGraph.ready_tasks(graph) do
      execute_task(project_id, task)
    end
  end

  defp execute_task(project_id, %Task{kind: :code_generation} = task) do
    # Small, local = CoT
    result =
      CotRunner.run(:code_generation, %{
        task: task,
        context: build_context_for_task(project_id, task)
      })

    persist_result(project_id, task, result)
  end

  defp execute_task(project_id, %Task{kind: :design_exploration} = task) do
    # Needs exploration = ToT
    candidates =
      TotRunner.run(:design_exploration, %{
        task: task,
        context: build_context_for_task(project_id, task)
      })

    selected = choose_candidate(candidates)
    persist_result(project_id, task, selected)
  end
end
```

You can later add specialized agents:

- CodeGenAgent (CoT-heavy)
- RefactorAgent (CoT + ToT for alternative refactors)
- TestAgent (CoT to write tests, run them, interpret failures)
- ReviewAgent (ToT / judge pattern)

Each agent run is also stored in the ontology as an AgentRun / Thought node linked to:

- The task
- The artifacts modified
- Any errors produced

## 2. How the OWL ontology anchors Graph-of-Thought

### 2.1 TBox (schema-level)

Define core concepts in your **project ontology**:

- **Goals & tasks**
  - :Goal
  - :Task
  - :SubTask
  - :PlanningThought (high-level decomposition)
- **Artifacts**
  - :CodeArtifact (file, module, function)
  - :TestArtifact (test file, case)
  - :ConfigArtifact
- **Reasoning / runs**
  - :Thought (a reasoning step)
  - :AgentRun (one CoT/ToT execution)
  - :Decision
  - :ErrorReport
- **Relations (object properties)**
  - :hasTask(project, task)
  - :dependsOnTask(task, task)
  - :implements(task, artifact)
  - :touchesModule(artifact, moduleUri)
  - :hasThought(task, thought)
  - :generatedBy(thought, agentRun)
  - :hasOutcome(agentRun, decision | error)
  - :precedesTask(task, task)
  - :relatesToConcept(task, ontologyConcept) (tie to domain/tech ontologies)

This gives you a **typed Graph-of-Thought** where:

- Nodes = individuals of these classes
- Edges = object properties

### 2.2 ABox (instance-level)

During a real run:

- When a user asks: "Add an Invoice aggregate":
  - Create :goal_123 a :Goal
- Planner decomposes into tasks:
  - :task_1 a :Task ; :dependsOnTask :task_0 etc.
- Each agent call:
  - Create :run_42 a :AgentRun ; :hasThought :thought_9
  - Link :thought_9 to :task_1, :codeArtifact_abc etc.

Over time, your OWL ABox **is** your Graph-of-Thought memory.

## 3. End-to-end flow for a feature request

Let's walk a realistic example:

User (in JidoCode TUI):
"Implement a new event-sourced Invoice aggregate using Commanded + Ash, with basic create/pay/cancel flows and tests."

### Step 1 - Orchestrator registers goal

- Orchestrator.handle_goal/3:
  - Creates :goal_InvoiceAggregate individual
  - Attaches metadata (user text, time, project id)

### Step 2 - Planner builds task graph (GoT + ToT)

- Planner.plan_goal/3:
  - Loads current project ontology: knows about OrderAggregate, CustomerAggregate etc.
  - Calls TotRunner.run(:planning, ...) with:
    - Repo structure
    - Ontology concepts (e.g. :Invoice, :Aggregate, :Command, :Event)
  - ToT returns **several candidate decompositions**, e.g.:
    - Plan A: "Aggregate first → events → projectors → tests"
    - Plan B: "Start from API (Ash resources) → work inward"
    - Plan C: "Copy Order aggregate pattern and rename"
  - Planner picks best (maybe via a ToT judge or CoT heuristic).
  - ProjectGraph.materialize_plan/3 writes all the tasks + dependencies as individuals.

### Step 3 - TaskExecutor runs tasks (GoT orchestrating CoT/ToT)

- TaskExecutor.execute_ready_tasks/2:
  - Task 1: "Analyze Order aggregate for pattern"
    - CoT runner on a small reasoning prompt
    - Output: mermaid-like design, list of patterns → stored as Thought + Decision.
  - Task 2: "Design Invoice events & commands"
    - ToT runner explores e.g.:
      - {InvoiceCreated, InvoicePaid, InvoiceCancelled}
      - with or without InvoiceOverdue, etc.
    - Best design stored as new individuals :InvoiceCreatedEvent, etc.
  - Task 3: "Generate aggregate code"
    - CoT runner writes actual Elixir modules
    - Artifacts attached as CodeArtifact individuals linked via :implements.
  - ...
- Each step:
  - Updates both the **file system / git** _and_ the **project ontology**.

### Step 4 - Feedback loops

If tests fail:

- TestAgent creates an ErrorReport individual
- Link from :task_tests to :error_567
- Planner can see that failure is related to e.g. :Decision_X and schedule:
  - New task: "Revisit decision X about InvoiceCancellation semantics."

This is **Graph-of-Thought** in action: failures and decisions are connected across many reasoning episodes.

## 4. How CoT and ToT runners "plug in"

In your JidoAi layer you might have behaviours:

```elixir
defmodule JidoAi.Runner do
  @callback run(atom(), map()) :: any()
end

defmodule JidoAi.CotRunner do
  @behaviour JidoAi.Runner

  def run(task_type, payload), do: ...
end

defmodule JidoAi.TotRunner do
  @behaviour JidoAi.Runner

  def run(task_type, payload), do: ...
end
```

GoT layer **never** cares _how_ CoT/ToT are implemented; it just:

- Chooses **when** to call ToT vs CoT based on:
  - Task type (:design, :planning, :refactor → ToT)
  - Task scope (:local_code_change, :fix_compile_error → CoT)
- Records each run as a node (:AgentRun) in the ontology.

That separation keeps things very modular:

- Swap models / backends → no change to GoT architecture
- Add a new runner (e.g. "StaticAnalysisRunner") → plug it into TaskExecutor and Planner, still storing everything in OWL.

## 5. Why this is "real" Graph-of-Thought

The key GoT properties this design gives you:

- **Thoughts are persistent, addressable nodes**
  - Every plan, subtask, agent run, and decision is an OWL individual.
- **Reasoning is not one tree, but an evolving graph**
  - Tasks cross-reference prior goals, artifacts, and decisions.
  - New features can depend on, or refactor, old ones.
- **Multiple agents / runners share the same graph**
  - Planner, CodeGen, Test, Refactor all write/read the same ontology.
- **Long-term learning about the project**
  - Future planning prompts can be grounded in:
    - "Show me all existing aggregates with payment semantics"
    - "Find previous tasks where we added invoice-like entities"
  - That's exactly where your OWL backbone shines.

```mermaid
flowchart LR
%% LAYOUT
classDef layer fill:#f5f5f5,stroke:#999,stroke-width:1px,rx:6px,ry:6px;
classDef entity fill:#fff,stroke:#555,stroke-width:1px,rx:4px,ry:4px;
classDef runner fill:#eef7ff,stroke:#4a6fa5,stroke-width:1px,rx:4px,ry:4px;
classDef storage fill:#fef8e7,stroke:#b38b00,stroke-width:1px,rx:4px,ry:4px;

%% USER / TUI
subgraph S0[User & TUI]
  U[Developer in JidoCode TUI<br/>(gives high-level goal)]
end
class S0 layer;

%% GOT ORCHESTRATOR LAYER
subgraph S1[Graph-of-Thought Orchestration Layer]
  O[GoT Orchestrator<br/>(handle_goal/3)]
  P[Planner<br/>(plans Goal → Task graph)]
  TG[TaskGraph<br/>(in-memory task DAG)]
  TE[TaskExecutor<br/>(runs tasks via runners)]
  PG[ProjectGraph Adapter<br/>(RDF/OWL I/O)]
end
class S1 layer;

%% RUNNERS
subgraph S2[JidoAi Runners (Reasoning Engines)]
  C[CoT Runner<br/>(local step-by-step code/logic)]
  T[ToT Runner<br/>(branch & evaluate plans/variants)]
  SA[Other Runners<br/>(Static analysis, tests, etc.)]
end
class S2 layer;
class C,T,SA runner;

%% KNOWLEDGE / STORAGE
subgraph S3[Knowledge Graph & Code Base]
  subgraph S3A[Project Graph Ontology]
    PGO[pg:Project, pg:Goal,<br/>pg:Task, pg:Thought,<br/>pg:AgentRun, pg:Artifact,<br/>pg:Decision, pg:ErrorReport...]
    SHACL[SHACL Shapes<br/>(ProjectShape, TaskShape,<br/>AgentRunShape, ArtifactShape...)]
  end
  class S3A storage;

  subgraph S3B[Elixir Code Ontology]
    ELX[Elixir ontology<br/>elixir:Module, elixir:Function,<br/>elixir:SourceFile, ...]
  end
  class S3B storage;

  KG[(RDF Store / Triple DB<br/>Project graph + Elixir graph)]
  REPO[(Git / Filesystem<br/>Actual source code)]
end
class S3 layer;
class PGO,ELX,SHACL,KG,REPO storage;

%% ALIGNMENT
PGO ---|aligns classes & props| ELX

%% HIGH-LEVEL FLOW
U -->|1. High-level goal| O
O -->|2. Create pg:Project / pg:Goal| PG
PG -->|Write individuals<br/>via RDF.ex/SPARQL| KG
KG -->|Context for planning| PG
PG --> P

%% PLANNING
P -->|3. Plan goal → tasks<br/>(ToT exploration)| T
T -->|Candidate plans + evaluations| P
P -->|4. Materialize Task graph<br/>(pg:Task, dependencies)| PG
PG --> KG
KG --> PG
PG -->|Build in-memory DAG| TG

%% EXECUTION
O -->|5. Run ready tasks| TE
TE -->|For each Task| TG

%% TASK → RUNNERS
TE -->|local code / small fix| C
TE -->|design / variants / refactor| T
TE -->|tests / static checks etc.| SA

%% RUN RESULTS → THOUGHTS / RUNS / ARTIFACTS
C -->|AgentRun + Thoughts + Artifacts| PG
T -->|AgentRun + Thoughts + Decisions| PG
SA -->|AgentRun + ErrorReports| PG

PG -->|Write pg:AgentRun,<br/>pg:Thought, pg:Artifact,<br/>pg:Outcome, status updates| KG

%% ARTIFACTS & CODE
TE -->|Modify code files| REPO
REPO -->|Code structure extractor<br/>(Elixir ontology builder)| ELX
ELX --> KG

%% FEEDBACK LOOPS
KG -->|Query for context<br/>(open tasks, past runs,<br/>related modules/functions)| PG
PG --> P
PG --> TE

%% USER FEEDBACK
O -->|Summaries of progress,<br/>decisions, errors, artifacts| U
```
