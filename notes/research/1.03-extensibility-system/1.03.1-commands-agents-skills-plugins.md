# JidoCode Extensibility System Design (Jido v2)

**A Phoenix channel-integrated plugin architecture mapping ClaudeCode patterns to Jido v2 primitives**

JidoCode can leverage Jido v2's powerful agentic primitives—Actions, Signals, Agents, and Skills—to create an extensibility system that mirrors ClaudeCode's architecture while adding real-time Phoenix channel integration for state broadcasting. This design enables markdown-based definitions compatible with ClaudeCode, native Elixir module hooks, and seamless pub/sub messaging throughout the agent lifecycle.

> **Jido v2 Architecture Note**: Jido v2 introduces a modular dependency structure (`jido_action`, `jido_signal`) and a pure-functional Agent API with explicit directives. See the API changes section below.

## Jido v2 primitives map naturally to extensibility concepts

The Jido v2 framework provides ideal building blocks for a plugin system. **Actions** (`jido_action` dep) serve as schema-validated, discrete units of work—perfect for slash commands and tool implementations. **Signals** (`jido_signal` dep) provide CloudEvents-compliant pub/sub for hooks and Phoenix channel integration. **Agents** are pure-functional data structures with a directive-based execution model. **Skills** compose multiple actions with routing logic.

| ClaudeCode Component | Jido v2 Primitive | Implementation Pattern |
|---------------------|-------------------|------------------------|
| Slash Commands | `Jido.Action` | Actions with Zoi schemas |
| Sub-agents | `Jido.Agent` + `Jido.AgentServer` | Pure-functional agents with directive execution |
| Skills | `Jido.Skill` | Bundles actions + signal routing + state |
| Hooks | `Jido.Signal.Bus` + dispatch adapters | Signal subscriptions triggering handlers |
| Plugins | Supervision tree + runtime registration | OTP-supervised plugin containers |

## Jido v2 Dependency Structure

```
jido/           # Core: Agent, Skill, AgentServer, Directive
jido_action/    # Action primitive with Zoi validation
jido_signal/    # Signal primitive with Bus (CloudEvents v1.0.2)
```

## Directory structure follows ClaudeCode conventions

The extensibility system uses a two-tier configuration approach with global and local settings that merge at runtime, with local settings taking precedence.

```
~/.jido_code/                          # Global configuration
├── settings.json                      # Global settings + hooks
├── JIDO.md                           # Global agent memory/instructions
├── commands/                          # Personal slash commands
│   └── *.md
├── agents/                            # Personal sub-agent definitions
│   └── *.md
├── skills/                            # Personal skills
│   └── skill-name/
│       ├── SKILL.md
│       └── scripts/
├── plugins/                           # Installed plugins
│   └── plugin-name/
│       └── .jido-plugin/
│           └── plugin.json
└── logs/

.jido_code/                            # Project-level configuration
├── settings.json                      # Project settings (overrides global)
├── JIDO.md                           # Project memory/instructions
├── commands/
│   └── *.md
├── agents/
│   └── *.md
├── skills/
│   └── skill-name/
│       └── SKILL.md
├── hooks/                             # Native Elixir hook modules
│   └── *.ex
└── plugins/
```

## JSON configuration schema with Phoenix channel directives

The settings.json schema extends ClaudeCode's format with Phoenix channel configuration and native Elixir hook support:

```json
{
  "$schema": "https://jidocode.dev/schemas/settings.json",
  "version": "2.0.0",

  "channels": {
    "default": {
      "socket": "ws://localhost:4000/socket",
      "topic": "jido:agent",
      "auth": {
        "type": "token",
        "token_env": "JIDO_CHANNEL_TOKEN"
      }
    },
    "ui_state": {
      "topic": "jido:ui",
      "broadcast_events": ["state_change", "progress", "error"]
    }
  },

  "permissions": {
    "allow": ["Bash(git:*)", "Read", "Write", "Edit"],
    "deny": ["Bash(rm -rf:*)"],
    "ask": ["Bash(npm:*)"]
  },

  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'Editing file' >> ~/.jido_code/logs/audit.log",
            "timeout": 5000
          },
          {
            "type": "channel",
            "channel": "ui_state",
            "event": "tool_starting",
            "payload_template": "{\"tool\": \"{{tool_name}}\", \"timestamp\": \"{{timestamp}}\"}"
          }
        ]
      },
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "elixir",
            "module": "MyApp.Hooks.AuditLogger",
            "function": "log_tool_use"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "signal",
            "signal_type": "jido/tool/completed",
            "bus": ":jido_code_bus"
          }
        ]
      }
    ],
    "AgentStateChange": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "channel",
            "channel": "ui_state",
            "event": "agent_state",
            "payload_template": "{\"agent_id\": \"{{agent_id}}\", \"state\": {{state_json}}}"
          }
        ]
      }
    ]
  },

  "agents": {
    "default_model": "claude-sonnet-4-20250514",
    "max_concurrent": 5
  },

  "plugins": {
    "enabled": ["git-tools", "code-analyzer"],
    "disabled": [],
    "marketplaces": {
      "community": {
        "source": "github",
        "repo": "jidocode/plugin-marketplace"
      }
    }
  }
}
```

### Hook type specifications

| Type | Fields | Description |
|------|--------|-------------|
| `command` | `command`, `timeout`, `env` | Shell command execution |
| `elixir` | `module`, `function`, `args` | Native Elixir callback |
| `channel` | `channel`, `event`, `payload_template` | Phoenix channel broadcast |
| `signal` | `signal_type`, `bus`, `data_template` | Jido Signal emission |
| `prompt` | `prompt`, `model` | LLM evaluation |

## Markdown format for sub-agents with channel directives

Sub-agents use YAML frontmatter compatible with ClaudeCode, extended with Jido v2-specific options. Note that Jido v2 uses **Zoi schemas** instead of NimbleOptions:

```yaml
---
name: code-reviewer
description: Expert code review specialist. Analyzes code quality, security vulnerabilities, and maintainability issues.
model: sonnet
tools: Read, Grep, Glob, Bash(git diff:*)

# Jido v2-specific extensions
jido:
  agent_module: JidoCode.Agents.CodeReviewer    # Optional: custom Elixir module
  schema:
    # Zoi schema format (v2)
    review_depth: Zoi.atom(values: [:quick, :standard, :thorough], default: :standard)
    focus_areas: Zoi.list(Zoi.string(), default: [:security, :performance])

  channels:
    broadcast_to: ui_state
    events:
      on_start: review_started
      on_finding: finding_detected
      on_complete: review_completed

  signals:
    emit:
      - type: "code/review/finding"        # Path format (v2)
        on: finding
      - type: "code/review/complete"
        on: complete
    subscribe:
      - path: "code/changed"               # Path-based subscription (v2)
        action: trigger_review
---

You are an expert code reviewer specializing in Elixir and functional programming patterns.

## Review Process
1. Read the target files using available tools
2. Analyze for code quality issues
3. Check security vulnerabilities
4. Evaluate performance implications
5. Suggest improvements with code examples

## Channel Broadcasting
When you discover findings, emit them for real-time UI updates:
@channel(finding_detected) { "severity": "{{severity}}", "file": "{{file}}", "line": {{line}}, "message": "{{message}}" }

## Output Format
Structure findings as:
- **Critical**: Security vulnerabilities, data exposure risks
- **Warning**: Performance issues, code smells
- **Info**: Style suggestions, minor improvements
```

### Channel directive syntax within markdown

The `@channel()` directive enables agents to broadcast messages directly from their prompts:

```markdown
@channel(event_name) { JSON payload with {{variable}} interpolation }
@channel(ui_state:progress) { "step": {{current_step}}, "total": {{total_steps}} }
```

This compiles to Jido Signal emissions that dispatch to configured Phoenix channels.

## Skill definitions mirror ClaudeCode with signal routing

Jido v2 Skills use the `mount/2` lifecycle callback and path-based routing:

```yaml
---
name: pdf-processor
description: Extract text, tables, and forms from PDF documents. Use when working with PDF files or document analysis tasks.
version: 1.2.0
allowed-tools: Read, Write, Bash(python:*)

jido:
  skill_module: JidoCode.Skills.PdfProcessor
  actions:
    - JidoCode.Actions.ExtractPdfText
    - JidoCode.Actions.ExtractPdfTables
    - JidoCode.Actions.FillPdfForm

  channels:
    broadcast_to: ui_state
    progress_events: true

  # Path-based router (v2)
  router:
    - "pdf/extract/text": ExtractPdfText
    - "pdf/extract/tables": ExtractPdfTables
    - "pdf/form/fill": FillPdfForm
---

# PDF Processing Skill

## Quick Start

Extract text from a PDF:
```python
import pdfplumber
with pdfplumber.open("document.pdf") as pdf:
    for page in pdf.pages:
        text = page.extract_text()
        print(text)
```

## Progress Reporting
@channel(progress) { "operation": "extracting", "page": {{current_page}}, "total": {{total_pages}} }

## Available Operations
- **Text Extraction**: Full-text extraction with layout preservation
- **Table Extraction**: Structured table data to CSV/JSON
- **Form Filling**: Populate PDF forms programmatically

See [TABLES.md](TABLES.md) for advanced table extraction options.
```

## Plugin manifest bundles all extensibility components

```json
{
  "$schema": "https://jidocode.dev/schemas/plugin.json",
  "name": "code-quality",
  "version": "2.1.0",
  "description": "Comprehensive code quality tools including review, linting, and security analysis",
  "author": {
    "name": "JidoCode Community",
    "email": "plugins@jidocode.dev"
  },
  "license": "MIT",
  "repository": "https://github.com/jidocode/plugin-code-quality",
  "keywords": ["code-review", "linting", "security"],

  "elixir": {
    "application": "JidoCodeQuality",
    "mix_deps": [
      {:jido, "~> 2.0"},
      {:jido_signal, "~> 1.2"},
      {:jido_action, "~> 1.0"},
      {:credo, "~> 1.7"},
      {:sobelow, "~> 0.13"}
    ]
  },

  "commands": "./commands",
  "agents": ["./agents"],
  "skills": "./skills",
  "hooks": "./config/hooks.json",

  "channels": {
    "required": ["ui_state"],
    "optional": ["notifications"]
  },

  "signals": {
    "emits": [
      "code/quality/issue",
      "code/review/complete",
      "security/vulnerability"
    ],
    "subscribes": [
      "file/saved",
      "git/commit"
    ]
  },

  "mcp_servers": {
    "credo-server": {
      "command": "elixir",
      "args": ["${JIDO_PLUGIN_ROOT}/servers/credo_server.exs"],
      "env": {
        "MIX_ENV": "prod"
      }
    }
  }
}
```

## Elixir code architecture using Jido v2 patterns

### Core plugin registry and loader

```elixir
defmodule JidoCode.Extensibility.PluginRegistry do
  @moduledoc """
  Central registry for all loaded plugins, commands, agents, skills, and hooks.
  Uses Jido's Signal bus for plugin lifecycle events.
  """
  use GenServer

  alias JidoSignal.Signal
  alias JidoSignal.Bus

  defstruct plugins: %{},
            commands: %{},
            agents: %{},
            skills: %{},
            hooks: %{},
            channels: %{}

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  def init(opts) do
    # Subscribe to plugin lifecycle signals (path-based in v2)
    Bus.subscribe(:jido_code_bus, "plugin/created",
      dispatch: {:pid, target: self()})

    state = %__MODULE__{
      channels: load_channel_config(opts[:settings_path])
    }

    # Load global and local plugins
    {:ok, load_all_plugins(state, opts)}
  end

  def register_plugin(plugin_manifest) do
    GenServer.call(__MODULE__, {:register_plugin, plugin_manifest})
  end

  def get_command(name), do: GenServer.call(__MODULE__, {:get_command, name})
  def get_agent(name), do: GenServer.call(__MODULE__, {:get_agent, name})
  def get_skill(name), do: GenServer.call(__MODULE__, {:get_skill, name})

  def handle_call({:register_plugin, manifest}, _from, state) do
    plugin = load_plugin_from_manifest(manifest)

    # Emit plugin loaded signal (CloudEvents v1.0.2 format)
    {:ok, signal} = Signal.new(
      "plugin/loaded",
      %{
        plugin_name: manifest.name,
        version: manifest.version,
        capabilities: extract_capabilities(plugin)
      },
      source: "/plugins/#{manifest.name}"
    )
    Bus.publish(:jido_code_bus, [signal])

    new_state = %{state |
      plugins: Map.put(state.plugins, manifest.name, plugin),
      commands: Map.merge(state.commands, plugin.commands),
      agents: Map.merge(state.agents, plugin.agents),
      skills: Map.merge(state.skills, plugin.skills),
      hooks: merge_hooks(state.hooks, plugin.hooks)
    }

    {:reply, {:ok, plugin}, new_state}
  end
end
```

### Action-based slash command implementation (Jido v2)

```elixir
defmodule JidoCode.Extensibility.Command do
  @moduledoc """
  Defines slash commands as Jido Actions with markdown-parsed configuration.

  Jido v2 uses Zoi schemas for validation.
  """

  defmacro __using__(opts) do
    quote do
      use Jido.Action,
        name: unquote(opts[:name]),
        description: unquote(opts[:description]),
        # Zoi schema in v2
        schema: unquote(opts[:schema] || Zoi.object(%{}))

      @command_config unquote(opts)

      def __command_config__, do: @command_config
    end
  end

  @doc """
  Parses a markdown command file into a Jido Action module at runtime.
  """
  def from_markdown(path) do
    {:ok, content} = File.read(path)
    {frontmatter, body} = parse_frontmatter(content)

    # Build Zoi schema from frontmatter (v2)
    schema = build_zoi_schema_from_frontmatter(frontmatter)

    module_name = module_name_from_path(path)

    Module.create(module_name, quote do
      use Jido.Action,
        name: unquote(frontmatter["name"] || Path.basename(path, ".md")),
        description: unquote(frontmatter["description"]),
        schema: unquote(schema)

      @allowed_tools unquote(parse_tools(frontmatter["allowed-tools"]))
      @model_override unquote(frontmatter["model"])
      @prompt_body unquote(body)
      @channel_config unquote(frontmatter["jido"]["channels"])

      @impl true
      def run(params, context) do
        prompt = interpolate_prompt(@prompt_body, params)

        # Broadcast command start to configured channel
        maybe_broadcast_channel(@channel_config, "command_started", %{
          command: __MODULE__,
          params: params
        })

        result = execute_with_tools(prompt, @allowed_tools, context)

        maybe_broadcast_channel(@channel_config, "command_completed", %{
          command: __MODULE__,
          result: result
        })

        result
      end
    end, Macro.Env.location(__ENV__))

    {:ok, module_name}
  end
end
```

### Signal-based hook system with channel dispatch (Jido v2)

```elixir
defmodule JidoCode.Extensibility.HookRunner do
  @moduledoc """
  Executes hooks based on lifecycle events, supporting shell commands,
  Elixir modules, Phoenix channels, and Jido signals.

  Jido v2 uses path-based signal routing.
  """

  alias JidoSignal.Signal
  alias JidoSignal.Bus
  alias JidoSignal.Dispatch

  @lifecycle_events [
    :pre_tool_use,
    :post_tool_use,
    :permission_request,
    :agent_state_change,
    :session_start,
    :session_stop,
    :subagent_start,
    :subagent_stop,
    :user_prompt_submit,
    :error
  ]

  def init(hook_config, channel_config) do
    # Subscribe to lifecycle signals (path-based in v2)
    Enum.each(@lifecycle_events, fn event ->
      path = "lifecycle/#{event}"  # Path format
      Bus.subscribe(:jido_code_bus, path,
        dispatch: {:pid, target: self()})
    end)

    %{
      hooks: normalize_hooks(hook_config),
      channels: channel_config,
      channel_connections: connect_channels(channel_config)
    }
  end

  def handle_info({:signal, signal}, state) do
    # Extract event type from signal path (v2)
    event_type = signal_path_to_event(signal.type)
    matching_hooks = find_matching_hooks(state.hooks, event_type, signal.data)

    # Run all matching hooks in parallel
    tasks = Enum.map(matching_hooks, fn hook ->
      Task.async(fn -> execute_hook(hook, signal, state) end)
    end)

    results = Task.await_many(tasks, :timer.seconds(60))

    # Process hook decisions (approve/deny/ask)
    decision = aggregate_decisions(results)

    {:noreply, state, decision}
  end

  defp execute_hook(%{type: "command"} = hook, signal, _state) do
    env = build_env_vars(signal)
    {output, exit_code} = System.cmd("sh", ["-c", hook.command], env: env)
    parse_hook_output(output, exit_code)
  end

  defp execute_hook(%{type: "elixir"} = hook, signal, _state) do
    module = String.to_existing_atom("Elixir.#{hook.module}")
    function = String.to_atom(hook.function)
    args = [signal.data | hook.args || []]

    apply(module, function, args)
  end

  defp execute_hook(%{type: "channel"} = hook, signal, state) do
    channel_name = hook.channel
    event = hook.event
    payload = interpolate_template(hook.payload_template, signal.data)

    case Map.get(state.channel_connections, channel_name) do
      nil -> {:error, :channel_not_connected}
      channel ->
        Phoenix.Channel.push(channel, event, payload)
        {:ok, :broadcast_sent}
    end
  end

  defp execute_hook(%{type: "signal"} = hook, signal, _state) do
    # Create signal with CloudEvents v1.0.2 compliance (v2)
    {:ok, new_signal} = Signal.new(
      hook.signal_type,
      Map.merge(signal.data, %{source_signal: signal.id}),
      source: "/hooks/#{hook.id}"
    )

    Bus.publish(String.to_atom(hook.bus), [new_signal])
    {:ok, :signal_emitted}
  end
end
```

### Sub-agent implementation as Jido v2 Agent

Jido v2 introduces a **pure-functional Agent API** with explicit **Directives**:

```elixir
defmodule JidoCode.Extensibility.SubAgent do
  @moduledoc """
  Sub-agents implemented as Jido v2 Agents with Phoenix channel state broadcasting.

  Jido v2 Key Concepts:
  - Agents are pure-functional data structures
  - Agent.cmd/2 returns {agent, directives}
  - Directives describe external effects
  - AgentServer manages runtime execution
  """

  defmacro __using__(opts) do
    quote do
      use Jido.Agent,
        name: unquote(opts[:name]),
        description: unquote(opts[:description]),
        actions: unquote(opts[:actions] || []),
        # Zoi schema in v2
        schema: unquote(opts[:schema] || Zoi.object(%{}))

      alias Jido.Agent.Directive
      alias JidoSignal.Signal
      alias JidoSignal.Bus

      @channel_config unquote(opts[:channels])
      @signal_config unquote(opts[:signals])
      @system_prompt unquote(opts[:system_prompt])

      def start_link(opts) do
        Jido.AgentServer.start_link(__MODULE__, opts)
      end

      # Convenience wrapper for cmd with channel broadcasting
      def cmd_with_broadcast(agent, action, opts \\ []) do
        {agent, directives} = Jido.Agent.cmd(agent, action)

        # Emit channel broadcast directive
        channel_directive = maybe_emit_channel_directive(
          @channel_config,
          action,
          agent
        )

        final_directives =
          if channel_directive, do: [channel_directive | directives],
          else: directives

        {agent, final_directives}
      end
    end
  end

  @doc """
  Parses a markdown sub-agent definition into a module.
  """
  def from_markdown(path) do
    {:ok, content} = File.read(path)
    {frontmatter, body} = parse_frontmatter(content)

    jido_config = frontmatter["jido"] || %{}

    module_name = module_name_from_path(path)

    Module.create(module_name, quote do
      use JidoCode.Extensibility.SubAgent,
        name: unquote(frontmatter["name"]),
        description: unquote(frontmatter["description"]),
        schema: unquote(build_zoi_schema(jido_config["schema"])),
        channels: unquote(jido_config["channels"]),
        signals: unquote(jido_config["signals"]),
        system_prompt: unquote(body)

      @tools unquote(parse_tools(frontmatter["tools"]))
      @model unquote(frontmatter["model"] || "sonnet")
    end, Macro.Env.location(__ENV__))

    {:ok, module_name}
  end
end
```

### Jido v2 Directive System

Jido v2 introduces explicit directives for external effects:

```elixir
# Built-in directives in Jido v2
%Directive.Emit{
  signal: signal,
  dispatch: {:pubsub, topic: "events"}  # or {:pid, target: pid}
}

%Directive.Spawn{
  child_spec: child_spec
}

%Directive.Schedule{
  delay: 5000,
  message: :timeout
}

%Directive.Stop{
  reason: :normal
}

%Directive.Error{
  error: error_struct
}
```

### Phoenix channel integration module

```elixir
defmodule JidoCode.Channels.AgentStateChannel do
  @moduledoc """
  Phoenix channel for real-time agent state broadcasting.
  Integrates with Jido Signal bus for event distribution.

  Jido v2 uses path-based signal routing.
  """

  use Phoenix.Channel

  alias JidoSignal.Bus

  def join("jido:agent:" <> agent_id, _params, socket) do
    # Subscribe to agent-specific signals (path-based in v2)
    Bus.subscribe(:jido_code_bus, "agent/#{agent_id}",
      dispatch: {:pid, target: self()})

    {:ok, assign(socket, :agent_id, agent_id)}
  end

  def join("jido:ui", _params, socket) do
    # Subscribe to all UI-relevant signals (path-based in v2)
    Bus.subscribe(:jido_code_bus, "ui",
      dispatch: {:pid, target: self()})

    {:ok, socket}
  end

  # Handle signals from Jido bus and broadcast to channel
  def handle_info({:signal, signal}, socket) do
    event_name = signal_type_to_event(signal.type)
    push(socket, event_name, signal.data)
    {:noreply, socket}
  end

  # Handle incoming channel events and convert to signals
  def handle_in("user_input", %{"content" => content}, socket) do
    {:ok, signal} = JidoSignal.Signal.new(
      "user/input",  # Path format (v2)
      %{
        content: content,
        agent_id: socket.assigns[:agent_id],
        channel: socket.topic
      },
      source: "/channels/#{socket.topic}"
    )

    Bus.publish(:jido_code_bus, [signal])

    {:noreply, socket}
  end

  defp signal_type_to_event(type) do
    type
    |> String.replace("/", "_")  # v2 uses / separator
    |> String.replace("jido_", "")
  end
end
```

### Skill implementation with action bundling (Jido v2)

```elixir
defmodule JidoCode.Extensibility.Skill do
  @moduledoc """
  Skills as Jido.Skill implementations with channel integration.

  Jido v2 Skill callbacks:
  - mount/2: Initialize skill state (pure function)
  - router/1: Return signal path -> action mappings
  - handle_signal/2: Intercept and handle signals
  - transform_result/3: Wrap action results
  """

  defmacro __using__(opts) do
    quote do
      use Jido.Skill,
        name: unquote(opts[:name]),
        state_key: unquote(opts[:state_key]),
        actions: unquote(opts[:actions] || [])

      @description unquote(opts[:description])
      @version unquote(opts[:version])
      @channel_config unquote(opts[:channels])
      @router_config unquote(opts[:router])

      @impl Jido.Skill
      def mount(agent, config) do
        # Initialize skill state (pure function in v2)
        {:ok, %{initialized_at: DateTime.utc_now()}}
      end

      @impl Jido.Skill
      def router(_config) do
        # Path-based routing (v2)
        Enum.map(@router_config, fn {path, action} ->
          {path, %Jido.Instruction{action: action}}
        end)
      end

      @impl Jido.Skill
      def handle_signal(signal, _skill_opts) do
        # Check if signal path matches our routes
        case find_matching_route(signal.type, @router_config) do
          nil -> {:skip, signal}
          action -> {:ok, %Jido.Instruction{action: action, params: signal.data}}
        end
      end

      @impl Jido.Skill
      def transform_result(result, _action, _skill_opts) do
        # Wrap result with channel broadcast if configured
        if @channel_config do
          {:ok, result, [emit_channel_directive(result, @channel_config)]}
        else
          {:ok, result, []}
        end
      end
    end
  end

  def from_markdown(path) do
    skill_dir = Path.dirname(path)
    {:ok, content} = File.read(path)
    {frontmatter, body} = parse_frontmatter(content)

    jido_config = frontmatter["jido"] || %{}

    module_name = module_name_from_path(path)

    # Load and compile action modules if specified
    actions = compile_skill_actions(jido_config["actions"], skill_dir)

    Module.create(module_name, quote do
      use JidoCode.Extensibility.Skill,
        name: unquote(frontmatter["name"]),
        description: unquote(frontmatter["description"]),
        version: unquote(frontmatter["version"]),
        state_key: :skill_state,
        actions: unquote(actions),
        channels: unquote(jido_config["channels"]),
        router: unquote(jido_config["router"])

      @allowed_tools unquote(parse_tools(frontmatter["allowed-tools"]))
      @skill_body unquote(body)

      def skill_documentation, do: @skill_body
    end, Macro.Env.location(__ENV__))

    {:ok, module_name}
  end
end
```

## TermUI integration for state representation

The extensibility system integrates with TermUI's Elm Architecture for real-time state display:

```elixir
defmodule JidoCode.UI.ExtensibilityPanel do
  @moduledoc """
  TermUI component for displaying plugin/agent state.
  Receives updates via Phoenix channel subscriptions.
  """

  alias TermUI.Renderer.Style

  defstruct agents: %{},
            active_hooks: [],
            loaded_plugins: [],
            channel_status: :disconnected

  def init(_opts) do
    %__MODULE__{}
  end

  def event_to_msg(%{type: :channel_event, event: "agent_state"} = event, _state) do
    {:msg, {:agent_state_update, event.payload}}
  end

  def event_to_msg(%{type: :channel_event, event: "hook_triggered"} = event, _state) do
    {:msg, {:hook_triggered, event.payload}}
  end

  def event_to_msg(_, _state), do: :ignore

  def update({:agent_state_update, payload}, state) do
    agent_id = payload["agent_id"]
    updated_agents = Map.put(state.agents, agent_id, %{
      status: payload["status"],
      last_update: payload["timestamp"],
      context: payload["context"]
    })

    {%{state | agents: updated_agents}, []}
  end

  def update({:hook_triggered, payload}, state) do
    hook_entry = %{
      name: payload["hook_name"],
      event: payload["event"],
      timestamp: DateTime.utc_now()
    }

    # Keep last 10 hooks
    hooks = [hook_entry | state.active_hooks] |> Enum.take(10)

    {%{state | active_hooks: hooks}, []}
  end

  def view(state) do
    import TermUI.Elements

    stack(:vertical, [
      panel("Agent Status", agent_status_view(state.agents)),
      panel("Recent Hooks", hooks_view(state.active_hooks)),
      panel("Loaded Plugins", plugins_view(state.loaded_plugins)),
      status_bar(state.channel_status)
    ])
  end

  defp agent_status_view(agents) do
    agents
    |> Enum.map(fn {id, agent} ->
      status_style = case agent.status do
        :idle -> Style.new(fg: :green)
        :executing -> Style.new(fg: :yellow, attrs: [:bold])
        :error -> Style.new(fg: :red)
      end

      row([
        text(truncate(id, 12), Style.new(fg: :cyan)),
        text(to_string(agent.status), status_style),
        text(format_time(agent.last_update), Style.new(fg: :white))
      ])
    end)
    |> stack(:vertical)
  end
end
```

## Application supervision tree

```elixir
defmodule JidoCode.Application do
  use Application

  def start(_type, _args) do
    children = [
      # Core Jido Signal bus for extensibility events
      {JidoSignal.Bus, [
        name: :jido_code_bus,
        middleware: [
          {JidoSignal.Bus.Middleware.Logger, level: :debug}
        ]
      ]},

      # Plugin registry - loads all plugins at startup
      {JidoCode.Extensibility.PluginRegistry, [
        global_path: Path.expand("~/.jido_code"),
        local_path: ".jido_code"
      ]},

      # Hook runner - handles all lifecycle hooks
      {JidoCode.Extensibility.HookRunner, [
        settings_path: ".jido_code/settings.json"
      ]},

      # Phoenix endpoint for channel connections
      JidoCode.Endpoint,

      # TermUI application
      {TermUI.Application, app: JidoCode.UI.App},

      # Dynamic supervisor for sub-agents (Jido v2 AgentServer)
      {DynamicSupervisor, name: JidoCode.AgentSupervisor, strategy: :one_for_one}
    ]

    opts = [strategy: :one_for_one, name: JidoCode.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

## Summary of key integration points

The extensibility system creates a cohesive architecture where **ClaudeCode compatibility** is maintained through markdown-based definitions with YAML frontmatter, enabling potential reuse of existing ClaudeCode skills and agents. The `jido:` frontmatter extension adds Elixir-native capabilities without breaking compatibility.

**Phoenix channels** integrate at three levels: hook definitions can include `type: "channel"` entries that broadcast on lifecycle events; sub-agents and skills can specify `channels.broadcast_to` for automatic state synchronization; and the `@channel()` directive in markdown prompts enables agents to emit real-time updates during execution.

**Jido v2 primitives** provide the foundation: Actions implement commands with Zoi schema validation, Signals (CloudEvents v1.0.2) flow through the bus connecting all components, Agents use a pure-functional `cmd/2` API with directive-based effects, and Skills compose actions with path-based routing. The Signal bus acts as the central nervous system, with Phoenix channel dispatch adapters bridging to the TermUI for real-time visualization.

This design enables **progressive adoption**—teams can start with simple markdown commands and gradually add channel broadcasting, native Elixir hooks, and full plugin bundles as needs grow.

## Key API Changes from Jido v1 to v2

| Aspect | Jido v1 | Jido v2 |
|--------|---------|---------|
| **Agent API** | GenServer.call(agent, action) | Pure `Agent.cmd(agent, action)` |
| **Execution Model** | Direct side effects | Explicit directives |
| **Signal Routing** | Pattern-based (`"plugin.**"`) | Path-based (`"plugin/loaded"`) |
| **Schema** | NimbleOptions | Zoi schemas |
| **Dependencies** | Monolithic `jido` | Modular (`jido`, `jido_action`, `jido_signal`) |
| **Signals** | Custom format | CloudEvents v1.0.2 compliant |
| **Skill mount** | Side effects | Pure function |
| **Directive types** | Implicit | 5 explicit directives (Emit, Spawn, Schedule, Stop, Error) |
