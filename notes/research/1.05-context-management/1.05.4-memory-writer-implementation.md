# Jido MemoryWriter & MemoryReader Skeleton (Elixir)
Version: 0.1.0  
Status: Design Skeleton / Reference Implementation

This document describes **skeleton Elixir modules** for:

- `Jido.MemoryWriter` – the **only** component allowed to write into project long‑term memory TTL files.
- `Jido.MemoryReader` – the **canonical read/query interface** over the ontology-backed project memory.

It also explains the **responsibilities, data flow, and extension points** for each module so future you (or future agents) can turn this into a full implementation.

The code is written as **annotated skeletons**: it is not meant to compile as‑is, but to serve as a strongly opinionated blueprint.

---

## 1. High-Level Architecture

```mermaid
flowchart LR
    subgraph Jido Agents
      A[Planner Agent] --> I1[MemoryUpdateIntent]
      B[Architect Agent] --> I1
      C[Debugger Agent] --> I1
    end

    I1 -->|submit_intent/2| MW[Jido.MemoryWriter]
    MW -->|append to| TTL[(project_memory.ttl)]
    MR[Jido.MemoryReader] -->|SPARQL queries| TTL

    Jido TUI --> MR
    CI[CI Pipeline] -->|SHACL + OWL| TTL
```

### Key ideas

- **Agents never edit TTL directly** – they emit structured `MemoryUpdateIntent` messages.
- `Jido.MemoryWriter`:
  - Validates intents against ontology rules.
  - Detects conflicts (decisions, conventions, facts, etc.).
  - Creates **new triples only**, plus supersession links.
- `Jido.MemoryReader`:
  - Provides a set of **high-level query functions** for agents.
  - Uses **SPARQL queries** defined in the SPARQL playbook.
  - Shields agents from low-level RDF handling details.

---

## 2. Shared Types & Data Structures

We define a **core struct** representing a proposed change to memory.

```elixir
defmodule Jido.MemoryUpdateIntent do
  @moduledoc """
  Represents a *proposed* long-term memory update emitted by an agent.

  This is the only format other agents use to change memory.

  The MemoryWriter is responsible for:
  - validating this intent,
  - expanding it into RDF triples,
  - writing it safely into the project TTL file.
  """

  @type memory_type ::
          :fact
          | :assumption
          | :hypothesis
          | :discovery
          | :risk
          | :decision
          | :architectural_decision
          | :implementation_decision
          | :convention
          | :task
          | :error
          | :lesson

  @type confidence :: :low | :medium | :high

  @type t :: %__MODULE__{
          type: memory_type(),
          iri: String.t() | nil,
          summary: String.t(),
          detailed_explanation: String.t() | nil,
          rationale: String.t() | nil,
          applies_to_project: String.t(),
          asserted_by: String.t(),
          asserted_in: String.t(),
          confidence: confidence(),
          evidence: [String.t()],
          supersedes: [String.t()],
          invalidates: [String.t()],
          extra_triples: list()
        }

  defstruct [
    :type,
    :iri,
    :summary,
    :detailed_explanation,
    :rationale,
    :applies_to_project,
    :asserted_by,
    :asserted_in,
    :confidence,
    evidence: [],
    supersedes: [],
    invalidates: [],
    extra_triples: []
  ]
end
```

### Design notes

- `:iri` – optional pre-chosen IRI; if `nil`, the MemoryWriter generates one.
- `:extra_triples` – escape hatch for future complex modeling (e.g., custom properties).
- `:supersedes` / `:invalidates` – allow agents to *propose* relationships, but the MemoryWriter enforces/adjusts as needed.

---

## 3. Jido.MemoryWriter Skeleton

### 3.1 Module Overview

```elixir
defmodule Jido.MemoryWriter do
  @moduledoc """
  Authoritative writer for ontology-based long-term memory.

  Responsibilities:

    * Accept well-formed MemoryUpdateIntents from agents.
    * Validate intents against Jido ontologies & CI rules.
    * Detect conflicts (decisions, conventions, facts, etc.).
    * Create new RDF triples and append them to the project TTL.
    * Maintain supersession / invalidation links.
    * NEVER delete; only append and relate.

  This module is the only code allowed to persist changes
  into project memory TTL files.
  """

  alias Jido.MemoryUpdateIntent

  @type project_id :: String.t()
  @type ttl_path :: String.t()
  @type iri :: String.t()

  @doc """
  Submit a memory update intent for a given project.

  This is the main entrypoint for other agents.
  """
  @spec submit_intent(project_id(), MemoryUpdateIntent.t()) ::
          {:ok, iri()} | {:error, term()}
  def submit_intent(project_id, %MemoryUpdateIntent{} = intent) do
    with {:ok, ctx} <- load_context(project_id),
         {:ok, normalized} <- normalize_intent(ctx, intent),
         :ok <- validate_intent(ctx, normalized),
         {:ok, conflict_info} <- detect_conflicts(ctx, normalized),
         {:ok, triples} <- build_triples(ctx, normalized, conflict_info),
         :ok <- append_triples(ctx, triples) do
      {:ok, normalized.iri}
    end
  end

  @doc """
  Re-load / refresh the in-memory view of project TTL if you cache it.
  """
  @spec refresh(project_id()) :: :ok | {:error, term()}
  def refresh(_project_id) do
    :ok
  end

  # --------------------------------------------------------------------------
  # Internal Pipeline Stages
  # --------------------------------------------------------------------------

  @type context :: %{
          project_id: project_id(),
          ttl_path: ttl_path(),
          graph: term() # RDF.Graph.t() or similar
        }

  @spec load_context(project_id()) :: {:ok, context()} | {:error, term()}
  defp load_context(project_id) do
    # 1. Resolve TTL path for project.
    # 2. Parse TTL into RDF.Graph (using RDF.ex or similar).
    # 3. Return a context struct used by subsequent steps.
    {:ok,
     %{
       project_id: project_id,
       ttl_path: "/path/to/#{project_id}_memory.ttl",
       graph: :not_loaded_yet
     }}
  end

  @spec normalize_intent(context(), MemoryUpdateIntent.t()) ::
          {:ok, MemoryUpdateIntent.t()} | {:error, term()}
  defp normalize_intent(_ctx, intent) do
    # e.g. generate IRI if nil, fill timestamps if missing (or require caller),
    # ensure strings are trimmed, etc.
    iri =
      intent.iri ||
        "https://jido.ai/memory/#{System.system_time(:millisecond)}"

    {:ok, %MemoryUpdateIntent{intent | iri: iri}}
  end

  @spec validate_intent(context(), MemoryUpdateIntent.t()) :: :ok | {:error, term()}
  defp validate_intent(_ctx, intent) do
    # Apply rules from jido-memorywriter-protocol.md and SHACL shapes:
    #
    # * Must have applies_to_project, asserted_by, asserted_in, confidence, summary.
    # * Additional per-type checks (e.g. decision needs rationale).
    #
    # You might want to return structured errors with codes.
    required =
      [
        intent.applies_to_project,
        intent.asserted_by,
        intent.asserted_in,
        intent.summary,
        intent.confidence
      ]

    if Enum.any?(required, &is_nil/1) do
      {:error, :missing_required_fields}
    else
      :ok
    end
  end

  @type conflict_info :: %{conflicts: list()}

  @spec detect_conflicts(context(), MemoryUpdateIntent.t()) ::
          {:ok, conflict_info()} | {:error, term()}
  defp detect_conflicts(_ctx, intent) do
    # Query the graph for potentially conflicting items.
    #
    # Examples:
    #   * Existing Decisions of same category w/o supersession.
    #   * Existing Conventions with same scope & incompatible text.
    #
    # Optionally, you can:
    #   * auto-suggest supersession
    #   * or require the caller to resubmit with explicit supersedes.
    {:ok, %{conflicts: []}}
  end

  @spec build_triples(context(), MemoryUpdateIntent.t(), conflict_info()) ::
          {:ok, list()} | {:error, term()}
  defp build_triples(_ctx, intent, _conflict_info) do
    # Construct RDF triples according to type.
    #
    # Pseudocode structure (not actual RDF.ex calls):
    #
    #   subject = intent.iri
    #   [
    #     {subject, rdf:type, class_for_type(intent.type)},
    #     {subject, jido:summary, intent.summary},
    #     {subject, jido:appliesToProject, intent.applies_to_project},
    #     ...
    #   ] ++ supersession_triples ++ custom_extra_triples
    #
    triples = [:placeholder_triples]
    {:ok, triples}
  end

  @spec append_triples(context(), list()) :: :ok | {:error, term()}
  defp append_triples(ctx, triples) do
    # 1. Merge triples into graph.
    # 2. Serialize back to TTL.
    # 3. Write atomically (temp file + rename).
    #
    # Optionally:
    #   * call out to a SHACL validator before final write.
    _ = {ctx, triples}
    :ok
  end

  # --------------------------------------------------------------------------
  # Helper: classify type -> class IRI (sketch)
  # --------------------------------------------------------------------------

  @spec class_for_type(MemoryUpdateIntent.memory_type()) :: String.t()
  defp class_for_type(:fact), do: "jido:Fact"
  defp class_for_type(:assumption), do: "jido:Assumption"
  defp class_for_type(:hypothesis), do: "jido:Hypothesis"
  defp class_for_type(:discovery), do: "jido:Discovery"
  defp class_for_type(:risk), do: "jido:Risk"
  defp class_for_type(:decision), do: "jido:Decision"
  defp class_for_type(:architectural_decision), do: "jido:ArchitecturalDecision"
  defp class_for_type(:implementation_decision), do: "jido:ImplementationDecision"
  defp class_for_type(:convention), do: "jido:Convention"
  defp class_for_type(:task), do: "jido:Task"
  defp class_for_type(:error), do: "jido:Error"
  defp class_for_type(:lesson), do: "jido:LessonLearned"
end
```

### 3.2 Implementation Notes

- You’ll likely want to split this module into:
  - `Jido.MemoryWriter.Normalize`
  - `Jido.MemoryWriter.Validate`
  - `Jido.MemoryWriter.Conflict`
  - `Jido.MemoryWriter.Serialize`
- The skeleton keeps everything in one place for **conceptual clarity**.
- All I/O (`append_triples/2`) should be **atomic** (write to temp, then `File.rename/2`).

---

## 4. Jido.MemoryReader Skeleton

The MemoryReader is the **canonical query interface** for agents. It:

- Wraps SPARQL queries defined in the playbook.
- Provides high-level, typed functions like `list_active_decisions/1`.
- Can be used in both:
  - TUI (for display)
  - Agents (for context gathering)

### 4.1 Module Overview

```elixir
defmodule Jido.MemoryReader do
  @moduledoc """
  Canonical read/query interface over project long-term memory.

  Responsibilities:

    * Execute SPARQL queries against the project memory graph.
    * Provide high-level, typed query functions per agent role.
    * Hide RDF/SPARQL plumbing details from agents.
  """

  @type project_id :: String.t()

  # --------------------------------------------------------------------------
  # Low-level generic query functions
  # --------------------------------------------------------------------------

  @doc """
  Execute an arbitrary SPARQL SELECT query against the project's memory graph.

  NOTE: this should only be used by internal higher-level helpers, not
  directly by agents, to keep queries consistent and reusable.
  """
  @spec select(project_id(), String.t()) :: {:ok, list(map())} | {:error, term()}
  def select(project_id, sparql) do
    # 1. Resolve TTL / triplestore for project.
    # 2. Run SPARQL query using SPARQL.ex or HTTP client.
    # 3. Normalize results into list of maps.
    _ = {project_id, sparql}
    {:ok, []}
  end

  # --------------------------------------------------------------------------
  # Architect Agent Queries
  # --------------------------------------------------------------------------

  @doc """
  List all active architectural decisions for a project.
  """
  @spec list_active_architectural_decisions(project_id()) ::
          {:ok, list(map())} | {:error, term()}
  def list_active_architectural_decisions(project_id) do
    sparql = """
    PREFIX jido: <https://jido.ai/ontology#>

    SELECT ?decision ?summary WHERE {
      ?decision a jido:ArchitecturalDecision ;
                jido:summary ?summary ;
                jido:appliesToProject ?project .
      FILTER NOT EXISTS { ?decision jido:supersededBy ?x }
    }
    """
    select(project_id, sparql)
  end

  @doc """
  List all project-wide conventions (any enforcement level).
  """
  @spec list_conventions(project_id()) :: {:ok, list(map())} | {:error, term()}
  def list_conventions(project_id) do
    sparql = """
    PREFIX jido: <https://jido.ai/ontology#>

    SELECT ?conv ?name ?level WHERE {
      ?conv a jido:Convention ;
            jido:conventionName ?name ;
            jido:hasEnforcementLevel ?level .
    }
    """
    select(project_id, sparql)
  end

  # --------------------------------------------------------------------------
  # Planner Agent Queries
  # --------------------------------------------------------------------------

  @doc """
  List all non-completed tasks for a project.
  """
  @spec list_open_tasks(project_id()) :: {:ok, list(map())} | {:error, term()}
  def list_open_tasks(project_id) do
    sparql = """
    PREFIX jido: <https://jido.ai/ontology#>

    SELECT ?task ?summary ?status WHERE {
      ?task a jido:Task ;
            jido:summary ?summary ;
            jido:hasTaskStatus ?status .
      FILTER (?status != jido:Completed)
    }
    """
    select(project_id, sparql)
  end

  # --------------------------------------------------------------------------
  # Debugger Agent Queries
  # --------------------------------------------------------------------------

  @doc """
  List all non-resolved errors and bugs for a project.
  """
  @spec list_open_errors(project_id()) :: {:ok, list(map())} | {:error, term()}
  def list_open_errors(project_id) do
    sparql = """
    PREFIX jido: <https://jido.ai/ontology#>

    SELECT ?err ?summary ?severity WHERE {
      ?err a jido:Error ;
           jido:summary ?summary ;
           jido:severityLevel ?severity ;
           jido:hasErrorStatus ?status .
      FILTER (?status != jido:Resolved)
    }
    """
    select(project_id, sparql)
  end

  # --------------------------------------------------------------------------
  # Memory Curator Queries
  # --------------------------------------------------------------------------

  @doc """
  List all facts and their confidence level for a project.
  """
  @spec list_facts_with_confidence(project_id()) ::
          {:ok, list(map())} | {:error, term()}
  def list_facts_with_confidence(project_id) do
    sparql = """
    PREFIX jido: <https://jido.ai/ontology#>

    SELECT ?fact ?summary ?confidence WHERE {
      ?fact a jido:Fact ;
            jido:summary ?summary ;
            jido:hasConfidence ?confidence .
    }
    """
    select(project_id, sparql)
  end

  # --------------------------------------------------------------------------
  # Session & Governance Queries
  # --------------------------------------------------------------------------

  @doc """
  List all active work sessions.
  """
  @spec list_active_sessions(project_id()) :: {:ok, list(map())} | {:error, term()}
  def list_active_sessions(project_id) do
    sparql = """
    PREFIX jido: <https://jido.ai/ontology#>

    SELECT ?session ?start WHERE {
      ?session a jido:WorkSession ;
               jido:hasStatus jido:Active ;
               jido:startedAt ?start .
    }
    """
    select(project_id, sparql)
  end
end
```

### 4.2 Usage Pattern

From an agent or from the TUI:

```elixir
# Architect agent wants to see current decisions:
{:ok, decisions} = Jido.MemoryReader.list_active_architectural_decisions("jido_code")

# Planner agent wants open tasks:
{:ok, open_tasks} = Jido.MemoryReader.list_open_tasks("jido_code")

# Debugger agent wants open errors:
{:ok, errors} = Jido.MemoryReader.list_open_errors("jido_code")
```

You can later add **role-specific helper modules** if you want more granular separation, e.g.:

- `Jido.MemoryReader.Architect`
- `Jido.MemoryReader.Planner`
- `Jido.MemoryReader.Debugger`
- `Jido.MemoryReader.Curator`

Each would be a thin wrapper over `Jido.MemoryReader.select/2`.

---

## 5. Where This Fits in JidoCode

### 5.1 In the TUI

- The TUI can expose commands like:
  - `:memory decisions`
  - `:memory tasks`
  - `:memory errors`
- Each of these calls into `Jido.MemoryReader` and renders friendly tables.

### 5.2 In the Agent Orchestrator

- Planner agent:
  - Before planning, calls `list_open_tasks/1` and `list_conventions/1`.
- Architect agent:
  - Before proposing new architecture, calls `list_active_architectural_decisions/1`.
- Debugger agent:
  - Before starting a debugging session, calls `list_open_errors/1` and recent `LessonLearned` items.

### 5.3 In CI

- A CI task can:
  - Run SHACL on the TTL.
  - Use `Jido.MemoryReader` to:
    - Ensure no open tasks are marked as completed in GitHub.
    - Ensure all decisions have rationale (backed by SHACL and queries).

---

## 6. Next Implementation Steps

To turn these skeletons into working code, you will need to:

1. **Pick / integrate RDF tooling** in Elixir, e.g. `RDF.ex` and `SPARQL.ex`.
2. Implement the real logic of:
   - `load_context/1`
   - `build_triples/3`
   - `append_triples/2`
   - `select/2`
3. Hook SHACL validation (via external tool or Elixir wrapper) into `append_triples/2`.
4. Wire these modules into:
   - Your **Jido agent orchestration** layer.
   - The **TUI command handlers**.
   - The **CI pipeline** for project repositories.

At that point, your JidoCode system will have a **fully ontology-backed, deterministic, and auditable long-term memory subsystem** that both humans and agents can reason about in a principled way.

