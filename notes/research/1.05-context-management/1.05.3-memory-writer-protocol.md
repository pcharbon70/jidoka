# Jido MemoryWriter Agent Protocol (v1.0)

This document defines the **authoritative protocol** for how long-term
memory is written, validated, and evolved inside the JidoCode
ontology-based memory system.

This protocol is **mandatory** for all agents. No agent may write
directly to a project TTL file.

------------------------------------------------------------------------

## 1. Purpose

The MemoryWriter Agent exists to:

-   Enforce **semantic correctness**
-   Guarantee **non-destructive history**
-   Maintain **deterministic project state**
-   Prevent **contradictory long-term knowledge**
-   Provide **auditability and CI validation**

------------------------------------------------------------------------

## 2. Authority Model

Only the following role may write memory:

-   `jido:MemoryWriter`

All other agents must submit **Memory Update Intents**.

------------------------------------------------------------------------

## 3. Memory Update Pipeline

### Step 1 --- Intent Submission

Agents emit a message of the form:

    %MemoryUpdateIntent{
      type: :decision | :fact | :convention | :task | :error | :lesson,
      summary: "...",
      detailed_explanation: "...",
      applies_to_project: ProjectIRI,
      asserted_by: AgentIRI,
      asserted_in: SessionIRI,
      confidence: :low | :medium | :high,
      evidence: [EvidenceIRI],
      supersedes: [MemoryItemIRI]
    }

------------------------------------------------------------------------

### Step 2 --- Ontology Validation

The MemoryWriter MUST:

-   Validate class compatibility
-   Validate property-domain/range correctness
-   Reject undefined IRIs
-   Reject missing required provenance

------------------------------------------------------------------------

### Step 3 --- Conflict Detection

A conflict exists if:

-   Two active `Decision` items apply to the same project scope without
    `supersededBy`
-   Two `Convention` items enforce incompatible rules at the same scope
-   A `Fact` contradicts an existing `Fact` without explicit
    invalidation

Conflict resolution requires:

-   Explicit `jido:supersededBy` OR
-   Explicit `jido:invalidatedBy`

------------------------------------------------------------------------

### Step 4 --- Supersession Rules

If superseding:

-   The new item MUST reference the old item:
    -   `jido:supersededBy`

The older item remains valid *historically* but becomes inactive.

------------------------------------------------------------------------

### Step 5 --- Serialization

The MemoryWriter writes a new TTL block using:

-   Fresh IRI
-   Immutable timestamp
-   Full provenance linkage

No existing blocks are modified except for adding:

    jido:OldItem jido:supersededBy jido:NewItem .

------------------------------------------------------------------------

## 4. Deletion Rules

Hard deletion is **forbidden**.

Only allowed states:

-   Active
-   Superseded
-   Invalidated

------------------------------------------------------------------------

## 5. Mandatory Properties Per Memory Item

Every MemoryItem MUST contain:

-   `jido:appliesToProject`
-   `jido:assertedBy`
-   `jido:assertedIn`
-   `jido:hasConfidence`
-   `jido:hasTimestamp`
-   `jido:summary`

------------------------------------------------------------------------

## 6. Memory Consistency Invariants

  Invariant   Description
  ----------- ----------------------------------------------------
  I1          All MemoryItems must belong to exactly one project
  I2          No two active Decisions may contradict
  I3          No two active Conventions may conflict
  I4          Superseded items may never be reactivated
  I5          All Errors must optionally produce Lessons
  I6          All RootCauses must explain at least one Error

------------------------------------------------------------------------

## 7. CI Validation Integration

On every commit:

1.  TTL syntax check
2.  OWL consistency reasoning
3.  SHACL invariant validation
4.  No orphan IRIs
5.  No dangling supersession references

Failure blocks merge.

------------------------------------------------------------------------

## 8. Emergency Recovery Mode

If memory corruption occurs:

-   Immutable snapshot rollback allowed
-   New RecoverySession must be created
-   All corrections must be linked via `invalidatedBy`

------------------------------------------------------------------------

## 9. Design Guarantee

This protocol guarantees:

-   Full auditability
-   Causal traceability
-   Non-destructive knowledge evolution
-   Deterministic agent reasoning
-   CI-enforced epistemic correctness

