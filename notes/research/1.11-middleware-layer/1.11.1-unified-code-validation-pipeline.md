# Unified Code Validation Pipeline for JidoCode

## Comprehensive Middleware Architecture for LLM Code Quality Enforcement

This document synthesizes the three existing JidoCode research efforts into a unified validation pipeline:

1. **Credo Rules Prevention** (1.08) - ~40 style and consistency rules
2. **Anti-Pattern Prevention** (1.09) - 35 documented code smells
3. **Security Prevention** (1.10) - ~30 vulnerability types with 15+ insecure function patterns

The pipeline operates as a **Skill-based middleware layer** in JidoCode's LLMAgent workflow, combining **pre-generation constraint injection** with **post-generation validation** and **intelligent retry logic**.

---

## 1. Complete Rule Inventory

### 1.1 Security Vulnerabilities (30 Rules)

The security domain covers ERLEF Security Working Group recommendations and OWASP categories:

| Category | Vulnerability | ERLEF ID | Severity | Detection Method |
|----------|--------------|----------|----------|------------------|
| **Injection** | SQL Injection | WEB-004, WEB-005 | CRITICAL | AST + Semantic |
| **Injection** | Command Injection | BEAM-010, BEAM-011 | CRITICAL | AST Pattern |
| **Injection** | Code Injection (eval) | BEAM-008, BEAM-009 | CRITICAL | AST Pattern |
| **Injection** | XSS via raw() | WEB-001, WEB-002, WEB-003 | CRITICAL | AST Pattern |
| **Deserialization** | Atom Exhaustion | BEAM-001 to BEAM-005 | HIGH | AST Pattern |
| **Deserialization** | Unsafe binary_to_term | BEAM-006, BEAM-007 | CRITICAL | AST Pattern |
| **Deserialization** | XXE Vulnerability | BEAM-018 | HIGH | AST Pattern |
| **Authentication** | Session Vulnerability | WEB-010 to WEB-013 | HIGH | Config/Semantic |
| **Authentication** | CSRF Missing | WEB-006, WEB-007 | HIGH | Config |
| **Authentication** | WebSocket Hijacking | WEB-008 | HIGH | Config/Semantic |
| **Authorization** | Missing Auth Check | WEB-009, WEB-020 | CRITICAL | Semantic/SPARQL |
| **Authorization** | Mass Assignment | WEB-017 | HIGH | Semantic |
| **Cryptographic** | Timing Attack | BEAM-015 | MEDIUM | Semantic |
| **Cryptographic** | TLS Misconfiguration | BEAM-016, BEAM-017 | CRITICAL | Config |
| **Info Disclosure** | Secret in Stacktrace | BEAM-012 | HIGH | Semantic |
| **Info Disclosure** | Secret in Introspection | BEAM-013 | HIGH | Semantic/SPARQL |
| **Info Disclosure** | Missing @derive Inspect | BEAM-014 | HIGH | Semantic/SPARQL |
| **Info Disclosure** | Sensitive Data in Logs | WEB-016 | HIGH | Config |
| **Configuration** | Distribution Exposed | BEAM-019, BEAM-020 | CRITICAL | Config |
| **Configuration** | Missing Security Headers | WEB-014, WEB-015 | MEDIUM | Config |
| **Configuration** | Missing Rate Limiting | WEB-021 | MEDIUM | Semantic |

#### Insecure Function Pattern Registry (15 Patterns)

```elixir
@security_patterns [
  # Atom Exhaustion (BEAM-001)
  {"String", "to_atom", 1, "BEAM-001", :high, "String.to_existing_atom/1 or lookup map"},
  {"List", "to_atom", 1, "BEAM-001", :high, "List.to_existing_atom/1"},
  {"Module", "concat", 1, "BEAM-001", :high, "Module.safe_concat/1 with allowlist"},
  {"Module", "concat", 2, "BEAM-001", :high, "Module.safe_concat/2 with allowlist"},
  {"erlang", "binary_to_atom", 1, "BEAM-001", :high, "binary_to_existing_atom/2"},
  {"erlang", "binary_to_atom", 2, "BEAM-001", :high, "binary_to_existing_atom/2"},
  {"erlang", "list_to_atom", 1, "BEAM-001", :high, "list_to_existing_atom/1"},
  
  # Code Injection (BEAM-008, BEAM-009)
  {"Code", "eval_string", 1, "BEAM-008", :critical, "Embedded sandbox (Lua via luerl)"},
  {"Code", "eval_string", 2, "BEAM-008", :critical, "Embedded sandbox"},
  {"Code", "eval_string", 3, "BEAM-008", :critical, "Embedded sandbox"},
  {"Code", "eval_file", 1, "BEAM-008", :critical, "Avoid on untrusted input"},
  {"Code", "eval_file", 2, "BEAM-008", :critical, "Avoid on untrusted input"},
  {"Code", "eval_quoted", 2, "BEAM-008", :critical, "Avoid on untrusted input"},
  {"file", "script", 1, "BEAM-009", :critical, "Avoid on untrusted input"},
  {"file", "eval", 1, "BEAM-009", :critical, "Avoid on untrusted input"},
  
  # Command Injection (BEAM-010)
  {"os", "cmd", 1, "BEAM-010", :critical, "System.cmd/3 with args as list"},
  {"os", "cmd", 2, "BEAM-010", :critical, "System.cmd/3 with args as list"},
  {"System", "shell", 1, "BEAM-010", :high, "System.cmd/3 with args as list"},
  {"System", "shell", 2, "BEAM-010", :high, "System.cmd/3 with args as list"},
  
  # Unsafe Deserialization (BEAM-006)
  {"erlang", "binary_to_term", 1, "BEAM-006", :critical, "binary_to_term(data, [:safe])"},
  
  # XSS (WEB-001)
  {"Phoenix.HTML", "raw", 1, "WEB-001", :critical, "Default template escaping"},
  {"Phoenix.HTML.Raw", "raw", 1, "WEB-001", :critical, "Default template escaping"}
]
```

### 1.2 Anti-Patterns / Code Smells (35 Rules)

#### Design-Related Smells (14)

| Smell | Description | Detection | Severity |
|-------|-------------|-----------|----------|
| GenServer Envy | Using Task/Agent beyond intended purpose | Semantic/SPARQL | Medium |
| Agent Obsession | Agent access scattered across modules | SPARQL | High |
| Unsupervised Process | Long-running processes outside supervision | SPARQL | High |
| Large Messages | Processes exchanging huge structures | Runtime only | Low |
| Unrelated Multi-Clause Function | Too many unrelated patterns | AST/Credo | Medium |
| Complex Extractions in Clauses | Pattern-matching overload | AST/Credo | Medium |
| Using Exceptions for Control-Flow | Exceptions vs tuples | AST/Prompt | Medium |
| Untested Polymorphic Behaviors | Protocol implementations without guards | Semantic | Low |
| Code Organization by Process | Unnecessary GenServer for pure computation | SPARQL | Medium |
| Large Code Generation by Macros | Macro expansions creating excessive code | AST | Medium |
| Data Manipulation by Migration | Mixing schema changes with data transforms | AST | Medium |
| Using App Configuration for Libraries | Application.get_env in library code | AST/Credo | High |
| Compile-time Global Configuration | Module attributes evaluating config | AST/Credo | High |
| "Use" Instead of "Import" | Overusing `use` when `import` suffices | AST/Prompt | Low |

#### Low-Level Concern Smells (9)

| Smell | Description | Detection | Severity |
|-------|-------------|-----------|----------|
| Working with Invalid Data | Missing boundary validation | Semantic | Medium |
| Complex Branching | Deep conditional nesting | AST/Credo | Medium |
| Complex else Clauses in with | Flattening all errors into single else | AST/Prompt | Medium |
| Alternative Return Types | Parameters that change return type | Semantic | Low |
| Accessing Non-Existent Map/Struct Fields | Dynamic access returning nil | AST | Medium |
| Speculative Assumptions | Returning defaults when crash appropriate | Semantic | Low |
| Modules with Identical Names | Duplicate module definitions | AST/Credo | High |
| Unnecessary Macros | Macros where functions suffice | AST/Prompt | Medium |
| Dynamic Atom Creation | String.to_atom(user_input) | AST | Critical |

#### Traditional Smells Adapted for Elixir (12)

| Smell | Detection | Credo Check |
|-------|-----------|-------------|
| Long Parameter List | AST/Credo | FunctionArity |
| Long Function | AST/Credo | CyclomaticComplexity |
| Large Module | Semantic/SPARQL | Custom |
| Duplicated Code | AST/Credo | DuplicatedCode (disabled by default) |
| Primitive Obsession | Semantic | Custom |
| Feature Envy | SPARQL | Custom |
| Shotgun Surgery | SPARQL | Custom |
| Divergent Change | SPARQL | Custom |
| Inappropriate Intimacy | SPARQL | Custom |
| Speculative Generality | Semantic | Custom |
| Switch Statements | AST/Prompt | Custom |
| Comments as Code | AST/Credo | TagTODO, TagFIXME |

### 1.3 Credo Style Rules (~40 Rules)

#### Naming Conventions
- `FunctionNames` - snake_case for functions
- `ModuleNames` - PascalCase for modules
- `VariableNames` - snake_case for variables
- `PredicateFunctionNames` - valid? for predicates
- `ExceptionNames` - consistent suffix (Error)

#### Documentation
- `ModuleDoc` - @moduledoc required for public modules
- `Specs` - @spec for public functions

#### Complexity Metrics
- `CyclomaticComplexity` - max 9 per function
- `Nesting` - max 2 levels
- `FunctionArity` - max 8 parameters
- `ABCSize` - max 30 (Assignments+Branches+Conditions)
- `LongQuoteBlocks` - avoid excessive quote blocks

#### Code Quality
- `PipeChainStart` - pipes start with values, not function calls
- `SinglePipe` - avoid single-element pipe chains
- `NegatedConditionsWithElse` - don't use `if !x do...else...end`
- `NegatedConditionsInUnless` - don't use `unless !x`
- `UnlessWithElse` - don't use unless with else
- `CondStatements` - cond needs 3+ branches

#### Warnings (Production Blockers)
- `IoInspect` - no IO.inspect in production
- `IExPry` - no IEx.pry
- `Dbg` - no dbg() calls
- `LazyLogging` - use Logger with lazy evaluation
- `RaiseInsideRescue` - proper error handling
- `ApplicationConfigInModuleAttribute` - no compile-time config

#### Unused Code
- `UnusedEnumOperation` - use return values
- `UnusedStringOperation` - use return values
- `UnusedMapOperation` - use return values
- `UnusedListOperation` - use return values

---

## 2. Unified Severity Model

All three domains map to a common severity scale with numeric weights for scoring:

```elixir
@severity_config %{
  critical: %{weight: 100, blocking: true, color: :red},
  high:     %{weight: 50,  blocking: true, color: :orange},
  medium:   %{weight: 20,  blocking: false, color: :yellow},
  low:      %{weight: 5,   blocking: false, color: :blue},
  info:     %{weight: 1,   blocking: false, color: :gray}
}

@domain_multipliers %{
  security: 2.0,      # Security issues weighted highest
  anti_pattern: 1.2,  # Anti-patterns moderately weighted
  credo: 1.0          # Credo rules baseline
}
```

### Severity Mapping by Domain

| Domain | Critical | High | Medium | Low |
|--------|----------|------|--------|-----|
| **Security** | Injection, RCE, binary_to_term | Atom exhaustion, session, CSRF | Timing attacks, headers | Info |
| **Anti-Pattern** | Dynamic atom creation | Unsupervised process, Agent obsession | GenServer envy, complexity | Style preferences |
| **Credo** | Unused dangerous code | IoInspect, IExPry, AppConfig | Complexity, nesting | Naming, formatting |

---

## 3. Pipeline Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           JIDOCODE UNIFIED VALIDATION PIPELINE                       │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │ STAGE 1: PRE-GENERATION CONTEXT INJECTION                                      │ │
│  │                                                                                 │ │
│  │  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────────────────┐  │ │
│  │  │ Request         │   │ SPARQL Context  │   │ Prompt Enrichment           │  │ │
│  │  │ Analysis        │──▶│ Queries         │──▶│                             │  │ │
│  │  │                 │   │                 │   │ • Security guide (~800w)    │  │ │
│  │  │ Detect:         │   │ • Existing      │   │ • Credo guide (~600w)       │  │ │
│  │  │ • Code type     │   │   patterns      │   │ • Anti-pattern guide        │  │ │
│  │  │ • Context       │   │ • Supervision   │   │ • Context-triggered warns   │  │ │
│  │  │ • Keywords      │   │   trees         │   │ • Few-shot examples         │  │ │
│  │  └─────────────────┘   │ • Dependencies  │   │ • Negative examples         │  │ │
│  │                        └─────────────────┘   └─────────────────────────────┘  │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                         │                                           │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │ STAGE 2: LLM CODE GENERATION                                                   │ │
│  │                                                                                 │ │
│  │  [LLM Agent] ← Enriched prompt with all domain constraints                     │ │
│  │       │                                                                         │ │
│  │       ▼                                                                         │ │
│  │  Generated Elixir Code                                                          │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                         │                                           │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │ STAGE 3: PARALLEL POST-GENERATION VALIDATION                                   │ │
│  │                                                                                 │ │
│  │  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐              │ │
│  │  │ SECURITY         │  │ ANTI-PATTERN     │  │ CREDO            │              │ │
│  │  │ VALIDATOR        │  │ DETECTOR         │  │ VALIDATOR        │              │ │
│  │  ├──────────────────┤  ├──────────────────┤  ├──────────────────┤              │ │
│  │  │ • AST Pattern    │  │ • SPARQL Queries │  │ • mix credo      │              │ │
│  │  │   Matching (15)  │  │   (6 semantic)   │  │   --format json  │              │ │
│  │  │ • SPARQL Queries │  │ • AST Checks     │  │ • Quick checks   │              │ │
│  │  │   (semantic)     │  │   (15 patterns)  │  │   (pipe, docs)   │              │ │
│  │  │ • Sobelow        │  │ • SHACL Shapes   │  │ • Cached results │              │ │
│  │  │   Integration    │  │                  │  │                  │              │ │
│  │  └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘              │ │
│  │           │                     │                     │                        │ │
│  │           └─────────────────────┼─────────────────────┘                        │ │
│  │                                 ▼                                              │ │
│  │                    ┌──────────────────────────┐                                │ │
│  │                    │ VIOLATION AGGREGATOR     │                                │ │
│  │                    │ • Unified format         │                                │ │
│  │                    │ • Severity mapping       │                                │ │
│  │                    │ • Deduplication          │                                │ │
│  │                    │ • Score calculation      │                                │ │
│  │                    └──────────────────────────┘                                │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                         │                                           │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │ STAGE 4: DECISION & RETRY LOGIC                                                │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────┐  │ │
│  │  │                                                                          │  │ │
│  │  │  Score = 0 ───────────────────────────────────────▶ Return code          │  │ │
│  │  │                                                                          │  │ │
│  │  │  Score > 0 AND blocking = 0 AND score < threshold ─▶ Return with report  │  │ │
│  │  │                                                                          │  │ │
│  │  │  Score > 0 AND attempts < max ─────────────────────▶ Retry with feedback │  │ │
│  │  │                                                                          │  │ │
│  │  │  Score > 0 AND attempts >= max ────────────────────▶ Return best attempt │  │ │
│  │  │                                                                          │  │ │
│  │  └─────────────────────────────────────────────────────────────────────────┘  │ │
│  │                                                                                 │ │
│  │  Attempt Tracker: Stores all attempts, selects best by:                        │ │
│  │  1. Fewest blocking violations                                                 │ │
│  │  2. Lowest weighted score                                                      │ │
│  │  3. Fewest total violations                                                    │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. Ontology Integration

The pipeline leverages four existing ontology sets:

### 4.1 Base Ontologies (from elixir-ontologies repo)

```turtle
@prefix core: <https://w3id.org/elixir-code/core#> .      # AST elements
@prefix struct: <https://w3id.org/elixir-code/structure#> . # Modules, functions
@prefix otp: <https://w3id.org/elixir-code/otp#> .        # GenServer, Supervisor
@prefix evo: <https://w3id.org/elixir-code/evolution#> .  # Provenance, versioning
```

### 4.2 Security Ontology (from security research)

```turtle
@prefix sec: <https://w3id.org/elixir-code/security#> .

# Vulnerability hierarchy
sec:SecurityVulnerability rdfs:subClassOf core:CodeElement .
sec:InjectionVulnerability rdfs:subClassOf sec:SecurityVulnerability .
sec:SQLInjection rdfs:subClassOf sec:InjectionVulnerability .
sec:CommandInjection rdfs:subClassOf sec:InjectionVulnerability .
sec:CodeInjection rdfs:subClassOf sec:InjectionVulnerability .
sec:XSSVulnerability rdfs:subClassOf sec:InjectionVulnerability .

sec:DeserializationVulnerability rdfs:subClassOf sec:SecurityVulnerability .
sec:AtomExhaustion rdfs:subClassOf sec:DeserializationVulnerability .
sec:UnsafeBinaryToTerm rdfs:subClassOf sec:DeserializationVulnerability .
sec:XXEVulnerability rdfs:subClassOf sec:DeserializationVulnerability .

sec:AuthenticationVulnerability rdfs:subClassOf sec:SecurityVulnerability .
sec:SessionVulnerability rdfs:subClassOf sec:AuthenticationVulnerability .
sec:CSRFVulnerability rdfs:subClassOf sec:AuthenticationVulnerability .
sec:WebSocketHijacking rdfs:subClassOf sec:AuthenticationVulnerability .

sec:AuthorizationVulnerability rdfs:subClassOf sec:SecurityVulnerability .
sec:MissingAuthorizationCheck rdfs:subClassOf sec:AuthorizationVulnerability .
sec:MassAssignment rdfs:subClassOf sec:AuthorizationVulnerability .

sec:CryptographicVulnerability rdfs:subClassOf sec:SecurityVulnerability .
sec:TimingAttack rdfs:subClassOf sec:CryptographicVulnerability .
sec:TLSMisconfiguration rdfs:subClassOf sec:CryptographicVulnerability .

sec:InformationDisclosure rdfs:subClassOf sec:SecurityVulnerability .
sec:SecretInStacktrace rdfs:subClassOf sec:InformationDisclosure .
sec:SecretInIntrospection rdfs:subClassOf sec:InformationDisclosure .
sec:MissingDeriveInspect rdfs:subClassOf sec:InformationDisclosure .
sec:SensitiveDataInLogs rdfs:subClassOf sec:InformationDisclosure .

sec:ConfigurationVulnerability rdfs:subClassOf sec:SecurityVulnerability .
sec:DistributionExposed rdfs:subClassOf sec:ConfigurationVulnerability .
sec:MissingSecurityHeaders rdfs:subClassOf sec:ConfigurationVulnerability .
sec:MissingRateLimiting rdfs:subClassOf sec:ConfigurationVulnerability .

# Insecure Function Pattern class
sec:InsecureFunctionPattern a owl:Class .
```

### 4.3 Code Smell Ontology (from anti-pattern research)

```turtle
@prefix smell: <https://w3id.org/elixir-code/smells#> .

# Smell hierarchy
smell:CodeSmell a owl:Class .
smell:DesignSmell rdfs:subClassOf smell:CodeSmell .
smell:ProcessSmell rdfs:subClassOf smell:CodeSmell .
smell:LowLevelSmell rdfs:subClassOf smell:CodeSmell .

# Specific smells
smell:UnsupervisedProcessSmell rdfs:subClassOf smell:ProcessSmell .
smell:AgentObsessionSmell rdfs:subClassOf smell:ProcessSmell .
smell:CodeOrganizationByProcessSmell rdfs:subClassOf smell:ProcessSmell .
smell:GenServerEnvySmell rdfs:subClassOf smell:ProcessSmell .

smell:CircularDependencySmell rdfs:subClassOf smell:DesignSmell .
smell:GodModuleSmell rdfs:subClassOf smell:DesignSmell .
smell:FeatureEnvySmell rdfs:subClassOf smell:DesignSmell .

smell:DynamicAtomCreationSmell rdfs:subClassOf smell:LowLevelSmell .
smell:ComplexBranchingSmell rdfs:subClassOf smell:LowLevelSmell .
```

### 4.4 Unified Validation Ontology (new)

```turtle
@prefix val: <https://w3id.org/elixir-code/validation#> .

# Abstract validation rule (superclass for all domains)
val:ValidationRule a owl:Class .

# Domain mappings
sec:SecurityVulnerability rdfs:subClassOf val:ValidationRule .
smell:CodeSmell rdfs:subClassOf val:ValidationRule .
val:CredoRule rdfs:subClassOf val:ValidationRule .

# Unified severity
val:Severity a owl:Class .
val:Critical a val:Severity ; val:weight 100 ; val:blocking true .
val:High a val:Severity ; val:weight 50 ; val:blocking true .
val:Medium a val:Severity ; val:weight 20 ; val:blocking false .
val:Low a val:Severity ; val:weight 5 ; val:blocking false .
val:Info a val:Severity ; val:weight 1 ; val:blocking false .

# Common properties
val:hasSeverity a owl:ObjectProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range val:Severity .

val:hasRemediation a owl:DatatypeProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range xsd:string .

val:hasNegativeExample a owl:DatatypeProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range xsd:string .

val:hasPositiveExample a owl:DatatypeProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range xsd:string .
```

---

## 5. SPARQL Query Patterns

### 5.1 Security Domain Queries

```sparql
# Q1: Detect all insecure function patterns
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX sec: <https://w3id.org/elixir-code/security#>

SELECT ?call ?moduleName ?funcName ?arity ?filePath ?line ?vulnerability ?severity
WHERE {
    ?call a core:RemoteCall .
    ?call core:refersToModule/core:name ?moduleName .
    ?call struct:callsFunction ?funcRef .
    ?funcRef struct:functionName ?funcName .
    ?funcRef struct:arity ?arity .
    
    # Match against pattern registry
    ?pattern a sec:InsecureFunctionPattern .
    ?pattern sec:moduleAtom ?moduleName .
    ?pattern sec:functionAtom ?funcName .
    ?pattern sec:arity ?arity .
    ?pattern sec:triggersVulnerability ?vulnerability .
    ?pattern sec:severity ?severity .
    
    OPTIONAL {
        ?call core:hasSourceLocation ?loc .
        ?loc core:inSourceFile/core:filePath ?filePath .
        ?loc core:startLine ?line .
    }
}
ORDER BY DESC(?severity)
```

```sparql
# Q2: GenServers with sensitive state missing format_status
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX otp: <https://w3id.org/elixir-code/otp#>
PREFIX sec: <https://w3id.org/elixir-code/security#>

SELECT ?module ?moduleName ?sensitiveField
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    ?module struct:implementsBehaviour/struct:moduleName "GenServer" .
    
    # Has struct with sensitive fields
    ?module struct:containsStruct/struct:hasField ?field .
    ?field struct:fieldName ?sensitiveField .
    FILTER(REGEX(?sensitiveField, "(password|secret|key|token|credential)", "i"))
    
    # Missing format_status/2
    FILTER NOT EXISTS {
        ?module struct:containsFunction ?func .
        ?func struct:functionName "format_status" .
        ?func struct:arity 2 .
    }
}
```

```sparql
# Q3: Structs with sensitive fields missing @derive Inspect
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?module ?moduleName ?sensitiveField
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    ?module struct:containsStruct/struct:hasField ?field .
    ?field struct:fieldName ?sensitiveField .
    
    FILTER(REGEX(?sensitiveField, 
        "(password|secret|token|key|credential|ssn|credit_card|api_key)", "i"))
    
    FILTER NOT EXISTS {
        ?module struct:hasAttribute ?attr .
        ?attr a struct:DeriveAttribute .
        ?attr struct:attributeValue ?val .
        FILTER(CONTAINS(?val, "Inspect"))
    }
}
```

```sparql
# Q4: LiveView modules without authorization checks
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?module ?moduleName
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    ?module struct:usesModule/struct:moduleName "Phoenix.LiveView" .
    
    # Has handle_event
    ?module struct:containsFunction ?func .
    ?func struct:functionName "handle_event" .
    
    # No on_mount with auth
    FILTER NOT EXISTS {
        ?module struct:hasAttribute ?onMount .
        ?onMount struct:attributeName "on_mount" .
        ?onMount struct:attributeValue ?val .
        FILTER(REGEX(?val, "(auth|ensure|require)", "i"))
    }
}
```

### 5.2 Anti-Pattern Domain Queries

```sparql
# Q5: Unsupervised Process Detection
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX otp: <https://w3id.org/elixir-code/otp#>

SELECT ?process ?processName ?module
WHERE {
    ?process a otp:GenServer .
    ?process struct:definedIn ?module .
    ?process struct:name ?processName .
    
    FILTER NOT EXISTS {
        ?supervisor otp:supervises ?process .
    }
}
```

```sparql
# Q6: Agent Obsession (scattered access across modules)
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX otp: <https://w3id.org/elixir-code/otp#>

SELECT ?agent ?agentName (COUNT(DISTINCT ?module) AS ?accessingModules)
WHERE {
    ?agent a otp:Agent .
    ?agent struct:name ?agentName .
    ?func otp:accessesAgent ?agent .
    ?module struct:containsFunction ?func .
}
GROUP BY ?agent ?agentName
HAVING (COUNT(DISTINCT ?module) > 1)
ORDER BY DESC(?accessingModules)
```

```sparql
# Q7: Code Organization by Process (GenServer without state modification)
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX otp: <https://w3id.org/elixir-code/otp#>

SELECT ?genserver ?name
WHERE {
    ?genserver a otp:GenServer .
    ?genserver struct:name ?name .
    
    FILTER NOT EXISTS {
        ?genserver otp:hasCallback ?callback .
        ?callback otp:modifiesState true .
    }
}
```

```sparql
# Q8: Circular Dependency Detection
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT DISTINCT ?moduleA ?moduleB
WHERE {
    ?moduleA struct:dependsOn+ ?moduleB .
    ?moduleB struct:dependsOn+ ?moduleA .
    FILTER(STR(?moduleA) < STR(?moduleB))
}
```

```sparql
# Q9: Feature Envy (function uses more external than internal)
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?function ?functionName ?homeModule
       (COUNT(DISTINCT ?internalCall) AS ?internal)
       (COUNT(DISTINCT ?externalCall) AS ?external)
WHERE {
    ?function a struct:Function .
    ?function struct:functionName ?functionName .
    ?function struct:definedIn ?homeModule .
    
    OPTIONAL {
        ?function struct:calls ?internalTarget .
        ?internalTarget struct:definedIn ?homeModule .
        BIND(?internalTarget AS ?internalCall)
    }
    
    OPTIONAL {
        ?function struct:calls ?externalTarget .
        ?externalTarget struct:definedIn ?otherModule .
        FILTER(?otherModule != ?homeModule)
        BIND(?externalTarget AS ?externalCall)
    }
}
GROUP BY ?function ?functionName ?homeModule
HAVING (COUNT(DISTINCT ?externalCall) > COUNT(DISTINCT ?internalCall) * 2)
```

```sparql
# Q10: God Module Detection (>20 public functions)
PREFIX struct: <https://w3id.org/elixir-code/structure#>

SELECT ?module ?moduleName (COUNT(?func) AS ?funcCount)
WHERE {
    ?module a struct:Module .
    ?module struct:moduleName ?moduleName .
    ?module struct:containsFunction ?func .
    ?func struct:isPublic true .
}
GROUP BY ?module ?moduleName
HAVING (COUNT(?func) > 20)
ORDER BY DESC(?funcCount)
```

---

## 6. Pre-Generation Constraint Injection

### 6.1 Security Guide (~800 words - always injected)

```markdown
## ELIXIR/BEAM SECURITY REQUIREMENTS

### CRITICAL - NEVER DO THESE:

**1. Never create atoms from user input** (BEAM-001)
- ❌ `String.to_atom(user_input)`, `List.to_atom(input)`, `Module.concat(user_module)`
- ✅ `String.to_existing_atom(input)` or lookup maps: `%{"opt_a" => :opt_a}[input]`

**2. Never evaluate user-provided code** (BEAM-008)
- ❌ `Code.eval_string(user_code)`, `Code.eval_file(path)`, `:file.script(file)`
- ✅ Use embedded sandboxes (Lua via luerl) for untrusted code

**3. Never interpolate user input into SQL** (WEB-004)
- ❌ `Repo.query("SELECT * FROM users WHERE id = #{id}")`
- ✅ `Repo.query("SELECT * FROM users WHERE id = $1", [id])`

**4. Never use raw() with user input** (WEB-001)
- ❌ `<%= raw(user_input) %>`, `html(conn, "<p>#{input}</p>")`
- ✅ Phoenix templates auto-escape: `<%= @user_input %>`

**5. Never use :os.cmd for user input** (BEAM-010)
- ❌ `:os.cmd('grep #{pattern} file')`
- ✅ `System.cmd("grep", [pattern, "file"])` with args as list

**6. Never deserialize untrusted ETF without protections** (BEAM-006)
- ❌ `:erlang.binary_to_term(data)` without `[:safe]`
- ✅ `Plug.Crypto.non_executable_binary_to_term(data, [:safe])`

### AUTHENTICATION & SESSIONS:
- Hash passwords with Bcrypt/Argon2
- Regenerate session on login: `configure_session(conn, renew: true)`
- WebSockets: keep `check_origin: true` OR implement token auth
- LiveView: verify authorization in BOTH `mount/3` AND `handle_event/3`

### SENSITIVE DATA PROTECTION:
- Add `@derive {Inspect, except: [:password, :secret]}` to structs
- Implement `format_status/2` in GenServers holding sensitive state
- Configure `:filter_parameters` in Phoenix

### CRYPTOGRAPHIC OPERATIONS:
- Constant-time comparison: `Plug.Crypto.secure_compare(a, b)`
- Never pattern match on secrets
```

### 6.2 Credo Style Guide (~600 words - always injected)

```markdown
## ELIXIR/CREDO STYLE REQUIREMENTS

### Naming (snake_case is mandatory)
- Functions/variables: `get_user`, `user_id`, `@max_retries`
- Modules: PascalCase with uppercase acronyms: `HTTPClient`, `XMLParser`
- Predicates: `valid?` for functions, `is_valid` prefix for guard macros

### Documentation (required for public APIs)
- Every public module needs `@moduledoc` or `@moduledoc false`
- Every public function needs `@doc` before `@spec`
- Add `@spec` type specifications for all public functions

### Code structure limits
- Line length: max **120 characters**
- Cyclomatic complexity: max **9** per function
- Function arity: max **8** parameters
- Nesting depth: max **2** levels

### Pipe chain rules (frequently violated)
```elixir
# CORRECT - starts with value
user_id
|> fetch_user()
|> format_response()

# WRONG - starts with function call
fetch_user(user_id)
|> format_response()
```

### Control flow
- Never `unless` with `else`—use `if` instead
- Never `if !condition` with else—flip the branches
- `cond` needs 3+ branches; use `if/else` for 2 branches

### Warnings (production blockers)
- No `IO.inspect`—use `Logger.debug/info/warn/error`
- No `IEx.pry` or `dbg()` calls
- No unused variables (prefix with `_` if intentional)
```

### 6.3 Anti-Pattern Guide (~400 words - always injected)

```markdown
## ELIXIR OTP & PROCESS PATTERNS

### Process and OTP
- ALWAYS place GenServer/Agent/Task under supervision trees
- Use GenServer ONLY for stateful operations; pure functions don't need processes
- Encapsulate ALL Agent access in a single wrapper module
- Use `handle_call/3` for sync, `handle_cast/2` for async
- NEVER block in `init/1`—use `{:ok, state, {:continue, :setup}}`

### Function Design
- Return `{:ok, result}` or `{:error, reason}` tuples, NOT exceptions
- Validate data at function boundaries with guards
- Keep function clauses related—split unrelated logic
- Maximum 5 parameters per function; use keyword options for more

### Module Organization
- Use `import` when you only need functions; reserve `use` for macros/behaviors
- Avoid macros when functions suffice
- Libraries should accept configuration as function arguments, not Application env
```

### 6.4 Context-Triggered Warnings

Injected when specific patterns are detected in the request:

| Context Trigger | Warning Injected |
|-----------------|------------------|
| GenServer, handle_call, handle_cast | OTP context: supervision, format_status |
| Agent.start, Agent.get/update | Agent encapsulation warning |
| Ecto, Repo, query | SQL injection prevention |
| File, Path, upload | Path traversal prevention |
| Phoenix.HTML, raw | XSS prevention |
| LiveView, handle_event | LiveView auth requirements |
| WebSocket, Channel | WebSocket security |
| crypto, hash, password | Cryptographic best practices |

---

## 7. Elixir Implementation

### 7.1 Configuration Schema

```elixir
defmodule JidoCode.Validation.Config do
  @schema [
    # Retry configuration
    max_retries: [
      type: :non_neg_integer,
      default: 3,
      doc: "Maximum generation attempts before returning best result"
    ],
    
    acceptable_score_threshold: [
      type: :float,
      default: 50.0,
      doc: "Score below which code is accepted (0 = perfect)"
    ],
    
    # Domain enablement
    enabled_domains: [
      type: {:list, {:in, [:security, :anti_pattern, :credo]}},
      default: [:security, :anti_pattern, :credo],
      doc: "Which validation domains to enable"
    ],
    
    # Blocking configuration
    blocking_severities: [
      type: {:list, {:in, [:critical, :high, :medium, :low, :info]}},
      default: [:critical, :high],
      doc: "Severity levels that block code acceptance"
    ],
    
    # Domain-specific overrides
    security: [
      type: :keyword_list,
      default: [],
      keys: [
        sobelow_enabled: [type: :boolean, default: true],
        ignore_vulnerabilities: [type: {:list, :atom}, default: []]
      ]
    ],
    
    anti_pattern: [
      type: :keyword_list,
      default: [],
      keys: [
        ignore_smells: [type: {:list, :atom}, default: []],
        sparql_enabled: [type: :boolean, default: true]
      ]
    ],
    
    credo: [
      type: :keyword_list,
      default: [],
      keys: [
        strict: [type: :boolean, default: true],
        config_file: [type: :string, default: ".credo.exs"]
      ]
    ],
    
    # SPARQL configuration
    sparql: [
      type: :keyword_list,
      default: [],
      keys: [
        endpoint: [type: :string],
        timeout_ms: [type: :pos_integer, default: 5000]
      ]
    ],
    
    # Execution
    parallel_validation: [type: :boolean, default: true],
    timeout_ms: [type: :pos_integer, default: 30_000]
  ]
  
  def schema, do: @schema
end
```

### 7.2 Validation Middleware Skill

```elixir
defmodule JidoCode.Skills.ValidationMiddleware do
  use Jido.Skill,
    name: "validation_middleware",
    description: "Unified code validation pipeline"
  
  alias JidoCode.Validation.{
    PreGeneration,
    ParallelValidator,
    ViolationScorer,
    AttemptTracker,
    FeedbackFormatter
  }
  
  @impl Jido.Skill
  def router(_opts) do
    [{"jidocode.generate", &handle_generate/2}]
  end
  
  def handle_generate(signal, skill_opts) do
    config = skill_opts.config
    request_id = signal.id || UUID.uuid4()
    
    # Initialize attempt tracking
    {:ok, _} = AttemptTracker.start_link(request_id, signal.data.prompt, config)
    
    # Execute validation loop
    result = generate_with_validation(signal.data, config, request_id)
    
    {:ok, %{signal | data: result}}
  end
  
  defp generate_with_validation(input, config, request_id, attempt \\ 1) do
    # STAGE 1: Pre-generation enrichment
    enriched_prompt = PreGeneration.enrich_prompt(
      input.prompt,
      input[:context] || %{},
      config
    )
    
    # STAGE 2: Generate code
    {:ok, generated} = generate_code(enriched_prompt, config.model)
    
    # STAGE 3: Parallel validation
    violations = ParallelValidator.validate_all(
      generated.code,
      config.enabled_domains,
      config
    )
    
    # Record attempt
    AttemptTracker.record_attempt(request_id, generated.code, violations)
    best = AttemptTracker.get_best_attempt(request_id)
    
    # STAGE 4: Decision
    cond do
      best.score == 0.0 ->
        build_success_result(best)
      
      ViolationScorer.should_retry?(best, config) and attempt < config.max_retries ->
        feedback = FeedbackFormatter.format_for_llm(violations, attempt)
        generate_with_validation(
          %{input | prompt: feedback <> "\n\n" <> input.prompt},
          config,
          request_id,
          attempt + 1
        )
      
      true ->
        build_result_with_report(best, request_id)
    end
  end
end
```

### 7.3 Parallel Validator

```elixir
defmodule JidoCode.Validation.ParallelValidator do
  alias JidoCode.Validators.{
    SecurityValidator,
    AntiPatternValidator,
    CredoValidator
  }
  
  @validators %{
    security: SecurityValidator,
    anti_pattern: AntiPatternValidator,
    credo: CredoValidator
  }
  
  def validate_all(code, enabled_domains, opts \\ []) do
    timeout = Keyword.get(opts, :timeout, 30_000)
    
    enabled_domains
    |> Enum.filter(&Map.has_key?(@validators, &1))
    |> Task.async_stream(
      fn domain ->
        validator = Map.fetch!(@validators, domain)
        {domain, validator.validate(code, opts)}
      end,
      timeout: timeout,
      on_timeout: :kill_task
    )
    |> Enum.flat_map(fn
      {:ok, {domain, {:ok, violations}}} ->
        Enum.map(violations, &Map.put(&1, :domain, domain))
      
      {:ok, {domain, {:error, reason}}} ->
        [%{domain: domain, severity: :info, message: "Validator error: #{reason}"}]
      
      {:exit, :timeout} ->
        [%{domain: :system, severity: :info, message: "Validation timeout"}]
    end)
    |> Enum.sort_by(&severity_order(&1.severity))
  end
  
  defp severity_order(:critical), do: 0
  defp severity_order(:high), do: 1
  defp severity_order(:medium), do: 2
  defp severity_order(:low), do: 3
  defp severity_order(:info), do: 4
  defp severity_order(_), do: 5
end
```

### 7.4 Violation Scorer

```elixir
defmodule JidoCode.Validation.ViolationScorer do
  @severity_weights %{
    critical: 100,
    high: 50,
    medium: 20,
    low: 5,
    info: 1
  }
  
  @domain_multipliers %{
    security: 2.0,
    anti_pattern: 1.2,
    credo: 1.0
  }
  
  def calculate_score(violations) do
    {total_score, blocking_count} =
      Enum.reduce(violations, {0.0, 0}, fn v, {score, blocking} ->
        base = Map.get(@severity_weights, v.severity, 10)
        mult = Map.get(@domain_multipliers, v.domain, 1.0)
        
        new_blocking = if v[:blocking], do: blocking + 1, else: blocking
        {score + (base * mult), new_blocking}
      end)
    
    # Apply diminishing returns for repeated violations
    adjusted = apply_diminishing_returns(violations, total_score)
    
    {adjusted, blocking_count}
  end
  
  def select_best_attempt(attempts) do
    Enum.min_by(attempts, fn a ->
      {a.blocking_count, a.score, length(a.violations)}
    end)
  end
  
  def should_retry?(attempt, config) do
    attempt.score > 0 and
    attempt.blocking_count > 0 and
    attempt.attempt_number < config.max_retries
  end
  
  defp apply_diminishing_returns(violations, base_score) do
    violations
    |> Enum.frequencies_by(& &1[:rule_id])
    |> Enum.reduce(base_score, fn {_rule, count}, score ->
      if count > 1 do
        score - :math.log(count) * 5
      else
        score
      end
    end)
    |> max(0.0)
  end
end
```

### 7.5 Security Validator

```elixir
defmodule JidoCode.Validators.SecurityValidator do
  @security_patterns [
    # Atom exhaustion
    {"String", "to_atom", 1, "BEAM-001", :high},
    {"List", "to_atom", 1, "BEAM-001", :high},
    {"Module", "concat", 1, "BEAM-001", :high},
    {"Module", "concat", 2, "BEAM-001", :high},
    {"erlang", "binary_to_atom", 1, "BEAM-001", :high},
    {"erlang", "binary_to_atom", 2, "BEAM-001", :high},
    {"erlang", "list_to_atom", 1, "BEAM-001", :high},
    
    # Code injection
    {"Code", "eval_string", 1, "BEAM-008", :critical},
    {"Code", "eval_string", 2, "BEAM-008", :critical},
    {"Code", "eval_string", 3, "BEAM-008", :critical},
    {"Code", "eval_file", 1, "BEAM-008", :critical},
    {"Code", "eval_file", 2, "BEAM-008", :critical},
    {"Code", "eval_quoted", 2, "BEAM-008", :critical},
    {"file", "script", 1, "BEAM-009", :critical},
    {"file", "eval", 1, "BEAM-009", :critical},
    
    # Command injection
    {"os", "cmd", 1, "BEAM-010", :critical},
    {"os", "cmd", 2, "BEAM-010", :critical},
    {"System", "shell", 1, "BEAM-010", :high},
    {"System", "shell", 2, "BEAM-010", :high},
    
    # Unsafe deserialization
    {"erlang", "binary_to_term", 1, "BEAM-006", :critical},
    
    # XSS
    {"Phoenix.HTML", "raw", 1, "WEB-001", :critical},
    {"Phoenix.HTML.Raw", "raw", 1, "WEB-001", :critical}
  ]
  
  def validate(code, opts \\ []) do
    with {:ok, ast} <- Code.string_to_quoted(code) do
      violations = 
        ast_violations(ast) ++
        sparql_violations(code, opts) ++
        sobelow_violations(code, opts)
      
      {:ok, violations}
    end
  end
  
  defp ast_violations(ast) do
    {_, violations} = Macro.prewalk(ast, [], fn
      {{:., _, [{:__aliases__, _, module_parts}, func]}, meta, args}, acc ->
        module = Enum.join(module_parts, ".")
        arity = length(args)
        
        case find_pattern(module, to_string(func), arity) do
          nil -> {ast, acc}
          {erlef_id, severity} ->
            violation = %{
              rule_id: erlef_id,
              severity: severity,
              blocking: severity in [:critical, :high],
              message: "#{module}.#{func}/#{arity} is insecure",
              location: %{line: meta[:line]}
            }
            {ast, [violation | acc]}
        end
      
      node, acc -> {node, acc}
    end)
    
    violations
  end
  
  defp find_pattern(module, func, arity) do
    Enum.find_value(@security_patterns, fn
      {^module, ^func, ^arity, erlef_id, severity} -> {erlef_id, severity}
      _ -> nil
    end)
  end
  
  defp sparql_violations(code, opts) do
    if Keyword.get(opts, :sparql_enabled, true) do
      # Run SPARQL queries for semantic security issues
      JidoCode.SPARQL.Client.run_security_queries(code)
    else
      []
    end
  end
  
  defp sobelow_violations(code, opts) do
    if Keyword.get(opts, :sobelow_enabled, true) do
      JidoCode.Sobelow.analyze(code)
    else
      []
    end
  end
end
```

---

## 8. Files to Create

Based on this research, the following files should be created:

### Ontology Files
1. `lib/ontology/validation/unified-validation.ttl` - Unified validation ontology
2. `lib/ontology/validation/unified-validation-shapes.ttl` - SHACL shapes

### Validation Pipeline
3. `lib/jido_code/validation/config.ex` - Configuration schema
4. `lib/jido_code/validation/parallel_validator.ex` - Parallel execution
5. `lib/jido_code/validation/violation_scorer.ex` - Scoring algorithm
6. `lib/jido_code/validation/attempt_tracker.ex` - Attempt tracking
7. `lib/jido_code/validation/feedback_formatter.ex` - LLM feedback

### Domain Validators
8. `lib/jido_code/validators/security_validator.ex` - Security validation
9. `lib/jido_code/validators/anti_pattern_validator.ex` - Anti-pattern detection
10. `lib/jido_code/validators/credo_validator.ex` - Credo integration

### Pre-Generation
11. `lib/jido_code/pre_generation/constraint_injector.ex` - Prompt enrichment
12. `lib/jido_code/pre_generation/context_detector.ex` - Context detection
13. `lib/jido_code/pre_generation/negative_examples.ex` - DO/DON'T examples

### Integration
14. `lib/jido_code/skills/validation_middleware.ex` - Jido Skill middleware
15. `lib/jido_code/sparql/client.ex` - SPARQL client wrapper
16. `lib/jido_code/sobelow/integration.ex` - Sobelow integration

### Prompt Files
17. `priv/prompts/security_guide.md` - Security system prompt
18. `priv/prompts/credo_guide.md` - Credo system prompt
19. `priv/prompts/antipattern_guide.md` - Anti-pattern system prompt
20. `priv/prompts/context_warnings/*.md` - Context-triggered warnings

---

## 9. Implementation Priorities

### Phase 1: Core Infrastructure (Week 1-2)
1. Unified configuration schema
2. Parallel validator framework
3. Violation scorer with best-attempt selection
4. Attempt tracker

### Phase 2: Security Domain (Week 2-3)
1. AST pattern matching for 22 insecure function patterns
2. Sobelow integration
3. Security SPARQL queries (4 queries)
4. Security system prompt guide

### Phase 3: Credo Domain (Week 3-4)
1. Credo JSON output integration
2. Quick pattern checks (IO.inspect, pipe chains)
3. Result caching with ETS
4. Credo system prompt guide

### Phase 4: Anti-Pattern Domain (Week 4-5)
1. SPARQL queries for semantic smells (6 queries)
2. AST-based smell detection
3. SHACL shape validation
4. Anti-pattern system prompt guide

### Phase 5: Integration (Week 5-6)
1. Jido Skill middleware
2. Pre-generation context injection
3. Context-triggered warnings
4. Feedback formatter for retry loop

### Phase 6: Testing & Optimization (Week 6-7)
1. Comprehensive test suite
2. Performance optimization
3. Caching strategies
4. Documentation

---

## 10. Key Design Decisions

1. **Parallel validation**: All three domains run concurrently via Task.async_stream, reducing total time from 3x sequential to ~1x (limited by slowest).

2. **SPARQL for semantic analysis**: Complex cross-module patterns (circular deps, supervision, feature envy) use SPARQL; simple patterns use AST matching.

3. **Best-attempt selection**: Always returns usable code. Prioritizes by blocking count → score → violation count.

4. **Pre-generation over post-generation**: ~70% of issues prevented by system prompts, ~20% by context injection, ~10% caught in validation loop.

5. **Unified severity model**: Consistent scoring across domains enables fair comparison and intelligent retry decisions.

6. **Skill-based middleware**: Leverages Jido's existing primitives without framework modifications.
