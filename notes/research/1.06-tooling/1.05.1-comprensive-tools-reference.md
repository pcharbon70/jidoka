# Comprehensive tool reference for LLM-powered coding assistants

Modern agentic coding assistants converge on a remarkably consistent set of **15-25 core tools** spanning file operations, code search, shell execution, and project understanding. This analysis of Claude Code, OpenCode, Aider, Cline, Cursor, Continue.dev, GitHub Copilot, and Amazon Q reveals the essential toolkit for JidoCode, with particular attention to Elixir/BEAM-specific opportunities that other assistants cannot match.

## Core insight: tool categories are universal, implementations vary

Every major coding assistant implements the same fundamental categories: file read/write, search (pattern and semantic), shell execution, and task management. The key differentiators are **editing strategies** (whole-file vs. patch vs. search/replace), **LSP integration depth**, and **sandboxing approaches**. For JidoCode, the opportunity lies in combining these proven patterns with Elixir's unique runtime introspection capabilities.

---

## File system operations

File operations form the foundation of every coding assistant. The consensus across all tools examined is a **read-before-write validation pattern** that prevents the LLM from blindly overwriting files it hasn't examined.

### Read operations

| Tool Pattern | Input Schema | Output Format | Used By |
|--------------|--------------|---------------|---------|
| **read_file** | `{path, offset?, limit?}` | Line-numbered content (cat -n format) | Claude Code, OpenCode, Cursor, Continue |
| **notebook_read** | `{notebook_path}` | Parsed cells with outputs | Claude Code, OpenCode |
| **read_currently_open_file** | None | Active editor content | Continue.dev |

Claude Code's Read tool defaults to **2,000 lines** with **2,000 character line truncation**, providing sensible bounds for context windows. OpenCode adds binary file detection to reject images/PDFs automatically. Both track read timestamps via `FileTime.read()` to detect concurrent modifications.

**Key design decision**: Line-numbered output (1-indexed) enables precise referencing in subsequent edit operations. All major assistants format output as `cat -n` style.

### Write and edit operations

The most significant architectural divergence occurs in how assistants modify files:

**Whole-file replacement** (simplest approach):
```
Write(path, content) → Overwrites entire file
```
Used by: Aider (for weaker models), basic implementations. Anthropic's Claude Code requires prior Read operation before Write to prevent blind overwrites.

**Search/Replace blocks** (most common):
```
Edit(path, old_string, new_string) → Surgical replacement
```
Used by: Claude Code, OpenCode, Aider (diff format), Cline. Requires exact string matching with the original text serving as an anchor.

**Multi-edit batching**:
```
MultiEdit(path, [{old, new}, ...]) → Atomic batch
```
Claude Code's MultiEdit applies all edits sequentially in one atomic operation—either all succeed or none apply. This pattern reduces tool call overhead significantly.

**Unified diff/patch application**:
```
Patch(diff_text) → Apply unified diff
```
OpenCode implements a dedicated Patch tool for applying standard unified diffs across multiple files.

### OpenCode's multi-strategy edit matching

OpenCode implements **five fallback strategies** for edit matching, accounting for LLM formatting inconsistencies:

1. **SimpleReplacer**: Exact string match
2. **LineTrimmedReplacer**: Match after trimming line whitespace
3. **BlockAnchorReplacer**: Use first/last lines as anchors with Levenshtein distance
4. **WhitespaceNormalizedReplacer**: Normalize all whitespace before matching
5. **IndentationFlexibleReplacer**: Remove leading indentation before matching

This approach achieves higher edit success rates by gracefully handling common LLM output variations.

### Directory operations

| Tool | Purpose | Notes |
|------|---------|-------|
| **ls/list_dir** | List directory contents | Accepts ignore patterns |
| **glob** | Pattern-based file search | Supports `**`, `{a,b}`, `[abc]` patterns |
| **delete_file** | Remove files | Cursor includes this; most others don't |
| **create_new_file** | Create with content | Continue.dev separates create from overwrite |

---

## Code search and navigation

Search capabilities split into two paradigms: **pattern-based search** (grep/ripgrep) and **semantic search** (embeddings/vector similarity).

### Pattern-based search (grep)

All major assistants use **ripgrep** as the underlying engine:

```typescript
// Claude Code Grep schema
{
  pattern: string,           // Regex pattern
  path?: string,             // Search directory
  output_mode?: 'content' | 'files_with_matches' | 'count',
  '-A'?: number,             // Lines after match
  '-B'?: number,             // Lines before match
  '-C'?: number,             // Context lines (before AND after)
  multiline?: boolean,       // Cross-line patterns
  type?: string,             // File type filter: js, py, rust, go
}
```

**Critical design element**: Context lines (`-A`, `-B`, `-C` flags) provide surrounding code that helps the LLM understand matches without separate read operations.

### Semantic codebase search

Cursor pioneered **custom embeddings trained on agent session traces**: an LLM ranks which content would have been most helpful at each conversation step, creating a feedback loop that improves code-specific semantic understanding. Results: **12.5% higher accuracy** in answering questions, **2.6% better code retention** on 1,000+ file codebases.

| Assistant | Semantic Search Approach |
|-----------|-------------------------|
| Cursor | Custom embedding model, Turbopuffer vector DB |
| Continue.dev | Configurable embeddings (Ollama nomic-embed-text for local) |
| OpenCode | Exa integration (CodeSearch tool) for Zen users |
| GitHub Copilot | search_workspace with proprietary indexing |

### Repository map (Aider's innovation)

Aider creates a **compressed AST-based map** of the entire codebase using tree-sitter. This provides structural context without consuming tokens on full file contents:

- Shows file structure and code signatures
- Controlled via `--map-tokens` parameter
- Helps LLM understand large codebases without full file reads
- Critical for enabling changes across unfamiliar codebases

---

## Shell and terminal execution

### Core bash/terminal tool

All assistants implement shell execution with similar schemas:

```typescript
// Consensus Bash tool schema
{
  command: string,         // Shell command to execute
  description?: string,    // 5-10 word description (for logging/approval)
  timeout?: number,        // Max 2-10 minutes depending on assistant
}
```

**Output handling**: Claude Code truncates at **30,000 characters**. Most assistants stream output in real-time via metadata/SSE events.

### Background process management

Claude Code and OpenCode support long-running background processes:

| Tool | Purpose |
|------|---------|
| **bash(run_in_background=true)** | Start background process |
| **BashOutput(bash_id, filter?)** | Retrieve incremental output |
| **KillShell(shell_id)** | Terminate background shell |

Cline's VS Code integration enables a **"Proceed While Running"** button for long-running processes like dev servers.

### Shell state management

**Persistent vs. stateless shells**:
- Claude Code, OpenCode: Persistent shell session (state maintained across calls)
- Continue.dev: Explicitly notes "shell is not stateful"

Persistent shells enable `cd` commands and environment variable changes to carry forward, but require careful cleanup.

---

## Git operations

Git integration ranges from basic command passthrough to full automation:

### Aider's auto-commit model
- **Auto-commits** every change with AI-generated commit messages
- `/undo` command reverts the last aider commit
- `/diff` shows changes since last commit
- Full git command passthrough via `/git <command>`

### GitHub Copilot Coding Agent (async SWE agent)
Operates via GitHub Actions with full repository automation:
- Assign issues directly to `@copilot`
- Automatic branch creation and PR opening
- Runs tests and linters in CI environment
- Commits are co-authored for traceability
- Vision model support for mockups/screenshots in issues

### Amazon Q GitHub Integration
Similar PR automation (in preview):
- Implement features via GitHub
- Perform code reviews on PRs
- Transform Java applications

### Manual git via shell
Most assistants rely on bash tool for git operations without dedicated git tools.

---

## LSP integration and code intelligence

### Diagnostic integration patterns

| Assistant | LSP Approach |
|-----------|-------------|
| Claude Code | `getDiagnostics(uri?)` returns errors/warnings from VS Code |
| OpenCode | Auto-appends diagnostics after edit/write in `<file_diagnostics>` tags |
| Cursor | Automatic error detection, agent mode auto-fixes linter errors |
| Cline | Monitors linter/compiler errors, proactively fixes issues |

OpenCode's approach is notable: after every file modification, it calls `LSP.touchFile()` to notify language servers, then retrieves and appends diagnostics to the tool output. This creates an immediate feedback loop without requiring separate diagnostic checks.

### Code navigation tools

| Capability | Tool/Approach |
|------------|---------------|
| **Hover info** | `lsp_hover(file, line, character)` → Type info, docs |
| **Go-to-definition** | Via LSP, used for codebase exploration |
| **Find references** | Critical for safe refactoring |
| **Completions** | Context-aware suggestions at cursor position |

### ElixirLS and Lexical for JidoCode

**ElixirLS** (single-VM approach):
- ElixirSense for context-aware completion
- Dialyzer integration with persistent manifest
- Full DAP (Debug Adapter Protocol) support
- Test code lenses

**Lexical** (dual-VM approach):
- As-you-type compilation in separate VM (crashes don't affect LSP)
- Advanced indexing for fast find-references
- Better isolation but more complex setup

---

## Project understanding and context

### Context providers (Continue.dev pattern)

Continue.dev implements extensive `@`-mention context providers:

| Provider | Symbol | Description |
|----------|--------|-------------|
| @File | `@file` | Reference any workspace file |
| @Code | `@code` | Reference specific functions/classes |
| @Git Diff | `@diff` | All changes on current branch |
| @Terminal | `@terminal` | Last terminal command and output |
| @Problems | `@problems` | Current file problems/diagnostics |
| @Debugger | `@debugger` | Local variables in debugger |
| @Repository Map | `@repo-map` | Codebase outline with signatures |

### Cline's @ mention system
- `@url` - Fetch URL, convert to markdown
- `@file` - Add file contents
- `@folder` - Add all files in folder
- `@problems` - Workspace errors/warnings

### Dependency analysis

| Assistant | Approach |
|-----------|----------|
| Aider | Repository map with tree-sitter AST |
| Amazon Q | `/dev` command analyzes existing codebase before implementation |
| Continue.dev | `view_repo_map` tool with optional signatures |

---

## Web and documentation tools

### Web fetching

```typescript
// Claude Code WebFetch schema
{
  url: string,     // Fully-formed URL
  prompt: string,  // Prompt to run on fetched content
}
```

Claude Code converts HTML to markdown, uses a fast model for processing, and maintains a 15-minute cache. OpenCode's WebFetch supports format selection (`markdown`, `text`, `html`) with TurndownService for HTML→Markdown conversion.

### Web search

| Assistant | Search Capability |
|-----------|------------------|
| Claude Code | `WebSearch(query, allowed_domains?, blocked_domains?)` |
| OpenCode | Exa integration (Zen users only) |
| Cursor | Agent mode web_search |
| Continue.dev | `search_web` tool |
| Amazon Q | No direct web search (AWS-focused) |

### Browser automation (Cline unique capability)

Cline implements full headless browser control via Puppeteer/Playwright:

```typescript
browser_action({
  action: "launch" | "click" | "type" | "scroll" | "screenshot" | "close",
  url?: string,
  coordinate?: {x, y},
  text?: string,
})
```

This enables:
- End-to-end UI testing
- Filling forms and navigating web apps
- Capturing screenshots at each step
- Console log capture for debugging

---

## Agent and task management tools

### Sub-agent delegation

Claude Code and OpenCode both implement task delegation to specialized sub-agents:

```typescript
// Claude Code Task tool
{
  prompt: string,         // Detailed task description
  description: string,    // 3-5 word summary
  subagent_type: string,  // "general-purpose", "Explore", etc.
}
```

**Agent types** (Claude Code):
| Type | Tools Available | Use Case |
|------|-----------------|----------|
| `general-purpose` | All tools | Complex multi-step research |
| `Explore` | Glob, Grep, Read, Bash | Codebase exploration |
| `statusline-setup` | Read, Edit | Configuration tasks |

OpenCode's TaskTool creates new sessions for subagents with independent tools, models, and system prompts.

### Todo/task tracking

Both Claude Code and OpenCode implement session-scoped task tracking:

```typescript
// TodoWrite schema
{
  todos: [{
    content: string,      // What needs to be done
    status: 'pending' | 'in_progress' | 'completed',
    priority?: 'high' | 'medium' | 'low',
    id?: string,
  }]
}
```

**Critical constraint**: Only ONE task can be `in_progress` at a time. Tasks should be marked complete immediately, not batched.

### Plan/checkpoint systems

| Assistant | Approach |
|-----------|----------|
| Claude Code | `ExitPlanMode(plan)` transitions planning to execution |
| Cline | Checkpoint compare/restore for version branching |
| Cursor | Checkpoints before changes with revert capability |
| Continue.dev | Separate "Plan Mode" with read-only tools |

---

## Testing and quality tools

### Integrated test execution

| Assistant | Testing Integration |
|-----------|-------------------|
| Aider | `mix test` via bash, auto-fix on failure, `/test` command |
| Amazon Q | `/test` command for automatic test generation (Java, Python) |
| Cline | Terminal command with output monitoring |
| Continue.dev | `/test` slash command for unit test generation |

### Linting integration

| Assistant | Linting Approach |
|-----------|-----------------|
| Aider | `/lint` command with auto-fix |
| Amazon Q | `/review` for security and code quality |
| Cursor | Agent mode auto-fixes linter errors |
| OpenCode | LSP diagnostics in edit output |

### Amazon Q's specialized commands

| Command | Purpose |
|---------|---------|
| `/dev` | Multi-file feature implementation |
| `/doc` | README and documentation generation |
| `/review` | Security and code quality analysis |
| `/test` | Automatic test case identification |
| `/transform` | Java 8/11→17, .NET Windows→Linux |

---

## Tool design patterns and best practices

### Schema design principles

**Anthropic's guidance**:
1. **Descriptions are critical** - the most important element for tool selection
2. Use `input_examples` for complex tools with nested objects
3. Keep tool names unique and descriptive
4. Limit to ~20 tools for higher accuracy
5. All fields should be `required` for structured outputs

**MCP tool specification**:
```json
{
  "name": "tool_name",
  "title": "Human-readable Display Name",
  "description": "What the tool does",
  "inputSchema": { /* JSON Schema */ },
  "outputSchema": { /* Optional validation */ },
  "annotations": { /* Behavior hints */ }
}
```

### Two-level error architecture (MCP standard)

**Protocol errors** (JSON-RPC level):
```json
{"jsonrpc": "2.0", "id": 3, "error": {"code": -32602, "message": "Unknown tool"}}
```

**Tool execution errors** (in results):
```json
{"result": {"content": [{"type": "text", "text": "API rate limit exceeded"}], "isError": true}}
```

**Critical principle**: Tool errors should be reported in the result object, NOT as protocol-level errors. This allows the LLM to see and potentially handle errors.

### Recovery strategies

1. **Checkpoint recovery**: Record system state at strategic points, resume from checkpoint rather than restarting
2. **Retry with exponential backoff**: 5, 10, 30 seconds pattern
3. **Graceful degradation**: Fallback tools when primary fails
4. **Human escalation**: Clear paths when AI cannot solve

### Security and sandboxing

**Claude Code's dual-layer isolation**:
1. **Filesystem isolation**: Read/write to CWD only, blocks SSH keys, etc.
2. **Network isolation**: Approved destinations only, blocks data exfiltration

**OS-level enforcement**:
- macOS: Seatbelt sandbox
- Linux: bubblewrap + seccomp
- Restrictions inherited by all child processes

**Result**: 84% reduction in permission prompts internally.

### Tool composition patterns

**Combine sequential tools** when operations are always performed together:
- Reduces latency and token usage
- Example: Combine location query + mark into single function

**Use atomic tools** when:
- Operations may be used independently
- Easier testing and debugging required
- Higher reusability needed

**Agentic workflow patterns** (Anthropic):
- **Prompt chaining**: Sequential steps building on previous output
- **Routing**: Initial classification routes to specialized handlers
- **Parallelization**: Multiple agents provide independent analysis
- **Orchestrator-workers**: Central agent delegates to specialists
- **Evaluator-optimizer**: Generate, evaluate, iterate until quality threshold

---

## Elixir/BEAM-specific tool opportunities

The BEAM VM offers capabilities no other language runtime provides—**live system introspection without stopping processes**. JidoCode can leverage these for unique competitive advantage.

### IEx integration tools

| Tool | Purpose | Unique Value |
|------|---------|--------------|
| **eval_elixir** | `Code.eval_string(code, bindings)` | Live REPL without saving files |
| **fetch_docs** | `Code.fetch_docs(Module)` | Runtime documentation retrieval |
| **get_exports** | `exports(Module)` | Discover module API |
| **recompile_module** | `r(Module)` or `recompile()` | Hot reload without restart |
| **runtime_info** | `IEx.Helpers.runtime_info()` | VM memory, versions, stats |

### OTP introspection tools

```elixir
# These operations are unique to BEAM and cannot be replicated in other runtimes

# Get GenServer state without stopping process
:sys.get_state(pid_or_name)

# Full process status including state machine info
:sys.get_status(pid_or_name)

# Trace all messages to/from a process
:sys.trace(pid, true)

# Supervisor tree inspection
Supervisor.which_children(MySupervisor)
Supervisor.count_children(MySupervisor)
```

**Proposed tools**:

| Tool | Input | Output |
|------|-------|--------|
| **get_genserver_state** | `{name \| pid}` | Process state map |
| **inspect_supervisor** | `{supervisor_name}` | Children with types, pids, restart strategy |
| **trace_process** | `{pid, duration}` | Message log for debugging |
| **list_registered** | None | All registered process names |

### Mix task integration

```typescript
// mix_task tool schema
{
  task: string,     // "test", "compile", "format", etc.
  args?: string[],  // ["--failed", "--trace"]
}
```

**Critical Mix tasks for JidoCode**:

| Task | Automation Value |
|------|-----------------|
| `mix compile` | Build verification with warnings |
| `mix test` | ExUnit execution with filters |
| `mix format` | Auto-formatting |
| `mix credo` | Static analysis |
| `mix dialyzer` | Type checking |
| `mix xref` | Dependency analysis |

### Hot code reloading tools

| Tool | Purpose |
|------|---------|
| **reload_module** | `r(Module)` - recompile and reload single module |
| **deploy_to_nodes** | `nl([nodes], Module)` - deploy to distributed cluster |
| **purge_old_code** | `:code.soft_purge(Module)` - clean old code versions |

This enables debugging production issues without restarts—a capability unique to BEAM.

### ETS/DETS inspection

```typescript
// ets_inspect tool
{
  table: string,           // Table name
  operation: "list" | "lookup" | "info" | "match",
  key?: string,            // For lookup
  pattern?: string,        // For match
}
```

### Elixir LSP diagnostics

Integrate ElixirLS or Lexical for:
- Dialyzer type warnings
- Compilation errors
- Unused variable warnings
- Deprecated function usage
- Missing @spec warnings

---

## Recommended JidoCode tool inventory

Based on this analysis, JidoCode should implement these **22 core tools** plus **8 Elixir-specific tools**:

### Core tools (22)

**File Operations (7)**:
1. `read_file` - Line-numbered file reading with offset/limit
2. `write_file` - Create new files (require prior read for existing)
3. `edit_file` - Search/replace with multi-strategy matching
4. `multi_edit` - Atomic batch edits
5. `list_dir` - Directory listing with ignore patterns
6. `glob_search` - Pattern-based file finding
7. `delete_file` - File removal

**Code Search (3)**:
8. `grep_search` - Ripgrep-powered regex search with context
9. `codebase_search` - Semantic search (embeddings-based)
10. `repo_map` - Tree-sitter AST overview

**Shell Execution (3)**:
11. `bash_execute` - Command execution with timeout
12. `bash_background` - Start background processes
13. `bash_output` - Retrieve background process output

**Git Operations (1)**:
14. `git_command` - Passthrough to git CLI

**LSP Integration (2)**:
15. `get_diagnostics` - Fetch compilation/linter errors
16. `get_hover_info` - Type and documentation at position

**Web Tools (2)**:
17. `web_fetch` - Fetch and parse URL content
18. `web_search` - Search the web

**Agent/Task (3)**:
19. `spawn_subagent` - Delegate to specialized agent
20. `todo_write` - Track task progress
21. `todo_read` - Read current tasks

**User Interaction (1)**:
22. `ask_user` - Structured questions with options

### Elixir-specific tools (8)

23. `iex_eval` - Evaluate Elixir code with bindings
24. `mix_task` - Run Mix tasks with arguments
25. `get_process_state` - Inspect GenServer/Agent state
26. `inspect_supervisor` - View supervision tree
27. `reload_module` - Hot code reload
28. `ets_inspect` - ETS table inspection
29. `fetch_elixir_docs` - Runtime documentation retrieval
30. `run_exunit` - Execute tests with ExUnit integration

### Implementation priorities

**Phase 1 (MVP)**: Tools 1-8, 11, 14-15, 23-24
**Phase 2 (Core)**: Tools 9-10, 12-13, 16-18, 25-27
**Phase 3 (Advanced)**: Tools 19-22, 28-30

This inventory positions JidoCode to match Claude Code's capabilities while leveraging Elixir's unique strengths in live system introspection and hot code reloading—creating a coding assistant that can not just write code, but actively debug running OTP applications.
