# User Prompt Management in JidoCode

## Overview

This document explores the architecture for user-defined prompts in JidoCode with:
- Triplestore persistence (knowledge graph)
- Markdown content with YAML frontmatter
- TUI command interface (`/prompt use`, `/prompt list`, etc.)
- User-defined categories with sensible defaults

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         TUI Layer                                │
│  /prompt use <slug>  |  /prompt list  |  /prompt new  |  ...    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    JidoCode.Prompt Module                        │
│  - CRUD operations                                               │
│  - Frontmatter parsing                                           │
│  - Variable interpolation                                        │
│  - Category management                                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                  RDF/SPARQL Interface                            │
│  - Prompt ↔ RDF serialization                                    │
│  - SPARQL queries for search/filter                              │
│  - Category taxonomy queries                                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Triplestore                                  │
│  (Oxigraph / RDF.ex / etc.)                                     │
└─────────────────────────────────────────────────────────────────┘
```

## Frontmatter Schema

User prompts are written as markdown files with YAML frontmatter that maps directly to ontology properties:

```markdown
---
# Required
id: my-code-review
name: My Code Review Prompt
type: system  # system | user | assistant | meta | fragment | tool | validation

# Optional metadata
slug: my-code-review  # defaults to id if not provided
description: A custom code review prompt for Elixir projects
version: 1.0.0

# Categorization (user-defined or from defaults)
categories:
  domain: [code-review, elixir]
  task: evaluation
  technique: zero-shot
  complexity: intermediate
  audience: developer

# Variables declared in the prompt
variables:
  - name: code
    type: string
    required: true
    description: The code to review
  - name: context
    type: string
    required: false
    default: "No additional context"

# Targeting (optional)
target:
  language: elixir
  framework: [phoenix, ash]
  model: claude-3-opus
  model_family: Claude
  min_context: 8000

# Tags for search
tags: [elixir, review, custom]

# Provenance (auto-populated if not provided)
created_at: 2024-12-29T10:00:00Z
modified_at: 2024-12-29T10:00:00Z
author: user  # or agent name
---

# Code Review Instructions

You are an expert Elixir developer. Review the following code:

```elixir
{{code}}
```

## Context
{{context}}

Provide structured feedback with:
1. Critical issues
2. Suggestions
3. Positive observations
```

## Frontmatter → RDF Mapping

| Frontmatter Field | RDF Property | Notes |
|-------------------|--------------|-------|
| `id` | `jido:promptId` | Required, unique |
| `name` | `jido:promptName` | Required |
| `type` | `rdf:type` | Maps to `jido:SystemPrompt`, etc. |
| `slug` | `jido:promptSlug` | URL-safe identifier |
| `description` | `jido:promptDescription` | |
| `version` | `jido:versionNumber` | On `PromptVersion` |
| `categories.domain` | `jido:hasDomainCategory` | Can be list |
| `categories.task` | `jido:hasTaskCategory` | |
| `categories.technique` | `jido:hasTechniqueCategory` | |
| `categories.complexity` | `jido:hasComplexityCategory` | |
| `categories.audience` | `jido:hasAudienceCategory` | |
| `variables` | `jido:hasVariable` | Creates `PromptVariable` instances |
| `target.language` | `jido:targetLanguage` | |
| `target.framework` | `jido:targetFramework` | |
| `target.model` | `jido:targetModel` | |
| `tags` | `jido:hasPromptTag` | |
| `created_at` | `jido:promptCreatedAt` | |
| `author` | `jido:promptCreatedBy` | Links to Agent |
| (content body) | `jido:contentText` | On `PromptContent` |

## TUI Commands

### Command Reference

```
/prompt use <slug>           - Insert prompt into current context
/prompt list [--category=X]  - List available prompts
/prompt show <slug>          - Display prompt content and metadata
/prompt new                  - Interactive prompt creation
/prompt edit <slug>          - Edit existing prompt
/prompt delete <slug>        - Delete a prompt (with confirmation)
/prompt search <query>       - Full-text search prompts
/prompt categories           - List available categories
/prompt category new <name>  - Create new category
/prompt export <slug>        - Export prompt as markdown file
/prompt import <file>        - Import prompt from markdown file
```

### Example Usage

```
> /prompt list --category=code-review

Available Prompts (code-review):
  1. elixir-credo-review    Credo-style code review for Elixir
  2. my-code-review         My custom code review prompt
  3. security-review        Security-focused code review

> /prompt use my-code-review

[Prompt loaded: My Code Review Prompt v1.0.0]
Variables required: code (string)
Variables optional: context (string, default: "No additional context")

Paste your code or type to continue...
```

## Default Categories for Coding

### Domain Categories (Hierarchical)

```
coding/
├── code-generation/
│   ├── scaffolding
│   ├── boilerplate
│   └── implementation
├── code-review/
│   ├── style-review
│   ├── security-review
│   └── performance-review
├── debugging/
│   ├── error-analysis
│   ├── stack-trace
│   └── root-cause
├── refactoring/
│   ├── extract-function
│   ├── rename
│   └── restructure
├── testing/
│   ├── unit-test
│   ├── integration-test
│   └── property-test
├── documentation/
│   ├── api-docs
│   ├── readme
│   └── inline-comments
└── architecture/
    ├── design-review
    ├── pattern-selection
    └── dependency-analysis

elixir/
├── otp/
│   ├── genserver
│   ├── supervisor
│   └── application
├── phoenix/
│   ├── liveview
│   ├── channels
│   └── controllers
├── ecto/
│   ├── schemas
│   ├── queries
│   └── migrations
├── ash/
│   ├── resources
│   ├── actions
│   └── policies
└── mix/
    ├── tasks
    └── releases
```

### Task Categories

```
generation      - Create new content
transformation  - Convert between formats
evaluation      - Assess quality/correctness
extraction      - Pull information from content
summarization   - Condense content
classification  - Categorize/label
reasoning       - Logical deduction
validation      - Verify correctness
explanation     - Explain concepts/code
```

### Technique Categories

```
zero-shot           - No examples
few-shot            - With examples
chain-of-thought    - Step-by-step reasoning
tree-of-thought     - Multiple reasoning paths
self-consistency    - Multiple solutions, select best
react               - Reasoning + tool use
reflection          - Self-critique
role-play           - Persona-based
structured-output   - Enforced format (JSON, etc.)
```

### Complexity Categories

```
simple        - Single-turn, straightforward
intermediate  - Multi-step, moderate complexity
advanced      - Complex reasoning required
expert        - Domain expertise needed
```

### Audience Categories

```
beginner      - New to the domain
practitioner  - Working professional
advanced      - Deep expertise
developer     - Software developers specifically
```

## Elixir Implementation

### Module Structure

```
lib/jido_code/
├── prompt/
│   ├── prompt.ex           # Core Prompt struct and functions
│   ├── frontmatter.ex      # YAML parsing and validation
│   ├── rdf_mapper.ex       # Prompt ↔ RDF conversion
│   ├── repository.ex       # Triplestore CRUD operations
│   ├── category.ex         # Category management
│   ├── variable.ex         # Variable interpolation
│   └── defaults.ex         # Default categories and prompts
├── tui/
│   └── commands/
│       └── prompt_command.ex  # TUI command handlers
└── knowledge/
    └── sparql/
        └── prompt_queries.ex  # SPARQL query templates
```

### Core Prompt Struct

```elixir
defmodule JidoCode.Prompt do
  @moduledoc """
  Core prompt structure with frontmatter support.
  """

  use TypedStruct

  typedstruct do
    field :id, String.t(), enforce: true
    field :name, String.t(), enforce: true
    field :type, prompt_type(), default: :system
    field :slug, String.t()
    field :description, String.t()
    field :content, String.t(), enforce: true
    field :version, String.t(), default: "1.0.0"
    field :categories, categories(), default: %{}
    field :variables, [variable()], default: []
    field :target, target(), default: %{}
    field :tags, [String.t()], default: []
    field :created_at, DateTime.t()
    field :modified_at, DateTime.t()
    field :author, String.t()
    field :uri, String.t()  # RDF URI
  end

  @type prompt_type :: :system | :user | :assistant | :meta | :fragment | :tool | :validation

  @type categories :: %{
    optional(:domain) => String.t() | [String.t()],
    optional(:task) => String.t(),
    optional(:technique) => String.t(),
    optional(:complexity) => String.t(),
    optional(:audience) => String.t()
  }

  @type variable :: %{
    name: String.t(),
    type: String.t(),
    required: boolean(),
    default: String.t() | nil,
    description: String.t() | nil
  }

  @type target :: %{
    optional(:language) => String.t(),
    optional(:framework) => String.t() | [String.t()],
    optional(:model) => String.t(),
    optional(:model_family) => String.t(),
    optional(:min_context) => integer()
  }

  @doc """
  Parse a markdown string with frontmatter into a Prompt struct.
  """
  @spec from_markdown(String.t()) :: {:ok, t()} | {:error, term()}
  def from_markdown(markdown) do
    with {:ok, frontmatter, content} <- Frontmatter.parse(markdown),
         {:ok, prompt} <- build_from_frontmatter(frontmatter, content) do
      {:ok, prompt}
    end
  end

  @doc """
  Serialize a Prompt struct to markdown with frontmatter.
  """
  @spec to_markdown(t()) :: String.t()
  def to_markdown(%__MODULE__{} = prompt) do
    frontmatter = build_frontmatter(prompt)
    yaml = YamlElixir.dump(frontmatter)
    
    """
    ---
    #{yaml}
    ---

    #{prompt.content}
    """
  end

  @doc """
  Interpolate variables into prompt content.
  """
  @spec interpolate(t(), map()) :: {:ok, String.t()} | {:error, term()}
  def interpolate(%__MODULE__{} = prompt, variables) do
    with :ok <- validate_required_variables(prompt, variables) do
      content = 
        prompt.content
        |> interpolate_variables(variables, prompt.variables)
      
      {:ok, content}
    end
  end

  defp interpolate_variables(content, values, variable_defs) do
    Enum.reduce(variable_defs, content, fn var_def, acc ->
      value = Map.get(values, var_def.name) || var_def[:default] || ""
      
      # Support multiple template syntaxes
      acc
      |> String.replace("{{#{var_def.name}}}", value)
      |> String.replace("${#{var_def.name}}", value)
      |> String.replace("<#{var_def.name}>", value)
    end)
  end
end
```

### Frontmatter Parser

```elixir
defmodule JidoCode.Prompt.Frontmatter do
  @moduledoc """
  Parse and validate YAML frontmatter from markdown prompts.
  """

  @frontmatter_regex ~r/\A---\n(.+?)\n---\n(.*)\z/s

  @required_fields [:id, :name, :type]
  
  @valid_types ~w(system user assistant meta fragment tool validation)

  @doc """
  Parse markdown with frontmatter into {frontmatter_map, content}.
  """
  @spec parse(String.t()) :: {:ok, map(), String.t()} | {:error, term()}
  def parse(markdown) do
    case Regex.run(@frontmatter_regex, markdown) do
      [_, yaml, content] ->
        with {:ok, frontmatter} <- YamlElixir.read_from_string(yaml),
             :ok <- validate_frontmatter(frontmatter) do
          {:ok, normalize_frontmatter(frontmatter), String.trim(content)}
        end
      
      nil ->
        {:error, :no_frontmatter}
    end
  end

  defp validate_frontmatter(fm) do
    cond do
      missing_required?(fm) ->
        {:error, {:missing_required, missing_fields(fm)}}
      
      invalid_type?(fm) ->
        {:error, {:invalid_type, fm["type"]}}
      
      true ->
        :ok
    end
  end

  defp missing_required?(fm) do
    Enum.any?(@required_fields, &(!Map.has_key?(fm, to_string(&1))))
  end

  defp missing_fields(fm) do
    Enum.filter(@required_fields, &(!Map.has_key?(fm, to_string(&1))))
  end

  defp invalid_type?(fm) do
    fm["type"] && fm["type"] not in @valid_types
  end

  defp normalize_frontmatter(fm) do
    fm
    |> normalize_keys()
    |> normalize_categories()
    |> normalize_variables()
    |> normalize_target()
    |> set_defaults()
  end

  defp normalize_keys(fm) do
    Map.new(fm, fn {k, v} -> {String.to_atom(k), v} end)
  end

  defp normalize_categories(%{categories: cats} = fm) when is_map(cats) do
    normalized = Map.new(cats, fn {k, v} -> 
      {String.to_atom(k), normalize_category_value(v)}
    end)
    %{fm | categories: normalized}
  end
  defp normalize_categories(fm), do: Map.put(fm, :categories, %{})

  defp normalize_category_value(v) when is_list(v), do: v
  defp normalize_category_value(v) when is_binary(v), do: [v]
  defp normalize_category_value(v), do: v

  defp normalize_variables(%{variables: vars} = fm) when is_list(vars) do
    normalized = Enum.map(vars, fn var ->
      %{
        name: var["name"],
        type: var["type"] || "string",
        required: var["required"] || false,
        default: var["default"],
        description: var["description"]
      }
    end)
    %{fm | variables: normalized}
  end
  defp normalize_variables(fm), do: Map.put(fm, :variables, [])

  defp normalize_target(%{target: target} = fm) when is_map(target) do
    normalized = Map.new(target, fn {k, v} -> {String.to_atom(k), v} end)
    %{fm | target: normalized}
  end
  defp normalize_target(fm), do: Map.put(fm, :target, %{})

  defp set_defaults(fm) do
    now = DateTime.utc_now()
    
    fm
    |> Map.put_new(:slug, fm[:id])
    |> Map.put_new(:version, "1.0.0")
    |> Map.put_new(:created_at, now)
    |> Map.put_new(:modified_at, now)
    |> Map.put_new(:author, "user")
  end
end
```

### RDF Mapper

```elixir
defmodule JidoCode.Prompt.RDFMapper do
  @moduledoc """
  Convert between Prompt structs and RDF triples.
  """

  alias RDF.{Graph, IRI, Literal, XSD}
  
  @jido_ns "https://jido.ai/ontology#"
  @user_prompt_ns "https://jido.ai/user/prompts/"

  @type_mapping %{
    system: "SystemPrompt",
    user: "UserPrompt",
    assistant: "AssistantPrompt",
    meta: "MetaPrompt",
    fragment: "PromptFragment",
    tool: "ToolPrompt",
    validation: "ValidationPrompt"
  }

  @doc """
  Convert a Prompt struct to RDF triples.
  """
  @spec to_rdf(JidoCode.Prompt.t()) :: RDF.Graph.t()
  def to_rdf(%JidoCode.Prompt{} = prompt) do
    prompt_uri = prompt_uri(prompt.id)
    content_uri = content_uri(prompt.id)
    version_uri = version_uri(prompt.id, prompt.version)

    Graph.new()
    |> add_prompt_triples(prompt, prompt_uri)
    |> add_content_triples(prompt, prompt_uri, content_uri)
    |> add_version_triples(prompt, prompt_uri, version_uri)
    |> add_variable_triples(prompt, prompt_uri)
    |> add_category_triples(prompt, prompt_uri)
    |> add_target_triples(prompt, prompt_uri)
    |> add_tag_triples(prompt, prompt_uri)
  end

  @doc """
  Convert RDF triples to a Prompt struct.
  """
  @spec from_rdf(RDF.Graph.t(), String.t()) :: {:ok, JidoCode.Prompt.t()} | {:error, term()}
  def from_rdf(graph, prompt_id) do
    prompt_uri = prompt_uri(prompt_id)
    
    with {:ok, type} <- get_prompt_type(graph, prompt_uri),
         {:ok, name} <- get_literal(graph, prompt_uri, jido("promptName")),
         {:ok, content} <- get_content(graph, prompt_uri) do
      prompt = %JidoCode.Prompt{
        id: prompt_id,
        uri: to_string(prompt_uri),
        name: name,
        type: type,
        slug: get_literal!(graph, prompt_uri, jido("promptSlug"), prompt_id),
        description: get_literal!(graph, prompt_uri, jido("promptDescription"), nil),
        content: content,
        version: get_current_version(graph, prompt_uri),
        categories: get_categories(graph, prompt_uri),
        variables: get_variables(graph, prompt_uri),
        target: get_target(graph, prompt_uri),
        tags: get_tags(graph, prompt_uri),
        created_at: get_datetime(graph, prompt_uri, jido("promptCreatedAt")),
        modified_at: get_datetime(graph, prompt_uri, jido("promptModifiedAt")),
        author: get_author(graph, prompt_uri)
      }
      
      {:ok, prompt}
    end
  end

  # URI builders
  defp prompt_uri(id), do: IRI.new!("#{@user_prompt_ns}#{id}")
  defp content_uri(id), do: IRI.new!("#{@user_prompt_ns}#{id}/content")
  defp version_uri(id, version), do: IRI.new!("#{@user_prompt_ns}#{id}/v/#{version}")
  defp variable_uri(prompt_id, var_name), do: IRI.new!("#{@user_prompt_ns}#{prompt_id}/var/#{var_name}")
  
  defp jido(term), do: IRI.new!("#{@jido_ns}#{term}")

  # Triple builders
  defp add_prompt_triples(graph, prompt, uri) do
    type_class = Map.get(@type_mapping, prompt.type, "Prompt")
    
    graph
    |> Graph.add({uri, RDF.type(), jido(type_class)})
    |> Graph.add({uri, jido("promptId"), Literal.new(prompt.id)})
    |> Graph.add({uri, jido("promptName"), Literal.new(prompt.name)})
    |> maybe_add(uri, jido("promptSlug"), prompt.slug)
    |> maybe_add(uri, jido("promptDescription"), prompt.description)
    |> maybe_add_datetime(uri, jido("promptCreatedAt"), prompt.created_at)
    |> maybe_add_datetime(uri, jido("promptModifiedAt"), prompt.modified_at)
    |> maybe_add_author(uri, prompt.author)
  end

  defp add_content_triples(graph, prompt, prompt_uri, content_uri) do
    graph
    |> Graph.add({prompt_uri, jido("hasPromptContent"), content_uri})
    |> Graph.add({content_uri, RDF.type(), jido("PromptContent")})
    |> Graph.add({content_uri, jido("contentText"), Literal.new(prompt.content)})
    |> Graph.add({content_uri, jido("hasContentFormat"), jido("MarkdownFormat")})
  end

  defp add_version_triples(graph, prompt, prompt_uri, version_uri) do
    graph
    |> Graph.add({prompt_uri, jido("currentPromptVersion"), version_uri})
    |> Graph.add({prompt_uri, jido("hasPromptVersion"), version_uri})
    |> Graph.add({version_uri, RDF.type(), jido("PromptVersion")})
    |> Graph.add({version_uri, jido("versionNumber"), Literal.new(prompt.version)})
    |> Graph.add({version_uri, jido("versionOf"), prompt_uri})
    |> Graph.add({version_uri, jido("hasPromptStatus"), jido("PromptPublished")})
  end

  defp add_variable_triples(graph, prompt, prompt_uri) do
    Enum.reduce(prompt.variables, graph, fn var, g ->
      var_uri = variable_uri(prompt.id, var.name)
      
      g
      |> Graph.add({prompt_uri, jido("hasVariable"), var_uri})
      |> Graph.add({var_uri, RDF.type(), jido("PromptVariable")})
      |> Graph.add({var_uri, jido("variableName"), Literal.new(var.name)})
      |> Graph.add({var_uri, jido("variableType"), Literal.new(var.type)})
      |> Graph.add({var_uri, jido("variableRequired"), Literal.new(var.required)})
      |> maybe_add(var_uri, jido("variableDefault"), var[:default])
      |> maybe_add(var_uri, jido("variableDescription"), var[:description])
    end)
  end

  defp add_category_triples(graph, prompt, prompt_uri) do
    cats = prompt.categories
    
    graph
    |> add_category_list(prompt_uri, jido("hasDomainCategory"), cats[:domain])
    |> add_category_list(prompt_uri, jido("hasTaskCategory"), cats[:task])
    |> add_category_list(prompt_uri, jido("hasTechniqueCategory"), cats[:technique])
    |> add_category_list(prompt_uri, jido("hasComplexityCategory"), cats[:complexity])
    |> add_category_list(prompt_uri, jido("hasAudienceCategory"), cats[:audience])
  end

  defp add_category_list(graph, _uri, _pred, nil), do: graph
  defp add_category_list(graph, uri, pred, cats) when is_list(cats) do
    Enum.reduce(cats, graph, fn cat, g ->
      cat_uri = category_uri(cat)
      Graph.add(g, {uri, pred, cat_uri})
    end)
  end
  defp add_category_list(graph, uri, pred, cat), do: add_category_list(graph, uri, pred, [cat])

  defp category_uri(slug) do
    # Convert slug to category URI (e.g., "code-review" -> jido:CodeReviewDomain)
    camel = slug |> String.split("-") |> Enum.map(&String.capitalize/1) |> Enum.join("")
    jido("#{camel}Domain")
  end

  defp add_target_triples(graph, prompt, prompt_uri) do
    target = prompt.target
    
    graph
    |> maybe_add(prompt_uri, jido("targetLanguage"), target[:language])
    |> maybe_add_list(prompt_uri, jido("targetFramework"), target[:framework])
    |> maybe_add(prompt_uri, jido("targetModel"), target[:model])
    |> maybe_add(prompt_uri, jido("modelFamily"), target[:model_family])
    |> maybe_add_integer(prompt_uri, jido("minContextLength"), target[:min_context])
  end

  defp add_tag_triples(graph, prompt, prompt_uri) do
    Enum.reduce(prompt.tags, graph, fn tag, g ->
      Graph.add(g, {prompt_uri, jido("hasPromptTag"), Literal.new(tag)})
    end)
  end

  # Helper functions
  defp maybe_add(graph, _s, _p, nil), do: graph
  defp maybe_add(graph, s, p, o), do: Graph.add(graph, {s, p, Literal.new(o)})

  defp maybe_add_list(graph, _s, _p, nil), do: graph
  defp maybe_add_list(graph, s, p, list) when is_list(list) do
    Enum.reduce(list, graph, fn item, g -> Graph.add(g, {s, p, Literal.new(item)}) end)
  end
  defp maybe_add_list(graph, s, p, item), do: Graph.add(graph, {s, p, Literal.new(item)})

  defp maybe_add_integer(graph, _s, _p, nil), do: graph
  defp maybe_add_integer(graph, s, p, i), do: Graph.add(graph, {s, p, Literal.new(i, datatype: XSD.integer())})

  defp maybe_add_datetime(graph, _s, _p, nil), do: graph
  defp maybe_add_datetime(graph, s, p, dt), do: Graph.add(graph, {s, p, Literal.new(dt)})

  defp maybe_add_author(graph, uri, nil), do: graph
  defp maybe_add_author(graph, uri, author) do
    author_uri = IRI.new!("https://jido.ai/agents/#{author}")
    Graph.add(graph, {uri, jido("promptCreatedBy"), author_uri})
  end
end
```

### Repository (Triplestore Operations)

```elixir
defmodule JidoCode.Prompt.Repository do
  @moduledoc """
  CRUD operations for prompts in the triplestore.
  """

  alias JidoCode.Prompt
  alias JidoCode.Prompt.RDFMapper
  alias JidoCode.Knowledge.Store

  @user_prompt_ns "https://jido.ai/user/prompts/"

  @doc """
  Create a new prompt in the triplestore.
  """
  @spec create(Prompt.t()) :: {:ok, Prompt.t()} | {:error, term()}
  def create(%Prompt{} = prompt) do
    with :ok <- validate_unique_id(prompt.id),
         graph <- RDFMapper.to_rdf(prompt),
         :ok <- Store.insert(graph) do
      {:ok, %{prompt | uri: "#{@user_prompt_ns}#{prompt.id}"}}
    end
  end

  @doc """
  Get a prompt by ID or slug.
  """
  @spec get(String.t()) :: {:ok, Prompt.t()} | {:error, :not_found}
  def get(id_or_slug) do
    query = """
    PREFIX jido: <https://jido.ai/ontology#>
    
    SELECT ?id WHERE {
      ?prompt a ?type .
      ?type rdfs:subClassOf* jido:Prompt .
      {
        ?prompt jido:promptId "#{id_or_slug}" .
      } UNION {
        ?prompt jido:promptSlug "#{id_or_slug}" .
      }
      ?prompt jido:promptId ?id .
    }
    LIMIT 1
    """
    
    case Store.query(query) do
      {:ok, [%{"id" => id}]} ->
        graph = Store.describe("#{@user_prompt_ns}#{id}")
        RDFMapper.from_rdf(graph, id)
      
      {:ok, []} ->
        {:error, :not_found}
      
      error ->
        error
    end
  end

  @doc """
  Update an existing prompt.
  """
  @spec update(String.t(), map()) :: {:ok, Prompt.t()} | {:error, term()}
  def update(id, changes) do
    with {:ok, existing} <- get(id),
         updated <- apply_changes(existing, changes),
         updated <- %{updated | modified_at: DateTime.utc_now()},
         :ok <- delete(id),
         {:ok, prompt} <- create(updated) do
      {:ok, prompt}
    end
  end

  @doc """
  Delete a prompt by ID.
  """
  @spec delete(String.t()) :: :ok | {:error, term()}
  def delete(id) do
    uri = "#{@user_prompt_ns}#{id}"
    
    # Delete all triples where the prompt or its sub-resources are subject
    delete_query = """
    PREFIX jido: <https://jido.ai/ontology#>
    
    DELETE WHERE {
      {
        <#{uri}> ?p ?o .
      } UNION {
        <#{uri}/content> ?p ?o .
      } UNION {
        <#{uri}> jido:hasPromptVersion ?v .
        ?v ?p ?o .
      } UNION {
        <#{uri}> jido:hasVariable ?var .
        ?var ?p ?o .
      }
    }
    """
    
    Store.update(delete_query)
  end

  @doc """
  List all prompts, optionally filtered by category.
  """
  @spec list(keyword()) :: {:ok, [Prompt.t()]} | {:error, term()}
  def list(opts \\ []) do
    category = Keyword.get(opts, :category)
    limit = Keyword.get(opts, :limit, 100)
    
    query = build_list_query(category, limit)
    
    case Store.query(query) do
      {:ok, results} ->
        prompts = Enum.map(results, fn %{"id" => id} ->
          {:ok, prompt} = get(id)
          prompt
        end)
        {:ok, prompts}
      
      error ->
        error
    end
  end

  @doc """
  Search prompts by text query.
  """
  @spec search(String.t()) :: {:ok, [Prompt.t()]} | {:error, term()}
  def search(query_text) do
    query = """
    PREFIX jido: <https://jido.ai/ontology#>
    
    SELECT DISTINCT ?id WHERE {
      ?prompt a ?type .
      ?type rdfs:subClassOf* jido:Prompt .
      ?prompt jido:promptId ?id .
      
      {
        ?prompt jido:promptName ?name .
        FILTER(CONTAINS(LCASE(?name), LCASE("#{query_text}")))
      } UNION {
        ?prompt jido:promptDescription ?desc .
        FILTER(CONTAINS(LCASE(?desc), LCASE("#{query_text}")))
      } UNION {
        ?prompt jido:hasPromptTag ?tag .
        FILTER(CONTAINS(LCASE(?tag), LCASE("#{query_text}")))
      } UNION {
        ?prompt jido:hasPromptContent ?content .
        ?content jido:contentText ?text .
        FILTER(CONTAINS(LCASE(?text), LCASE("#{query_text}")))
      }
    }
    """
    
    case Store.query(query) do
      {:ok, results} ->
        prompts = Enum.map(results, fn %{"id" => id} ->
          {:ok, prompt} = get(id)
          prompt
        end)
        {:ok, prompts}
      
      error ->
        error
    end
  end

  # Private functions
  
  defp validate_unique_id(id) do
    case get(id) do
      {:ok, _} -> {:error, {:already_exists, id}}
      {:error, :not_found} -> :ok
      error -> error
    end
  end

  defp apply_changes(prompt, changes) do
    Enum.reduce(changes, prompt, fn {key, value}, acc ->
      Map.put(acc, key, value)
    end)
  end

  defp build_list_query(nil, limit) do
    """
    PREFIX jido: <https://jido.ai/ontology#>
    
    SELECT ?id ?name WHERE {
      ?prompt a ?type .
      ?type rdfs:subClassOf* jido:Prompt .
      ?prompt jido:promptId ?id .
      ?prompt jido:promptName ?name .
    }
    ORDER BY ?name
    LIMIT #{limit}
    """
  end

  defp build_list_query(category, limit) do
    cat_uri = category_to_uri(category)
    
    """
    PREFIX jido: <https://jido.ai/ontology#>
    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
    
    SELECT ?id ?name WHERE {
      ?prompt a ?type .
      ?type rdfs:subClassOf* jido:Prompt .
      ?prompt jido:promptId ?id .
      ?prompt jido:promptName ?name .
      ?prompt jido:hasDomainCategory ?cat .
      ?cat skos:broader* <#{cat_uri}> .
    }
    ORDER BY ?name
    LIMIT #{limit}
    """
  end

  defp category_to_uri(slug) do
    camel = slug |> String.split("-") |> Enum.map(&String.capitalize/1) |> Enum.join("")
    "https://jido.ai/ontology##{camel}Domain"
  end
end
```

### TUI Command Handler

```elixir
defmodule JidoCode.TUI.Commands.PromptCommand do
  @moduledoc """
  TUI command handlers for prompt management.
  """

  alias JidoCode.Prompt
  alias JidoCode.Prompt.Repository

  @behaviour JidoCode.TUI.Command

  @impl true
  def name, do: "prompt"

  @impl true
  def description, do: "Manage and use prompts"

  @impl true
  def usage do
    """
    /prompt use <slug>           - Load a prompt into the current context
    /prompt list [--category=X]  - List available prompts
    /prompt show <slug>          - Display prompt details
    /prompt new                  - Create a new prompt interactively
    /prompt edit <slug>          - Edit an existing prompt
    /prompt delete <slug>        - Delete a prompt
    /prompt search <query>       - Search prompts
    /prompt categories           - List available categories
    /prompt import <file>        - Import prompt from markdown file
    /prompt export <slug>        - Export prompt to markdown file
    """
  end

  @impl true
  def execute(["use", slug], context) do
    with {:ok, prompt} <- Repository.get(slug),
         {:ok, content} <- maybe_collect_variables(prompt, context) do
      # Inject the interpolated prompt into the conversation context
      {:ok, %{
        action: :inject_prompt,
        prompt: prompt,
        content: content,
        message: format_prompt_loaded(prompt)
      }}
    else
      {:error, :not_found} ->
        {:error, "Prompt '#{slug}' not found. Use /prompt list to see available prompts."}
      
      {:error, reason} ->
        {:error, "Failed to load prompt: #{inspect(reason)}"}
    end
  end

  def execute(["list" | opts], _context) do
    category = parse_option(opts, "category")
    
    case Repository.list(category: category) do
      {:ok, prompts} ->
        {:ok, %{
          action: :display,
          content: format_prompt_list(prompts, category)
        }}
      
      {:error, reason} ->
        {:error, "Failed to list prompts: #{inspect(reason)}"}
    end
  end

  def execute(["show", slug], _context) do
    case Repository.get(slug) do
      {:ok, prompt} ->
        {:ok, %{
          action: :display,
          content: format_prompt_details(prompt)
        }}
      
      {:error, :not_found} ->
        {:error, "Prompt '#{slug}' not found."}
    end
  end

  def execute(["new"], context) do
    {:ok, %{
      action: :interactive,
      handler: &handle_new_prompt/2,
      initial_state: %{step: :get_id},
      message: "Creating new prompt. Enter prompt ID (slug):"
    }}
  end

  def execute(["edit", slug], context) do
    case Repository.get(slug) do
      {:ok, prompt} ->
        markdown = Prompt.to_markdown(prompt)
        
        {:ok, %{
          action: :edit,
          content: markdown,
          handler: &handle_edit_save/2,
          state: %{original_id: slug},
          message: "Editing prompt '#{slug}'. Modify and save when done."
        }}
      
      {:error, :not_found} ->
        {:error, "Prompt '#{slug}' not found."}
    end
  end

  def execute(["delete", slug], _context) do
    {:ok, %{
      action: :confirm,
      message: "Are you sure you want to delete prompt '#{slug}'? (yes/no)",
      handler: fn
        "yes" -> 
          case Repository.delete(slug) do
            :ok -> {:ok, "Prompt '#{slug}' deleted."}
            {:error, reason} -> {:error, "Failed to delete: #{inspect(reason)}"}
          end
        _ -> 
          {:ok, "Deletion cancelled."}
      end
    }}
  end

  def execute(["search", query], _context) do
    case Repository.search(query) do
      {:ok, prompts} ->
        {:ok, %{
          action: :display,
          content: format_search_results(prompts, query)
        }}
      
      {:error, reason} ->
        {:error, "Search failed: #{inspect(reason)}"}
    end
  end

  def execute(["categories"], _context) do
    {:ok, %{
      action: :display,
      content: format_categories()
    }}
  end

  def execute(["import", file_path], _context) do
    with {:ok, markdown} <- File.read(file_path),
         {:ok, prompt} <- Prompt.from_markdown(markdown),
         {:ok, saved} <- Repository.create(prompt) do
      {:ok, %{
        action: :display,
        content: "Imported prompt '#{saved.name}' (#{saved.id})"
      }}
    else
      {:error, :enoent} ->
        {:error, "File not found: #{file_path}"}
      
      {:error, reason} ->
        {:error, "Import failed: #{inspect(reason)}"}
    end
  end

  def execute(["export", slug], _context) do
    with {:ok, prompt} <- Repository.get(slug) do
      markdown = Prompt.to_markdown(prompt)
      filename = "#{slug}.md"
      
      {:ok, %{
        action: :save_file,
        content: markdown,
        filename: filename,
        message: "Exported to #{filename}"
      }}
    end
  end

  def execute(_, _context) do
    {:error, "Unknown subcommand. Use /prompt for help."}
  end

  # Private helpers

  defp maybe_collect_variables(prompt, context) do
    required = Enum.filter(prompt.variables, & &1.required)
    
    if Enum.empty?(required) do
      Prompt.interpolate(prompt, %{})
    else
      # Return action to collect variables interactively
      {:collect_variables, required}
    end
  end

  defp format_prompt_loaded(prompt) do
    vars = prompt.variables
    required = Enum.filter(vars, & &1.required) |> Enum.map(& &1.name)
    optional = Enum.reject(vars, & &1.required) |> Enum.map(& "#{&1.name} (default: #{&1[:default] || "none"})")
    
    """
    [Prompt loaded: #{prompt.name} v#{prompt.version}]
    #{if length(required) > 0, do: "Variables required: #{Enum.join(required, ", ")}", else: ""}
    #{if length(optional) > 0, do: "Variables optional: #{Enum.join(optional, ", ")}", else: ""}
    """
  end

  defp format_prompt_list(prompts, category) do
    header = if category, do: "Prompts (#{category}):", else: "Available Prompts:"
    
    items = prompts
    |> Enum.with_index(1)
    |> Enum.map(fn {p, i} -> 
      "  #{i}. #{String.pad_trailing(p.slug, 25)} #{p.name}"
    end)
    |> Enum.join("\n")
    
    """
    #{header}
    #{items}
    
    Use /prompt show <slug> for details, /prompt use <slug> to load.
    """
  end

  defp format_prompt_details(prompt) do
    categories = prompt.categories
    |> Enum.map(fn {k, v} -> "  #{k}: #{inspect(v)}" end)
    |> Enum.join("\n")
    
    variables = prompt.variables
    |> Enum.map(fn v -> 
      req = if v.required, do: "*", else: ""
      "  #{v.name}#{req} (#{v.type})#{if v[:default], do: " = #{v[:default]}", else: ""}"
    end)
    |> Enum.join("\n")
    
    """
    ═══════════════════════════════════════════════════
    #{prompt.name}
    ═══════════════════════════════════════════════════
    ID:          #{prompt.id}
    Slug:        #{prompt.slug}
    Type:        #{prompt.type}
    Version:     #{prompt.version}
    Description: #{prompt.description || "(none)"}
    
    Categories:
    #{categories}
    
    Variables (* = required):
    #{if variables == "", do: "  (none)", else: variables}
    
    Tags: #{Enum.join(prompt.tags, ", ")}
    
    Target:
      Language: #{prompt.target[:language] || "any"}
      Model:    #{prompt.target[:model] || "any"}
    
    Created:  #{prompt.created_at}
    Modified: #{prompt.modified_at}
    Author:   #{prompt.author}
    ═══════════════════════════════════════════════════
    
    Content Preview:
    #{String.slice(prompt.content, 0, 500)}#{if String.length(prompt.content) > 500, do: "...", else: ""}
    """
  end

  defp format_search_results(prompts, query) do
    if Enum.empty?(prompts) do
      "No prompts found matching '#{query}'."
    else
      format_prompt_list(prompts, nil)
    end
  end

  defp format_categories do
    """
    Available Categories:
    
    Domain:
      coding, code-generation, code-review, debugging, refactoring, testing
      documentation, architecture, elixir, otp, phoenix, ecto, ash
    
    Task:
      generation, transformation, evaluation, extraction, summarization
      classification, reasoning, validation, explanation
    
    Technique:
      zero-shot, few-shot, chain-of-thought, tree-of-thought
      self-consistency, react, reflection, role-play, structured-output
    
    Complexity:
      simple, intermediate, advanced, expert
    
    Audience:
      beginner, practitioner, advanced, developer
    
    Use /prompt category new <name> to create a custom category.
    """
  end

  defp parse_option(opts, name) do
    Enum.find_value(opts, fn opt ->
      case String.split(opt, "=", parts: 2) do
        ["--#{^name}", value] -> value
        _ -> nil
      end
    end)
  end
end
```

### Default Categories Module

```elixir
defmodule JidoCode.Prompt.Defaults do
  @moduledoc """
  Default categories and seed prompts for JidoCode.
  """

  alias JidoCode.Knowledge.Store

  @default_categories_ttl """
  @base <https://jido.ai/ontology#> .
  @prefix jido: <https://jido.ai/ontology#> .
  @prefix skos: <http://www.w3.org/2004/02/skos/core#> .

  # User Category Scheme (separate from system defaults)
  jido:UserPromptCategoryScheme a jido:PromptCategoryScheme, skos:ConceptScheme ;
      rdfs:label "User Prompt Categories" .

  # Allow users to extend these
  jido:UserDomainCategory a owl:Class ;
      rdfs:subClassOf jido:DomainCategory ;
      rdfs:label "User Domain Category" .

  jido:UserTaskCategory a owl:Class ;
      rdfs:subClassOf jido:TaskCategory ;
      rdfs:label "User Task Category" .
  """

  @doc """
  Initialize default categories in the triplestore.
  """
  def init_defaults do
    # Load the base taxonomy
    Store.load_file("priv/ontology/jido-prompt-taxonomy.ttl")
    
    # Add user extension points
    Store.load_string(@default_categories_ttl, format: :turtle)
    
    :ok
  end

  @doc """
  Create a new user-defined category.
  """
  def create_category(name, type, parent \\ nil) do
    slug = Slug.slugify(name)
    uri = "https://jido.ai/user/categories/#{slug}"
    parent_uri = if parent, do: category_uri(parent), else: type_top_concept(type)
    type_class = type_to_class(type)
    
    ttl = """
    @prefix jido: <https://jido.ai/ontology#> .
    @prefix skos: <http://www.w3.org/2004/02/skos/core#> .
    
    <#{uri}> a jido:#{type_class} ;
        skos:prefLabel "#{name}" ;
        skos:broader <#{parent_uri}> ;
        skos:inScheme jido:UserPromptCategoryScheme .
    """
    
    Store.load_string(ttl, format: :turtle)
  end

  defp type_to_class(:domain), do: "UserDomainCategory"
  defp type_to_class(:task), do: "UserTaskCategory"
  defp type_to_class(:technique), do: "TechniqueCategory"
  defp type_to_class(:complexity), do: "ComplexityCategory"
  defp type_to_class(:audience), do: "AudienceCategory"

  defp type_top_concept(:domain), do: "https://jido.ai/ontology#DomainCategories"
  defp type_top_concept(:task), do: "https://jido.ai/ontology#TaskCategories"
  defp type_top_concept(:technique), do: "https://jido.ai/ontology#TechniqueCategories"
  defp type_top_concept(:complexity), do: "https://jido.ai/ontology#ComplexityCategories"
  defp type_top_concept(:audience), do: "https://jido.ai/ontology#AudienceCategories"

  defp category_uri(slug) do
    camel = slug |> String.split("-") |> Enum.map(&String.capitalize/1) |> Enum.join("")
    "https://jido.ai/ontology##{camel}Domain"
  end
end
```

## Complete Workflow Examples

### 1. Creating a New Prompt via TUI

```
> /prompt new

Creating new prompt. Enter prompt ID (slug):
> my-elixir-review

Enter prompt name:
> My Elixir Code Review

Select type (system/user/assistant/meta/fragment/tool/validation):
> system

Enter description (optional):
> Custom code review focused on OTP patterns

Select categories (comma-separated):
  Domain options: coding, code-review, elixir, otp, phoenix, ash...
> code-review, elixir, otp

  Task options: generation, evaluation, extraction...
> evaluation

  Technique options: zero-shot, few-shot, chain-of-thought...
> role-play

  Complexity options: simple, intermediate, advanced, expert
> intermediate

Enter tags (comma-separated):
> elixir, review, otp, custom

Define variables? (y/n):
> y

Variable 1 name (or 'done'):
> code

Variable 1 type (string/number/boolean):
> string

Variable 1 required? (y/n):
> y

Variable 1 description:
> The Elixir code to review

Variable 2 name (or 'done'):
> done

Now enter the prompt content (markdown). End with '---END---':

# Elixir Code Review

Review this Elixir code focusing on OTP patterns:

```elixir
{{code}}
```

Check for:
1. Proper GenServer usage
2. Supervisor tree design
3. Error handling with tagged tuples
4. Process isolation

---END---

✓ Prompt 'my-elixir-review' created successfully!
```

### 2. Using a Prompt

```
> /prompt use my-elixir-review

[Prompt loaded: My Elixir Code Review v1.0.0]
Variables required: code (string)

Paste your code:
> defmodule MyServer do
>   use GenServer
>   
>   def start_link(opts) do
>     GenServer.start_link(__MODULE__, opts)
>   end
>   ...
> end

[Prompt injected into context]

# Elixir Code Review

Review this Elixir code focusing on OTP patterns:

```elixir
defmodule MyServer do
  use GenServer
  ...
```
...

[Claude responds with review]
```

### 3. Import/Export Workflow

```bash
# Create a prompt file locally
cat > my-prompt.md << 'EOF'
---
id: security-review
name: Security Code Review
type: system
categories:
  domain: [code-review, security]
  task: evaluation
variables:
  - name: code
    type: string
    required: true
tags: [security, review]
---

# Security Review

Analyze this code for security vulnerabilities:

```
{{code}}
```

Focus on:
- Input validation
- Injection risks
- Authentication/authorization
- Data exposure
EOF
```

```
> /prompt import ~/my-prompt.md
Imported prompt 'Security Code Review' (security-review)

> /prompt export security-review
Exported to security-review.md
```

## Summary

This design provides:

1. **Frontmatter-based prompt definition** - Intuitive YAML frontmatter mapping directly to ontology properties
2. **Triplestore persistence** - Full RDF storage with SPARQL querying
3. **TUI command interface** - Complete CRUD operations via `/prompt` commands
4. **User-defined categories** - Extensible SKOS taxonomy with sensible coding defaults
5. **Variable interpolation** - Multiple template syntaxes (`{{var}}`, `${var}`, `<var>`)
6. **Version tracking** - Semantic versioning with full history
7. **Import/Export** - Markdown file interchange format
