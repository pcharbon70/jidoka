

# Designing an OWL Ontology for Conversation History

To enhance the foundational architecture of `jidoka` with a robust, semantically rich record of interactions, we propose a new OWL ontology specifically for conversation history. This ontology will meticulously capture the nuances of each interaction within a work-session, including user prompts, any tool invocations by the AI agent, their corresponding results, and the agent's final answers. By structuring this information, we enable powerful querying, analysis, and retrieval of past conversations, significantly improving the agent's ability to maintain context, learn from interactions, and provide consistent, informed support over time. This conversation history will be intrinsically linked to the `jido:WorkSession` concept, ensuring that all conversational data is properly scoped within its originating session.

This new ontology, which we'll call the "Conversation History Ontology," will be a crucial addition to the system's semantic layer. It will complement the existing Jido ontology (used for long-term memories) and the Elixir ontology (used for codebase representation), all residing within the knowledge-graph engine. The structured nature of this conversation history will allow agents to do more than just recall past text; they will be able to understand the *structure* of past interactions, such as which tools were used in response to a particular prompt and what outcomes those tool usages produced.

## The Conversation History Ontology Design

The ontology will be defined in a new file, say `conversation-history.ttl`, and will introduce several core classes and properties to model conversational flows. We'll use the prefix `ch:` for this new ontology (e.g., `https://jido.ai/ontology/conversation-history#`). It will also leverage concepts from the Jido core ontology, particularly `jido:WorkSession` and `jido:MemoryItem`.

```turtle
@prefix : <https://jido.ai/ontology/conversation-history#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix jido: <https://jido.ai/ontology#> . # Base URI for Jido ontologies
# @prefix jido_action: <https://jido.ai/ontology/action#> . # Placeholder if Jido Actions are formally modeled

<https://jido.ai/ontology/conversation-history> a owl:Ontology ;
    rdfs:label "Jido Conversation History Ontology" ;
    rdfs:comment "An ontology for representing detailed conversation history within Jido work-sessions, including prompts, tool usage, and answers." ;
    owl:versionInfo "1.0.0" ;
    # Consider importing Jido core if WorkSession is directly referenced.
    # owl:imports <https://jido.ai/ontology/jido-core.ttl> ;
    .

# --- Core Classes ---

:Conversation a owl:Class ;
    rdfs:label "Conversation" ;
    rdfs:comment "Represents a sequence of conversation turns within a specific work-session." ;
    rdfs:subClassOf jido:MemoryItem ; # A conversation is a type of persistent memory.
    .

:ConversationTurn a owl:Class ;
    rdfs:label "Conversation Turn" ;
    rdfs:comment "A single prompt-answer cycle, including any intermediate tool invocations and their results." ;
    rdfs:subClassOf jido:MemoryItem ; # Each turn is also a distinct memory item.
    .

:Prompt a owl:Class ;
    rdfs:label "Prompt" ;
    rdfs:comment "The user's input text for a conversation turn." ;
    .

:Answer a owl:Class ;
    rdfs:label "Answer" ;
    rdfs:comment "The assistant's final textual response to a prompt in a conversation turn." ;
    .

:ToolInvocation a owl:Class ;
    rdfs:label "Tool Invocation" ;
    rdfs:comment "Represents a single call to a tool by the assistant during a conversation turn." ;
    rdfs:subClassOf jido:MemoryItem . # Tool invocations are also memory items.
    .

:ToolResult a owl:Class ;
    rdfs:label "Tool Result" ;
    rdfs:comment "Represents the outcome of a tool invocation." ;
    rdfs:subClassOf jido:MemoryItem . # Tool results are memory items.
    .

# --- Object Properties ---

:associatedWithSession a owl:ObjectProperty ;
    rdfs:label "associated with session" ;
    rdfs:comment "Links a conversation to the work-session in which it occurred." ;
    rdfs:domain :Conversation ;
    rdfs:range jido:WorkSession ;
    .

:hasTurn a owl:ObjectProperty ;
    rdfs:label "has turn" ;
    rdfs:comment "Links a conversation to one of its constituent turns." ;
    rdfs:domain :Conversation ;
    rdfs:range :ConversationTurn ;
    .

:partOfConversation a owl:ObjectProperty ; # Inverse of hasTurn
    rdfs:label "part of conversation" ;
    rdfs:domain :ConversationTurn ;
    rdfs:range :Conversation ;
    owl:inverseOf :hasTurn ;
    .

:hasPrompt a owl:ObjectProperty ;
    rdfs:label "has prompt" ;
    rdfs:comment "Links a conversation turn to its user prompt." ;
    rdfs:domain :ConversationTurn ;
    rdfs:range :Prompt ;
    .

:hasAnswer a owl:ObjectProperty ;
    rdfs:label "has answer" ;
    rdfs:comment "Links a conversation turn to its final assistant answer." ;
    rdfs:domain :ConversationTurn ;
    rdfs:range :Answer ;
    .

:involvesToolInvocation a owl:ObjectProperty ;
    rdfs:label "involves tool invocation" ;
    rdfs:comment "Links a conversation turn to a tool invocation that occurred during it." ;
    rdfs:domain :ConversationTurn ;
    rdfs:range :ToolInvocation ;
    .

:hasResult a owl:ObjectProperty ;
    rdfs:label "has result" ;
    rdfs:comment "Links a tool invocation to its result." ;
    rdfs:domain :ToolInvocation ;
    rdfs:range :ToolResult ;
    .

:usesTool a owl:ObjectProperty ;
    rdfs:label "uses tool" ;
    rdfs:comment "Links a tool invocation to the definition of the tool that was used." ;
    rdfs:domain :ToolInvocation ;
    # The range depends on how Jido models tools/actions.
    # If Jido.Actions are formalized, that would be ideal.
    # For now, we can use a generic capability or a string identifier for the tool.
    # rdfs:range jido:Capability ; # Placeholder, adjust based on Jido's tool model.
    # If tools are Jido.Actions, and if Jido.Action is a class:
    # rdfs:range jido:Action ; # Assuming jido:Action exists or is defined.
    # A pragmatic approach if a formal ontology for tools isn't available:
    rdfs:range rdfs:Resource ; # Or a specific class for tool identifiers if created.
    .

# --- Data Properties ---

:promptText a owl:DatatypeProperty ;
    rdfs:label "prompt text" ;
    rdfs:comment "The textual content of the user's prompt." ;
    rdfs:domain :Prompt ;
    rdfs:range xsd:string ;
    .

:answerText a owl:DatatypeProperty ;
    rdfs:label "answer text" ;
    rdfs:comment "The textual content of the assistant's answer." ;
    rdfs:domain :Answer ;
    rdfs:range xsd:string ;
    .

:invocationParameters a owl:DatatypeProperty ;
    rdfs:label "invocation parameters" ;
    rdfs:comment "The parameters passed to the tool during invocation, serialized as a JSON string." ;
    rdfs:domain :ToolInvocation ;
    rdfs:range xsd:string ;
    .

:resultData a owl:DatatypeProperty ;
    rdfs:label "result data" ;
    rdfs:comment "The data returned by the tool, serialized as a JSON string." ;
    rdfs:domain :ToolResult ;
    rdfs:range xsd:string ;
    .

:timestamp a owl:DatatypeProperty ;
    rdfs:label "timestamp" ;
    rdfs:comment "The timestamp of when an event (prompt, answer, tool invocation, result) occurred." ;
    rdfs:domain [ rdf:type owl:Class ; owl:unionOf ( :Prompt :Answer :ToolInvocation :ToolResult ) ] ;
    rdfs:range xsd:dateTime ;
    .

:turnIndex a owl:DatatypeProperty ;
    rdfs:label "turn index" ;
    rdfs:comment "The zero-based index of the conversation turn within its parent conversation, ensuring order." ;
    rdfs:domain :ConversationTurn ;
    rdfs:range xsd:integer ;
    .

:toolName a owl:DatatypeProperty ; # Alternative/Complement to usesTool if tools are simple strings
    rdfs:label "tool name" ;
    rdfs:comment "The name or identifier of the tool invoked." ;
    rdfs:domain :ToolInvocation ;
    rdfs:range xsd:string ;
    .
```
This ontology provides a comprehensive structure for logging conversations. By making `:Conversation`, `:ConversationTurn`, `:ToolInvocation`, and `:ToolResult` subclasses of `jido:MemoryItem`, we inherently give them properties like `jido:assertedBy`, `jido:hasConfidence`, `jido:hasSourceType`, and `jido:hasTimestamp` (though we also define a specific `ch:timestamp` for fine-grained timing). This allows them to be seamlessly integrated into the long-term memory system and benefit from its provenance tracking. The `jido:hasTimestamp` from the core Jido ontology could be used, or the more specific `ch:timestamp`; consistency in choice would be key. For simplicity, `ch:timestamp` is used here for direct application to conversation events.

## Integration into the Architecture

The conversation history ontology will be integrated into the `jidoka` architecture primarily through the knowledge-graph layer and the agents that interact with it, especially the `LLMOrchestrator` within each work-session.

### Knowledge-Graph Layer and Named Graphs

The instances of this conversation history ontology will reside within the knowledge-graph engine. A new named graph, perhaps `jido:conversation-history`, could be dedicated to storing all conversation data across all sessions. Alternatively, since each `ch:Conversation` is linked to a `jido:WorkSession` (which itself is part of the `jido:long-term-context` graph or a related session-specific graph), conversation triples could be stored within the session's designated graph area if the quad-store supports fine-grained scoping like that. For simplicity and manageability, a dedicated `jido:conversation-history` graph is a good starting point.

The SPARQL client library will be used by agents to insert new conversation data (SPARQL UPDATE) and to query past conversations (SPARQL SELECT/CONSTRUCT).

### Agent Interaction and Data Population

The `LLMOrchestrator` agent within each `Work-Session` will be primarily responsible for populating this conversation history. As it processes user prompts, makes tool calls, and generates answers, it will concurrently create and link the corresponding RDF triples.

Here's a conceptual flow within the `LLMOrchestrator` for a single interaction turn:

1.  **Receive User Prompt**:
    *   When a user prompt arrives (e.g., via a `user_prompt` signal), the `LLMOrchestrator` identifies the current `jido:WorkSession`.
    *   It ensures a `ch:Conversation` instance exists for this session in the knowledge graph, creating one if necessary (`INSERT DATA { ... a ch:Conversation ; ch:associatedWithSession jido:session_123 . }`).
    *   It determines the next `:turnIndex`.
    *   It creates a new `ch:ConversationTurn` instance, linking it to the `ch:Conversation` and setting the `:turnIndex`.
    *   It creates a `ch:Prompt` instance, sets its `:promptText` and `:timestamp`, and links it to the `ch:ConversationTurn` using `ch:hasPrompt`.

2.  **LLM Processing and Tool Usage**:
    *   The `LLMOrchestrator` sends the prompt (along with other context) to the LLM.
    *   If the LLM decides to use one or more tools:
        *   For each tool invocation requested by the LLM:
            *   The `LLMOrchestrator` executes the tool (e.g., `CodingAssistant.Tools.ReadFile.run/2`).
            *   It creates a `ch:ToolInvocation` instance.
            *   It sets `:invocationParameters` (e.g., a JSON string of the tool's arguments) and `:timestamp`.
            *   It links the `ch:ToolInvocation` to the current `ch:ConversationTurn` using `ch:involvesToolInvocation`.
            *   It identifies the tool used. If Jido Actions are formally modeled in an ontology, it links via `ch:usesTool`. Otherwise, it might use `ch:toolName` to store the tool's identifier (e.g., the module name "CodingAssistant.Tools.ReadFile").
            *   Upon receiving the tool's result, it creates a `ch:ToolResult` instance, sets `:resultData` (e.g., a JSON string of the tool's output or an error message) and `:timestamp`, and links it to the `ch:ToolInvocation` using `ch:hasResult`.

3.  **Generate and Store Final Answer**:
    *   After all tool interactions (if any), the LLM generates its final answer.
    *   The `LLMOrchestrator` creates a `ch:Answer` instance, sets its `:answerText` and `:timestamp`, and links it to the `ch:ConversationTurn` using `ch:hasAnswer`.

All these insertions into the knowledge graph would be performed using SPARQL UPDATE queries via the session's LTM adapter or a dedicated SPARQL client interface.

### Enhanced Context and Memory Retrieval

With conversation history semantically stored, the `ContextManager` (or the `LLMOrchestrator` itself when preparing the LLM prompt) can retrieve relevant past interactions to enrich the current context.

*   **Recent Conversation**: The most recent `ch:ConversationTurn`s can be fetched and their `:promptText` and `:answerText` added to the short-term conversation buffer or directly into the LLM's context, similar to how the existing STM's `ConversationBuffer` works but now sourced from persistent, structured LTM.
*   **Semantic Search on History**: The agent can perform more complex queries. For example, if a user says, "What was that function you suggested for parsing JSON last week?", the agent can query the `jido:conversation-history` graph for `ch:Answer` instances containing "function" and "JSON" within a relevant timeframe and session.
*   **Tool Usage Analysis**: The agent can analyze past tool usage patterns. For instance, "Show me all the times we tried to read the `config.exs` file and what the outcome was." This involves querying for `ch:ToolInvocation`s where `:toolName` (or the target of `:usesTool`) indicates a file read operation and the parameters match `config.exs`.

### Synergy with Two-Tier Memory

The conversation history ontology integrates deeply with the two-tier memory system:
*   **Long-Term Memory (LTM)**: The conversation data, being stored in the knowledge-graph using this ontology, *is* part of the LTM. Its persistence is ensured by the knowledge-graph engine.
*   **Short-Term Memory (STM)**: The STM (e.g., `JidoCode.Memory.ShortTerm.ConversationBuffer`) might now be seen more as a cache of the most relevant or recent parts of this structured LTM conversation history, optimized for quick LLM input assembly. Evicted items from the STM are already safely stored in the LTM.
*   **Promotion Engine**: While entire conversation turns are inherently long-term by being persisted, specific *insights* or *decisions* *from* a conversation could still be promoted to other types of `jido:MemoryItem`s (like `jido:Fact`, `jido:Decision`, or `jido:LessonLearned`) via the existing promotion engine. For example, the agent might analyze a conversation turn and decide to explicitly store a concluded fact from it as a `jido:Fact`, separate from the raw conversation log.

## Example SPARQL Queries

Here are some example SPARQL queries that illustrate how this conversation history can be used:

**Query 1: Retrieve the last 3 conversation turns for a given session (ordered by turn index)**

```sparql
PREFIX ch: <https://jido.ai/ontology/conversation-history#>
PREFIX jido: <https://jido.ai/ontology#>

SELECT ?turnIndex ?promptText ?answerText ?turnTimestamp
WHERE {
  ?conversation a ch:Conversation ;
               ch:associatedWithSession jido:session_abc .  # Replace with actual session URI
  ?turn ch:partOfConversation ?conversation ;
       ch:turnIndex ?turnIndex ;
       ch:hasPrompt/ch:promptText ?promptText ;
       ch:hasAnswer/ch:answerText ?answerText ;
       (ch:hasPrompt | ch:hasAnswer)/ch:timestamp ?turnTimestamp . # Get a timestamp for the turn
}
ORDER BY DESC(?turnIndex)
LIMIT 3
```
*(Note: Getting a single timestamp for a turn might involve choosing one from prompt or answer, or an average. The query above fetches a timestamp associated with either prompt or answer for sorting. A more robust way might be to add a `ch:timestamp` directly to `ch:ConversationTurn` or use `MAX`/`MIN` on prompt/answer timestamps if they are distinct.)*

**Query 2: Find all tool invocations of a specific tool (e.g., "ReadFile") within a session**

```sparql
PREFIX ch: <https://jido.ai/ontology/conversation-history#>
PREFIX jido: <https://jido.ai/ontology#>

SELECT ?turnIndex ?toolName ?invocationTimestamp ?resultData
WHERE {
  ?conversation a ch:Conversation ;
               ch:associatedWithSession jido:session_abc .  # Replace with actual session URI
  ?turn ch:partOfConversation ?conversation ;
       ch:turnIndex ?turnIndex ;
       ch:involvesToolInvocation ?invocation .
  ?invocation ch:toolName "ReadFile" ; # Assuming ch:toolName is used
               ch:timestamp ?invocationTimestamp ;
               ch:hasResult/ch:resultData ?resultData .
}
ORDER BY DESC(?invocationTimestamp)
```

## Conclusion: A Rich Record of Interactions

The introduction of this conversation history ontology significantly enriches the `jidoka` architecture. It transforms raw conversational data into a structured, queryable knowledge asset. This not only provides a detailed audit trail of all interactions but also unlocks powerful capabilities for context management, personalized assistance, and long-term learning by allowing the AI to reflect on its past dialogues and tool usage patterns within the semantic framework of the knowledge-graph engine. This design ensures that the history is meticulously recorded, easily retrievable, and semantically linked to the sessions and memories it pertains to, paving the way for a more aware and adaptive AI coding assistant.
