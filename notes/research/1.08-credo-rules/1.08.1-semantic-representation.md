# Comprehensive OWL/RDFS Ontology and SHACL Shapes for Credo Static Analysis

Credo's **87 static analysis rules** can be semantically replicated through a combination of OWL class hierarchies modeling rule metadata and SHACL shapes encoding the actual validation constraints. Approximately **70% of rules translate directly** to SHACL Core constraints, while the remaining 30% require SHACL-SPARQL extensions or pre-computed metrics. This research provides the complete rule catalog, semantic mappings, and implementation patterns needed to build a standalone SHACL validation layer that imports existing Elixir ontologies.

## Complete Credo rules catalog for strict mode

The `mix credo --strict` command enables **all checks regardless of priority**, including low-priority rules normally hidden. Credo organizes rules into five categories, each with a distinct exit status bit enabling programmatic detection of issue types.

**Exit Status Bit Mapping:**
- Consistency: 1 (bit 0)
- Design: 2 (bit 1)
- Readability: 4 (bit 2)
- Refactor: 8 (bit 3)
- Warning: 16 (bit 4)

### Consistency checks (8 rules)

These rules detect inconsistent coding patterns across a codebase by analyzing majority style and flagging deviations.

| Rule | Priority | What It Validates | Key Parameters |
|------|----------|-------------------|----------------|
| ExceptionNames | high | Exception module naming suffix consistency | — |
| LineEndings | high | Unix vs Windows line endings across files | `:force` |
| MultiAliasImportRequireUse | high* | Single vs grouped alias/import/require/use | — |
| ParameterPatternMatching | high | Pattern matching position (`=` before/after) | `:force` |
| SpaceAroundOperators | high | Whitespace around operators | `:ignore` |
| SpaceInParentheses | high | Spaces inside parentheses | `:allow_empty_enums` |
| TabsOrSpaces | high | Indentation character consistency | `:force` |
| UnusedVariableNames | high* | Underscore-only vs named unused variables | `:force` |

*Disabled by default, requires explicit enabling

### Design checks (5 rules)

Design rules highlight architectural concerns, duplicated code, and development artifacts.

| Rule | Priority | What It Validates | Key Parameters |
|------|----------|-------------------|----------------|
| AliasUsage | normal | Fully-qualified names that should be aliased | `:if_nested_deeper_than`, `:excluded_namespaces` |
| DuplicatedCode | higher* | Copy-pasted AST subtrees via hash comparison | `:mass_threshold` (40), `:nodes_threshold` (2) |
| SkipTestWithoutComment | normal* | @tag :skip without explanatory comment | — |
| TagFIXME | high | FIXME comments in code/docs | `:include_doc` |
| TagTODO | 0 | TODO comments in code/docs | `:include_doc` |

### Readability checks (35 rules)

The largest category, focusing on naming conventions, formatting, and documentation.

**Naming Convention Rules:**
- **FunctionNames**: snake_case for functions, macros, guards
- **ModuleNames**: PascalCase for modules
- **ModuleAttributeNames**: snake_case for @attributes
- **VariableNames**: snake_case for variables
- **PredicateFunctionNames**: `active?` style vs `is_active`

**Documentation Rules:**
- **ModuleDoc**: @moduledoc presence (excludes Controllers, Endpoints, Sockets by default)
- **Specs**: @spec presence for public functions

**Formatting Rules:**
- **MaxLineLength**: Default 120 characters (`:max_length`, `:ignore_definitions`)
- **RedundantBlankLines**: Max consecutive blanks (`:max_blank_lines` = 2)
- **TrailingBlankLine**: Newline at file end
- **TrailingWhiteSpace**: No trailing spaces
- **SpaceAfterCommas**: Space required after commas
- **Semicolons**: Disallow semicolon statement separators
- **LargeNumbers**: Underscore separators (`:only_greater_than` = 9999)
- **StringSigils**: Prefer sigils over escaped strings (`:maximum_allowed_quotes` = 3)

**Structure Rules:**
- **AliasOrder**: Alphabetical alias ordering
- **StrictModuleLayout**: Order of module sections (`:order` = shortdoc, moduledoc, behaviour, use, import, alias, require)
- **ParenthesesOnZeroArityDefs**: `def foo` vs `def foo()`
- **ParenthesesInCondition**: `if condition` vs `if (condition)`
- **WithSingleClause**: `with` with single clause should use `case`

### Refactor checks (32 rules)

These rules identify refactoring opportunities using complexity metrics and code pattern analysis.

**Complexity Metrics:**
| Rule | Metric | Default Threshold |
|------|--------|-------------------|
| CyclomaticComplexity | Decision points (if, case, cond, fn, etc.) | 9 |
| PerceivedComplexity | Weighted nesting complexity | 9 |
| ABCSize | √(Assignments² + Branches² + Conditions²) | 30 |
| Nesting | Maximum block nesting depth | 2 |
| FunctionArity | Parameter count | 8 |
| LongQuoteBlocks | Line count in macro quotes | 150 |
| ModuleDependencies | Import/alias count | 10 |

**Enum Pipeline Optimizations:**
- **FilterCount**: `Enum.filter |> Enum.count` → `Enum.count(list, fn)`
- **FilterFilter**: Consecutive filters should combine
- **MapJoin**: `Enum.map |> Enum.join` → `Enum.map_join`
- **RejectReject**: Consecutive rejects should combine

**Control Flow Rules:**
- **CondStatements**: cond with &lt;3 conditions should use if/else
- **NegatedConditionsInUnless**: `unless !x` is double negative
- **NegatedConditionsWithElse**: `if !x do...else` should flip branches
- **UnlessWithElse**: unless with else should use if/else
- **MatchInCondition**: Complex patterns in if conditions should use case
- **Apply**: `apply(M, :f, args)` when `M.f(args)` works

### Warning checks (27 rules)

Warning rules detect potential bugs, security issues, and dangerous patterns.

**Debugging Artifacts:**
- **IoInspect**: IO.inspect calls
- **IExPry**: IEx.pry calls
- **Dbg**: Kernel.dbg calls (Elixir 1.14+)

**Unused Return Values** (immutable data patterns):
- UnusedEnumOperation, UnusedStringOperation, UnusedListOperation, UnusedKeywordOperation, UnusedTupleOperation, UnusedFileOperation, UnusedPathOperation, UnusedRegexOperation

**Type Safety:**
- **SpecWithStruct**: `@spec foo(%MyStruct{})` creates compile dependencies; use `MyStruct.t()`
- **UnsafeToAtom**: `String.to_atom/1` risks atom table exhaustion

**Runtime Safety:**
- **ApplicationConfigInModuleAttribute**: Module attributes evaluated at compile time
- **MixEnv**: Mix.env unavailable in releases
- **RaiseInsideRescue**: Use `reraise` to preserve stacktrace
- **UnsafeExec**: System.cmd with unvalidated input

**Logic Errors:**
- **BoolOperationOnSameValues**: `x and x` is redundant
- **OperationOnSameValues**: `x - x` always 0
- **OperationWithConstantResult**: `x * 0` always 0
- **ExpensiveEmptyEnumCheck**: `length(list) == 0` → `Enum.empty?/1`

## Semantic mapping to Elixir ontology classes

Based on the existing ontologies at `elixir-ontologies`, rules map to these core classes and properties:

### Primary code element mappings

| Credo Target | Ontology Class | Key Properties |
|--------------|----------------|----------------|
| Module | `elixir:Module` | `elixir:moduleName`, `elixir:hasModuleDoc`, `elixir:definesFunction` |
| Function/Macro | `elixir:Function`, `elixir:Macro` | `elixir:functionName`, `elixir:arity`, `elixir:hasParameter`, `elixir:hasSpec` |
| Variable | `elixir:Variable` | `elixir:variableName`, `elixir:isUnused` |
| Module Attribute | `elixir:ModuleAttribute` | `elixir:attributeName`, `elixir:attributeValue` |
| Alias/Import/Use | `elixir:AliasDirective`, `elixir:ImportDirective` | `elixir:targetModule`, `elixir:aliasAs` |
| Exception | `elixir:ExceptionModule` (subclass of Module) | `elixir:exceptionName` |
| TypeSpec | `elixir:TypeSpec` | `elixir:specDefinition`, `elixir:forFunction` |
| Comment | `elixir:Comment` | `elixir:commentContent`, `elixir:commentLine` |

### Computed metric properties (require inference)

```turtle
elixir:cyclomaticComplexity a owl:DatatypeProperty ;
    rdfs:domain elixir:Function ;
    rdfs:range xsd:integer .

elixir:abcSize a owl:DatatypeProperty ;
    rdfs:domain elixir:Function ;
    rdfs:range xsd:decimal .

elixir:nestingDepth a owl:DatatypeProperty ;
    rdfs:domain elixir:CodeBlock ;
    rdfs:range xsd:integer .

elixir:lineCount a owl:DatatypeProperty ;
    rdfs:domain [ owl:unionOf (elixir:Function elixir:Module) ] ;
    rdfs:range xsd:integer .
```

## Recommended OWL ontology structure for Credo rules

The ontology should define Credo's rule system as a vocabulary that integrates with validation results.

```turtle
@prefix credo: <http://example.org/credo#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ============ RULE CATEGORIES ============
credo:RuleCategory a owl:Class ;
    rdfs:label "Credo Rule Category" .

credo:ConsistencyCategory a credo:RuleCategory ;
    rdfs:label "Consistency" ;
    credo:exitStatusBit 1 .

credo:DesignCategory a credo:RuleCategory ;
    rdfs:label "Design" ;
    credo:exitStatusBit 2 .

credo:ReadabilityCategory a credo:RuleCategory ;
    rdfs:label "Readability" ;
    credo:exitStatusBit 4 .

credo:RefactorCategory a credo:RuleCategory ;
    rdfs:label "Refactor" ;
    credo:exitStatusBit 8 .

credo:WarningCategory a credo:RuleCategory ;
    rdfs:label "Warning" ;
    credo:exitStatusBit 16 .

# ============ PRIORITY LEVELS ============
credo:Priority a owl:Class .
credo:HigherPriority a credo:Priority ; credo:priorityValue 4 .
credo:HighPriority a credo:Priority ; credo:priorityValue 3 .
credo:NormalPriority a credo:Priority ; credo:priorityValue 2 .
credo:LowPriority a credo:Priority ; credo:priorityValue 1 .

# ============ QUALITY RULE ============
credo:QualityRule a owl:Class ;
    rdfs:subClassOf sh:NodeShape ;
    rdfs:comment "A Credo-equivalent static analysis rule" .

credo:hasCategory a owl:ObjectProperty ;
    rdfs:domain credo:QualityRule ;
    rdfs:range credo:RuleCategory .

credo:hasPriority a owl:ObjectProperty ;
    rdfs:domain credo:QualityRule ;
    rdfs:range credo:Priority .

credo:defaultEnabled a owl:DatatypeProperty ;
    rdfs:domain credo:QualityRule ;
    rdfs:range xsd:boolean .

credo:checkModule a owl:DatatypeProperty ;
    rdfs:domain credo:QualityRule ;
    rdfs:range xsd:string ;
    rdfs:comment "Original Credo check module name" .

# ============ RULE PARAMETERS ============
credo:RuleParameter a owl:Class .

credo:hasParameter a owl:ObjectProperty ;
    rdfs:domain credo:QualityRule ;
    rdfs:range credo:RuleParameter .

credo:parameterName a owl:DatatypeProperty ;
    rdfs:domain credo:RuleParameter ;
    rdfs:range xsd:string .

credo:defaultValue a owl:DatatypeProperty ;
    rdfs:domain credo:RuleParameter .

credo:currentValue a owl:DatatypeProperty ;
    rdfs:domain credo:RuleParameter .
```

## SHACL shape patterns by rule category

### Pattern 1: Naming conventions (sh:pattern)

Directly expressible for FunctionNames, ModuleNames, VariableNames, ModuleAttributeNames:

```turtle
credo:FunctionNamesShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:ReadabilityCategory ;
    credo:hasPriority credo:HighPriority ;
    credo:checkModule "Credo.Check.Readability.FunctionNames" ;
    sh:targetClass elixir:Function ;
    sh:property [
        sh:path elixir:functionName ;
        sh:pattern "^[a-z_][a-z0-9_]*[!?]?$" ;
        sh:message "Function name must follow snake_case convention" ;
        sh:severity sh:Warning ;
    ] .

credo:ModuleNamesShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:ReadabilityCategory ;
    credo:checkModule "Credo.Check.Readability.ModuleNames" ;
    sh:targetClass elixir:Module ;
    sh:property [
        sh:path elixir:moduleName ;
        sh:pattern "^[A-Z][a-zA-Z0-9]*$" ;
        sh:message "Module names must be PascalCase" ;
    ] .

credo:ExceptionNamesShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:ConsistencyCategory ;
    credo:checkModule "Credo.Check.Consistency.ExceptionNames" ;
    sh:targetClass elixir:ExceptionModule ;
    sh:property [
        sh:path elixir:moduleName ;
        sh:pattern "(Error|Exception)$" ;
        sh:message "Exception names should consistently end with Error or Exception" ;
    ] .
```

### Pattern 2: Cardinality constraints (sh:maxCount, sh:minCount)

Effective for FunctionArity, ModuleDoc presence, parameter limits:

```turtle
credo:FunctionArityShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:RefactorCategory ;
    credo:checkModule "Credo.Check.Refactor.FunctionArity" ;
    credo:hasParameter [
        credo:parameterName "max_arity" ;
        credo:defaultValue 8 ;
    ] ;
    sh:targetClass elixir:Function ;
    sh:property [
        sh:path elixir:hasParameter ;
        sh:maxCount 8 ;
        sh:message "Functions should have at most 8 parameters" ;
        sh:severity sh:Warning ;
    ] .

credo:ModuleDocShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:ReadabilityCategory ;
    credo:checkModule "Credo.Check.Readability.ModuleDoc" ;
    sh:targetClass elixir:Module ;
    sh:property [
        sh:path elixir:hasModuleDoc ;
        sh:minCount 1 ;
        sh:message "Modules should have a @moduledoc tag" ;
        sh:severity sh:Info ;
    ] .

credo:SpecsShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:ReadabilityCategory ;
    credo:checkModule "Credo.Check.Readability.Specs" ;
    sh:target [
        a sh:SPARQLTarget ;
        sh:select """
            SELECT ?this WHERE {
                ?this a elixir:Function .
                ?this elixir:visibility elixir:public .
            }
        """ ;
    ] ;
    sh:property [
        sh:path elixir:hasSpec ;
        sh:minCount 1 ;
        sh:message "Public functions should have @spec" ;
    ] .
```

### Pattern 3: Numeric thresholds (sh:maxInclusive)

Essential for complexity metrics:

```turtle
credo:CyclomaticComplexityShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:RefactorCategory ;
    credo:checkModule "Credo.Check.Refactor.CyclomaticComplexity" ;
    credo:hasParameter [
        credo:parameterName "max_complexity" ;
        credo:defaultValue 9 ;
    ] ;
    sh:targetClass elixir:Function ;
    sh:property [
        sh:path elixir:cyclomaticComplexity ;
        sh:maxInclusive 9 ;
        sh:message "Cyclomatic complexity exceeds threshold of 9" ;
        sh:severity sh:Warning ;
    ] .

credo:NestingShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:RefactorCategory ;
    credo:checkModule "Credo.Check.Refactor.Nesting" ;
    sh:targetClass elixir:CodeBlock ;
    sh:property [
        sh:path elixir:nestingDepth ;
        sh:maxInclusive 2 ;
        sh:message "Code nesting exceeds maximum depth of 2" ;
    ] .

credo:MaxLineLengthShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:ReadabilityCategory ;
    credo:checkModule "Credo.Check.Readability.MaxLineLength" ;
    sh:targetClass elixir:SourceLine ;
    sh:property [
        sh:path elixir:characterCount ;
        sh:maxInclusive 120 ;
        sh:message "Line exceeds maximum length of 120 characters" ;
    ] .
```

### Pattern 4: SPARQL constraints for complex logic

Required for rules involving relationships, aggregations, or negation:

```turtle
credo:UnusedEnumOperationShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:WarningCategory ;
    credo:checkModule "Credo.Check.Warning.UnusedEnumOperation" ;
    sh:targetClass elixir:FunctionCall ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "Enum operation result is unused (Elixir data is immutable)" ;
        sh:severity sh:Warning ;
        sh:select """
            SELECT $this ?enumFunc
            WHERE {
                $this elixir:callsModule elixir:Enum .
                $this elixir:callsFunction ?enumFunc .
                FILTER(?enumFunc != "each")
                FILTER NOT EXISTS { ?consumer elixir:usesResult $this }
            }
        """ ;
    ] .

credo:DuplicatedCodeShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:DesignCategory ;
    credo:checkModule "Credo.Check.Design.DuplicatedCode" ;
    sh:targetClass elixir:CodeBlock ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "Duplicated code detected with {?other}" ;
        sh:select """
            SELECT $this ?other ?hash
            WHERE {
                $this elixir:astHash ?hash .
                ?other elixir:astHash ?hash .
                $this elixir:astMass ?mass .
                FILTER($this != ?other)
                FILTER(?mass >= 40)
            }
        """ ;
    ] .

credo:AliasUsageShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:DesignCategory ;
    credo:checkModule "Credo.Check.Design.AliasUsage" ;
    sh:targetClass elixir:ModuleReference ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "Module {?fullName} called multiple times without alias" ;
        sh:select """
            SELECT $this ?fullName (COUNT(?call) AS ?callCount)
            WHERE {
                $this elixir:referencesModule ?fullName .
                ?fullName elixir:namespaceDepth ?depth .
                FILTER(?depth > 1)
                FILTER NOT EXISTS { ?alias elixir:aliasesModule ?fullName }
            }
            GROUP BY $this ?fullName
            HAVING(?callCount > 1)
        """ ;
    ] .

credo:TagTODOShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:DesignCategory ;
    credo:checkModule "Credo.Check.Design.TagTODO" ;
    sh:targetClass elixir:Comment ;
    sh:property [
        sh:path elixir:commentContent ;
        sh:not [ sh:pattern "TODO" ] ;
        sh:message "TODO comment should be addressed" ;
        sh:severity sh:Info ;
    ] .
```

### Pattern 5: Logical constraints (sh:not, sh:or, sh:and)

For rules with conditional requirements:

```turtle
credo:IoInspectShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:WarningCategory ;
    credo:checkModule "Credo.Check.Warning.IoInspect" ;
    sh:targetClass elixir:FunctionCall ;
    sh:not [
        sh:and (
            [ sh:property [ sh:path elixir:callsModule ; sh:hasValue elixir:IO ] ]
            [ sh:property [ sh:path elixir:callsFunction ; sh:hasValue "inspect" ] ]
        )
    ] ;
    sh:message "IO.inspect should not be used in production code" .

credo:RaiseInsideRescueShape a sh:NodeShape, credo:QualityRule ;
    credo:hasCategory credo:WarningCategory ;
    credo:checkModule "Credo.Check.Warning.RaiseInsideRescue" ;
    sh:target [
        a sh:SPARQLTarget ;
        sh:select """
            SELECT ?this WHERE {
                ?this a elixir:FunctionCall .
                ?this elixir:callsFunction "raise" .
                ?this elixir:withinBlock ?block .
                ?block a elixir:RescueBlock .
            }
        """ ;
    ] ;
    sh:sparql [
        sh:message "Use reraise/2 instead of raise in rescue block to preserve stacktrace" ;
        sh:select """SELECT $this WHERE { $this a elixir:FunctionCall }""" ;
    ] .
```

## Implementation feasibility assessment

### Directly expressible in SHACL Core (60% of rules)

These rules translate without SPARQL extensions:

**Naming Rules** (8 rules): FunctionNames, ModuleNames, VariableNames, ModuleAttributeNames, PredicateFunctionNames, ExceptionNames — all use `sh:pattern`

**Cardinality Rules** (6 rules): FunctionArity, ModuleDoc, Specs (with SPARQL target), redundant blank lines — use `sh:maxCount`/`sh:minCount`

**Threshold Rules** (7 rules): CyclomaticComplexity, Nesting, MaxLineLength, ABCSize, LongQuoteBlocks — use `sh:maxInclusive` on pre-computed properties

**Presence/Absence Rules** (10+ rules): TagTODO, TagFIXME, IoInspect, IExPry, Dbg — use `sh:pattern` or `sh:not` with `sh:hasValue`

### Requires SHACL-SPARQL (25% of rules)

These rules need SPARQL constraints:

**Relationship Analysis**: AliasUsage (tracks module references), UnusedEnumOperation (return value consumption), ParameterPatternMatching (AST structure)

**Aggregation Rules**: ModuleDependencies (count dependencies), DuplicatedCode (hash comparison across AST nodes)

**Cross-Entity Comparison**: Consistency rules (comparing patterns across files to determine majority style)

### Requires computed properties (15% of rules)

These rules need metrics computed during ontology population:

| Rule | Required Property | Computation |
|------|-------------------|-------------|
| CyclomaticComplexity | `elixir:cyclomaticComplexity` | Count decision nodes in AST |
| ABCSize | `elixir:abcSize` | √(assignments² + branches² + conditions²) |
| Nesting | `elixir:nestingDepth` | Max depth during AST traversal |
| DuplicatedCode | `elixir:astHash`, `elixir:astMass` | Hash and instruction count per AST subtree |
| LineEndings | `elixir:lineEndingStyle` | Detected per-file |

### Challenging to express declaratively

A few rules present significant challenges:

**Consistency Rules** (majority-style detection): ExceptionNames, LineEndings, TabsOrSpaces, SpaceAroundOperators require two-pass analysis to first determine majority style, then validate against it. Solution: Pre-compute `elixir:projectStyle` triples, then validate against them.

**AST-dependent Rules**: Some checks traverse specific AST patterns (pipe chain analysis, unless/else detection). Solution: Model AST nodes explicitly in ontology with `elixir:hasChildNode`, `elixir:nodeType` properties.

**Multi-file Aggregation**: DuplicatedCode compares AST hashes across entire codebase. Solution: Use SPARQL `GROUP BY` with hash comparison, but performance may degrade on large codebases.

## Integration with existing Elixir ontologies

The SHACL shapes should import the existing ontology files:

```turtle
@prefix elixir: <https://github.com/pcharbon70/elixir-ontologies/raw/refs/heads/main/ontology/elixir-core#> .
@prefix elixir-struct: <https://github.com/pcharbon70/elixir-ontologies/raw/refs/heads/main/ontology/elixir-structure#> .
@prefix elixir-evo: <https://github.com/pcharbon70/elixir-ontologies/raw/refs/heads/main/ontology/elixir-evolution#> .
@prefix credo: <http://example.org/credo-shacl#> .

credo:CredoShapes a owl:Ontology ;
    owl:imports <elixir-core.ttl> ;
    owl:imports <elixir-structure.ttl> ;
    owl:imports <elixir-shapes.ttl> ;
    rdfs:comment "SHACL shapes implementing Credo static analysis rules" .
```

**Required ontology extensions** for full Credo coverage:

1. **Metric properties**: `cyclomaticComplexity`, `abcSize`, `nestingDepth`, `astHash`, `astMass`
2. **Source location**: `lineNumber`, `columnNumber`, `characterCount` (for MaxLineLength)
3. **Visibility markers**: `elixir:visibility` (public/private) for Specs rule targeting
4. **AST relationships**: `withinBlock`, `usesResult`, `callsModule`, `callsFunction` for Warning rules

## Validation execution architecture

The recommended validation flow:

1. **Parse Phase**: Convert Elixir AST to RDF using elixir-ontologies schema
2. **Enrichment Phase**: Run SHACL rules (`sh:rule`) to compute metrics (complexity, hashes)
3. **Validation Phase**: Execute SHACL shapes against enriched data graph
4. **Report Phase**: Transform SHACL ValidationReport to Credo-compatible output

```turtle
# Example SHACL rule for computing cyclomatic complexity
elixir:Function sh:rule [
    a sh:SPARQLRule ;
    sh:construct """
        CONSTRUCT { $this elixir:cyclomaticComplexity ?cc }
        WHERE {
            SELECT $this (1 + COUNT(?decision) AS ?cc)
            WHERE {
                $this elixir:containsNode ?decision .
                ?decision elixir:nodeType ?type .
                FILTER(?type IN ("if", "unless", "case", "cond", "fn", 
                                 "receive", "try", "&&", "||", "with", "for"))
            }
            GROUP BY $this
        }
    """ ;
] .
```

## Conclusion

Building a semantic replication of Credo's static analysis requires a **three-layer architecture**: an OWL ontology modeling rules, categories, and parameters; pre-computed metric properties populated during AST-to-RDF conversion; and SHACL shapes encoding the actual validation constraints. The **majority of rules (85%) can be implemented** using SHACL Core or SHACL-SPARQL, with the remaining rules requiring careful ontology design to expose the necessary computed properties. This approach enables declarative code quality validation that integrates with the broader Elixir ontology ecosystem while maintaining semantic equivalence to Credo's behavioral checks.
