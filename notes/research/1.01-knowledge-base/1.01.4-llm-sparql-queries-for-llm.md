# SPARQL Query Patterns for LLM Code Understanding

These queries are designed to be executed against Elixir project knowledge graphs (like jido.ttl) to help an LLM understand codebase architecture and generate better, more consistent code.

## Prefixes (use in all queries)

```sparql
PREFIX struct: <https://w3id.org/elixir-code/structure#>
PREFIX core: <https://w3id.org/elixir-code/core#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
```

---

## 1. Module Discovery & Context

### 1.1 Get complete module context (for understanding before modifying)

When the LLM needs to work with a specific module, this query provides full context:

```sparql
SELECT ?moduleName ?docstring ?usedModule ?aliasedModule ?importedModule ?requiredModule
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  FILTER(CONTAINS(?moduleName, "Jido.Agent.Server"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
  OPTIONAL { ?module struct:usesModule ?used . ?used struct:moduleName ?usedModule }
  OPTIONAL { ?module struct:aliasesModule ?aliased . ?aliased struct:moduleName ?aliasedModule }
  OPTIONAL { ?module struct:importsFrom ?imported . ?imported struct:moduleName ?importedModule }
  OPTIONAL { ?module struct:requiresModule ?required . ?required struct:moduleName ?requiredModule }
}
```

### 1.2 List all modules in a namespace

Understand the structure of a subsystem:

```sparql
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  OPTIONAL { ?module struct:docstring ?docstring }
  
  FILTER(STRSTARTS(?moduleName, "Jido.Agent."))
}
ORDER BY ?moduleName
```

### 1.3 Find modules that use a specific module/library

Understand adoption patterns (e.g., "how is GenServer used in this project?"):

```sparql
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName ?usedName .
  
  FILTER(CONTAINS(?usedName, "GenServer"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
}
```

---

## 2. Function Discovery & Signatures

### 2.1 Get all public functions in a module with their arities

Essential for understanding module API:

```sparql
SELECT ?functionName ?arity ?docstring ?sourceLocation
WHERE {
  ?module a struct:Module ;
          struct:moduleName "Jido.Agent.Lifecycle" ;
          struct:containsFunction ?function .
  
  ?function a struct:PublicFunction ;
            struct:functionName ?functionName ;
            struct:arity ?arity .
  
  OPTIONAL { ?function struct:docstring ?docstring }
  OPTIONAL { 
    ?function core:hasSourceLocation ?loc .
    ?loc core:startLine ?line .
    BIND(CONCAT("L", STR(?line)) AS ?sourceLocation)
  }
}
ORDER BY ?functionName ?arity
```

### 2.2 Find all functions with a specific name across the codebase

Useful for understanding naming conventions and finding similar implementations:

```sparql
SELECT ?moduleName ?functionName ?arity ?visibility
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function struct:functionName ?functionName ;
            struct:arity ?arity .
  
  FILTER(?functionName = "run")
  
  BIND(IF(EXISTS { ?function a struct:PublicFunction }, "public", "private") AS ?visibility)
}
ORDER BY ?moduleName ?arity
```

### 2.3 Find functions by arity pattern

Find all binary functions (arity 2) - useful for understanding common patterns:

```sparql
SELECT ?moduleName ?functionName
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function a struct:PublicFunction ;
            struct:functionName ?functionName ;
            struct:arity 2 .
}
ORDER BY ?moduleName ?functionName
```

### 2.4 Find callback implementations

Identify GenServer callbacks, behaviour implementations:

```sparql
SELECT ?moduleName ?callbackName ?arity
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function struct:functionName ?callbackName ;
            struct:arity ?arity .
  
  FILTER(?callbackName IN ("init", "handle_call", "handle_cast", "handle_info", "terminate", "code_change"))
}
ORDER BY ?moduleName ?callbackName
```

---

## 3. Dependency Analysis

### 3.1 Build module dependency graph

Understand what a module depends on:

```sparql
SELECT ?moduleName ?dependencyType ?dependsOn
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  FILTER(?moduleName = "Jido.Agent.Server.Runtime")
  
  {
    ?module struct:aliasesModule ?dep .
    ?dep struct:moduleName ?dependsOn .
    BIND("alias" AS ?dependencyType)
  }
  UNION
  {
    ?module struct:usesModule ?dep .
    ?dep struct:moduleName ?dependsOn .
    BIND("use" AS ?dependencyType)
  }
  UNION
  {
    ?module struct:requiresModule ?dep .
    ?dep struct:moduleName ?dependsOn .
    BIND("require" AS ?dependencyType)
  }
  UNION
  {
    ?module struct:importsFrom ?dep .
    ?dep struct:moduleName ?dependsOn .
    BIND("import" AS ?dependencyType)
  }
}
ORDER BY ?dependencyType ?dependsOn
```

### 3.2 Find reverse dependencies (what depends on this module?)

Critical for understanding impact of changes:

```sparql
SELECT ?dependentModule ?dependencyType
WHERE {
  ?target a struct:Module ;
          struct:moduleName "Jido.Agent.Server.State" .
  
  ?dependent a struct:Module ;
             struct:moduleName ?dependentModule .
  
  {
    ?dependent struct:aliasesModule ?target .
    BIND("alias" AS ?dependencyType)
  }
  UNION
  {
    ?dependent struct:usesModule ?target .
    BIND("use" AS ?dependencyType)
  }
  UNION
  {
    ?dependent struct:requiresModule ?target .
    BIND("require" AS ?dependencyType)
  }
}
ORDER BY ?dependentModule
```

### 3.3 Find commonly aliased modules

Understand which modules are central to the architecture:

```sparql
SELECT ?moduleName (COUNT(?aliaser) AS ?aliasCount)
WHERE {
  ?aliased a struct:Module ;
           struct:moduleName ?moduleName .
  
  ?aliaser struct:aliasesModule ?aliased .
}
GROUP BY ?moduleName
ORDER BY DESC(?aliasCount)
LIMIT 20
```

---

## 4. Type System Queries

### 4.1 Get all types defined in a module

```sparql
SELECT ?typeName ?typeArity ?visibility
WHERE {
  ?module a struct:Module ;
          struct:moduleName "Jido.Agent.Server.State" ;
          struct:containsType ?type .
  
  ?type struct:typeName ?typeName ;
        struct:typeArity ?typeArity .
  
  BIND(
    IF(EXISTS { ?type a struct:PublicType }, "public",
    IF(EXISTS { ?type a struct:OpaqueType }, "opaque", "private"))
    AS ?visibility
  )
}
ORDER BY ?typeName
```

### 4.2 Find all modules that define a `t()` type

Common Elixir pattern - modules with struct-like types:

```sparql
SELECT ?moduleName
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsType ?type .
  
  ?type struct:typeName "t" ;
        struct:typeArity 0 .
}
ORDER BY ?moduleName
```

---

## 5. Pattern Recognition

### 5.1 Find all Action modules (modules using Jido.Action)

Identify a specific architectural pattern:

```sparql
SELECT ?moduleName ?docstring ?runArity
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName ?usedName .
  
  FILTER(CONTAINS(?usedName, "Jido.Action"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
  OPTIONAL {
    ?module struct:containsFunction ?runFunc .
    ?runFunc struct:functionName "run" ;
             struct:arity ?runArity .
  }
}
ORDER BY ?moduleName
```

### 5.2 Find all Server-related modules (GenServer pattern)

```sparql
SELECT ?moduleName ?hasInit ?hasHandleCall ?hasHandleCast
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName "GenServer" .
  
  BIND(EXISTS {
    ?module struct:containsFunction ?f1 .
    ?f1 struct:functionName "init" .
  } AS ?hasInit)
  
  BIND(EXISTS {
    ?module struct:containsFunction ?f2 .
    ?f2 struct:functionName "handle_call" .
  } AS ?hasHandleCall)
  
  BIND(EXISTS {
    ?module struct:containsFunction ?f3 .
    ?f3 struct:functionName "handle_cast" .
  } AS ?hasHandleCast)
}
ORDER BY ?moduleName
```

### 5.3 Find modules with TypedStruct (struct pattern)

```sparql
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName ?usedName .
  
  FILTER(CONTAINS(?usedName, "TypedStruct"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
}
ORDER BY ?moduleName
```

---

## 6. Error Handling Patterns

### 6.1 Find all Error modules

```sparql
SELECT ?moduleName ?docstring ?hasException
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  FILTER(CONTAINS(?moduleName, "Error"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
  
  BIND(EXISTS {
    ?module struct:containsFunction ?f .
    ?f struct:functionName "exception" .
  } AS ?hasException)
}
ORDER BY ?moduleName
```

---

## 7. Architecture Understanding

### 7.1 Get namespace tree structure

Understand the high-level organization:

```sparql
SELECT ?namespace (COUNT(?module) AS ?moduleCount) (GROUP_CONCAT(?shortName; separator=", ") AS ?modules)
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  # Extract namespace (everything before last dot) and short name
  BIND(REPLACE(?moduleName, "\\.[^.]+$", "") AS ?namespace)
  BIND(REPLACE(?moduleName, "^.*\\.", "") AS ?shortName)
}
GROUP BY ?namespace
ORDER BY ?namespace
```

### 7.2 Find entry points (modules with start_link)

Identify process entry points:

```sparql
SELECT ?moduleName ?startLinkArity
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function struct:functionName "start_link" ;
            struct:arity ?startLinkArity .
}
ORDER BY ?moduleName
```

### 7.3 Find modules with child_spec (supervisable)

```sparql
SELECT ?moduleName
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function struct:functionName "child_spec" ;
            struct:arity 1 .
}
ORDER BY ?moduleName
```

---

## 8. Code Generation Context Queries

### 8.1 Get complete context for adding a new function to a module

When LLM needs to add a function, get everything it needs:

```sparql
SELECT ?moduleName ?docstring ?usedModule ?existingFunc ?existingArity ?existingVisibility
WHERE {
  ?module a struct:Module ;
          struct:moduleName "Jido.Agent.Lifecycle" .
  
  OPTIONAL { ?module struct:docstring ?docstring }
  
  OPTIONAL {
    ?module struct:usesModule ?used .
    ?used struct:moduleName ?usedModule .
  }
  
  OPTIONAL {
    ?module struct:containsFunction ?func .
    ?func struct:functionName ?existingFunc ;
          struct:arity ?existingArity .
    BIND(IF(EXISTS { ?func a struct:PublicFunction }, "public", "private") AS ?existingVisibility)
  }
}
ORDER BY ?existingVisibility ?existingFunc ?existingArity
```

### 8.2 Find similar modules for pattern consistency

When creating a new module, find similar ones to match patterns:

```sparql
SELECT ?moduleName ?docstring ?pattern
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  # Look for modules with similar naming pattern
  FILTER(CONTAINS(?moduleName, "Server"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
  
  # Identify the pattern used
  OPTIONAL {
    ?module struct:usesModule ?used .
    ?used struct:moduleName ?pattern .
  }
}
ORDER BY ?moduleName
```

### 8.3 Get function signature patterns for a specific callback type

When implementing a callback, see how others do it:

```sparql
SELECT ?moduleName ?arity ?minArity ?sourceLocation
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function struct:functionName "handle_call" ;
            struct:arity ?arity .
  
  OPTIONAL { ?function struct:minArity ?minArity }
  OPTIONAL {
    ?function core:hasSourceLocation ?loc .
    BIND(STR(?loc) AS ?sourceLocation)
  }
}
ORDER BY ?moduleName
```

---

## 9. Documentation Queries

### 9.1 Find well-documented modules (for learning patterns)

```sparql
SELECT ?moduleName ?docLength
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:docstring ?doc .
  
  BIND(STRLEN(?doc) AS ?docLength)
  FILTER(?docLength > 500)
}
ORDER BY DESC(?docLength)
LIMIT 10
```

### 9.2 Find undocumented public functions

```sparql
SELECT ?moduleName ?functionName ?arity
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:containsFunction ?function .
  
  ?function a struct:PublicFunction ;
            struct:functionName ?functionName ;
            struct:arity ?arity .
  
  FILTER NOT EXISTS { ?function struct:docstring ?doc }
}
ORDER BY ?moduleName ?functionName
```

---

## 10. Composite Queries for Specific Tasks

### 10.1 "I need to add a new Action" - Get all Action patterns

```sparql
SELECT DISTINCT ?moduleName ?docstring ?funcName ?arity
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName ?usedName .
  
  FILTER(CONTAINS(?usedName, "Jido.Action"))
  FILTER(CONTAINS(?moduleName, "Actions"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
  
  ?module struct:containsFunction ?func .
  ?func a struct:PublicFunction ;
        struct:functionName ?funcName ;
        struct:arity ?arity .
}
ORDER BY ?moduleName ?funcName
```

### 10.2 "I need to add a new Directive" - Get Directive patterns

```sparql
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  FILTER(CONTAINS(?moduleName, "Directive") || CONTAINS(?moduleName, "Enqueue") || 
         CONTAINS(?moduleName, "RegisterAction") || CONTAINS(?moduleName, "Spawn"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
}
ORDER BY ?moduleName
```

### 10.3 "What's the Server architecture?" - Complete server module map

```sparql
SELECT ?moduleName ?docstring ?funcCount
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  
  FILTER(CONTAINS(?moduleName, "Jido.Agent.Server"))
  
  OPTIONAL { ?module struct:docstring ?docstring }
  
  {
    SELECT ?module (COUNT(?func) AS ?funcCount)
    WHERE {
      ?module struct:containsFunction ?func .
      ?func a struct:PublicFunction .
    }
    GROUP BY ?module
  }
}
ORDER BY ?moduleName
```

---

## Usage Guide for LLMs

### Query Selection Strategy

1. **Before modifying a module**: Use queries 1.1 and 2.1 to understand full context
2. **Before adding new module**: Use query 5.x to find similar patterns
3. **Before adding function**: Use query 8.1 for context, 2.2 to see similar functions elsewhere
4. **Understanding architecture**: Start with 7.1, then drill into specific namespaces
5. **Finding dependencies**: Use 3.1 before changes, 3.2 to understand impact

### Combining Results

LLMs should chain queries:
1. First, identify the relevant namespace/subsystem
2. Then, get specific module details
3. Finally, get function-level information as needed

### Response Format

Query results should be formatted as structured context for the LLM prompt, enabling it to generate code that:
- Follows existing naming conventions
- Uses appropriate dependencies
- Matches function signature patterns
- Includes proper documentation style

