# LLM Workflow: Using SPARQL to Generate Better Elixir Code

This document shows how an LLM with SPARQL access would use the queries to accomplish real coding tasks.

## Workflow 1: "Add a new Action module for file operations"

### Step 1: Understand the Action pattern
```sparql
# Find all Action modules and see their structure
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName ?usedName .
  FILTER(CONTAINS(?usedName, "Jido.Action"))
  OPTIONAL { ?module struct:docstring ?docstring }
}
ORDER BY ?moduleName
LIMIT 5
```

**Result insight**: Actions use `Jido.Action`, have a `run/2` function, and follow naming like `Jido.Actions.X`

### Step 2: Get a template Action's full structure
```sparql
# Get complete details of Jido.Actions.Iterator as a template
SELECT ?funcName ?arity ?visibility
WHERE {
  ?module struct:moduleName "Jido.Actions.Iterator" ;
          struct:containsFunction ?func .
  ?func struct:functionName ?funcName ;
        struct:arity ?arity .
  BIND(IF(EXISTS { ?func a struct:PublicFunction }, "public", "private") AS ?visibility)
}
ORDER BY ?visibility ?funcName
```

**Result**: Iterator has `run/2` (public) and `enqueue/2` (private)

### Step 3: Generate the new module

Based on the pattern discovered, the LLM generates:

```elixir
defmodule Jido.Actions.FileOps do
  @moduledoc """
  Action for performing file operations.
  
  ## Parameters
  * `operation` - The file operation (:read, :write, :delete)
  * `path` - Target file path
  * `content` - Content for write operations (optional)
  """
  
  use Jido.Action,
    name: "file_ops",
    description: "Performs file system operations",
    schema: [
      operation: [type: {:in, [:read, :write, :delete]}, required: true],
      path: [type: :string, required: true],
      content: [type: :string]
    ]

  alias Jido.Agent.Directive.Enqueue

  @impl true
  def run(params, _context) do
    case params.operation do
      :read -> do_read(params.path)
      :write -> do_write(params.path, params.content)
      :delete -> do_delete(params.path)
    end
  end

  defp do_read(path), do: File.read(path)
  defp do_write(path, content), do: File.write(path, content)
  defp do_delete(path), do: File.rm(path)
end
```

---

## Workflow 2: "Add a new callback to an existing GenServer"

### Step 1: Understand the module's current state
```sparql
SELECT ?funcName ?arity ?visibility
WHERE {
  ?module struct:moduleName "Jido.Agent.Server" ;
          struct:containsFunction ?func .
  ?func struct:functionName ?funcName ;
        struct:arity ?arity .
  BIND(IF(EXISTS { ?func a struct:PublicFunction }, "public", "private") AS ?visibility)
}
ORDER BY ?visibility ?funcName
```

### Step 2: See what it already depends on
```sparql
SELECT ?depType ?depName
WHERE {
  ?module struct:moduleName "Jido.Agent.Server" .
  {
    ?module struct:aliasesModule ?dep .
    ?dep struct:moduleName ?depName .
    BIND("alias" AS ?depType)
  } UNION {
    ?module struct:usesModule ?dep .
    ?dep struct:moduleName ?depName .
    BIND("use" AS ?depType)
  }
}
```

### Step 3: Check how similar callbacks are implemented elsewhere
```sparql
SELECT ?moduleName ?arity
WHERE {
  ?module struct:moduleName ?moduleName ;
          struct:containsFunction ?func .
  ?func struct:functionName "handle_info" ;
        struct:arity ?arity .
  FILTER(CONTAINS(?moduleName, "Server"))
}
```

**Insight**: The LLM sees `handle_info/2` patterns across server modules, understands the return conventions.

---

## Workflow 3: "Understand the Directive system to add a new directive"

### Step 1: Find all directive-related modules
```sparql
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  FILTER(CONTAINS(?moduleName, "Directive") || 
         CONTAINS(?moduleName, "Enqueue") ||
         CONTAINS(?moduleName, "RegisterAction") ||
         CONTAINS(?moduleName, "Spawn") ||
         CONTAINS(?moduleName, "Kill"))
  OPTIONAL { ?module struct:docstring ?docstring }
}
ORDER BY ?moduleName
```

### Step 2: Get the Directive type definition
```sparql
SELECT ?typeName ?typeArity
WHERE {
  ?module struct:moduleName "Jido.Agent.Directive" ;
          struct:containsType ?type .
  ?type struct:typeName ?typeName ;
        struct:typeArity ?typeArity .
}
```

### Step 3: Examine existing directive struct patterns
```sparql
SELECT ?moduleName ?usedModule
WHERE {
  ?module struct:moduleName ?moduleName ;
          struct:usesModule ?used .
  ?used struct:moduleName ?usedModule .
  FILTER(CONTAINS(?moduleName, "Enqueue") || CONTAINS(?moduleName, "Spawn"))
  FILTER(CONTAINS(?usedModule, "TypedStruct"))
}
```

**Insight**: Directives use TypedStruct for their struct definition.

---

## Workflow 4: "Where should I add this new functionality?"

Task: "Add session tracking to agents"

### Step 1: Find modules dealing with agent state
```sparql
SELECT ?moduleName ?docstring
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  FILTER(CONTAINS(?moduleName, "State") && CONTAINS(?moduleName, "Agent"))
  OPTIONAL { ?module struct:docstring ?docstring }
}
```

### Step 2: Understand the State module's structure
```sparql
SELECT ?funcName ?arity ?docstring
WHERE {
  ?module struct:moduleName "Jido.Agent.Server.State" ;
          struct:containsFunction ?func .
  ?func a struct:PublicFunction ;
        struct:functionName ?funcName ;
        struct:arity ?arity .
  OPTIONAL { ?func struct:docstring ?docstring }
}
ORDER BY ?funcName
```

### Step 3: See what types State defines
```sparql
SELECT ?typeName
WHERE {
  ?module struct:moduleName "Jido.Agent.Server.State" ;
          struct:containsType ?type .
  ?type struct:typeName ?typeName .
}
```

**Decision**: Based on the query results, the LLM determines:
- Session tracking could be added as a field in `Jido.Agent.Server.State`
- Or as a separate `Jido.Agent.Server.Session` module following existing patterns

---

## Workflow 5: "Fix/extend an existing function"

Task: "Add timeout support to `Jido.Agent.Interaction.call/3`"

### Step 1: Get full context of the module
```sparql
SELECT ?funcName ?arity ?minArity
WHERE {
  ?module struct:moduleName "Jido.Agent.Interaction" ;
          struct:containsFunction ?func .
  ?func struct:functionName ?funcName ;
        struct:arity ?arity .
  OPTIONAL { ?func struct:minArity ?minArity }
}
ORDER BY ?funcName ?arity
```

### Step 2: See what the module depends on
```sparql
SELECT ?depType ?depName
WHERE {
  ?module struct:moduleName "Jido.Agent.Interaction" .
  {
    ?module struct:aliasesModule ?dep .
    BIND("alias" AS ?depType)
  } UNION {
    ?module struct:usesModule ?dep .
    BIND("use" AS ?depType)
  }
  ?dep struct:moduleName ?depName .
}
```

### Step 3: Check existing timeout patterns in codebase
```sparql
SELECT ?moduleName ?funcName
WHERE {
  ?module struct:moduleName ?moduleName ;
          struct:containsFunction ?func .
  ?func struct:functionName ?funcName .
  FILTER(CONTAINS(?funcName, "timeout") || CONTAINS(?funcName, "call"))
}
```

---

## Workflow 6: "Create a comprehensive test plan"

Task: Understand what needs testing for `Jido.Agent.Lifecycle`

### Step 1: Get all public functions to test
```sparql
SELECT ?funcName ?arity
WHERE {
  ?module struct:moduleName "Jido.Agent.Lifecycle" ;
          struct:containsFunction ?func .
  ?func a struct:PublicFunction ;
        struct:functionName ?funcName ;
        struct:arity ?arity .
}
ORDER BY ?funcName ?arity
```

### Step 2: Understand module dependencies (for mocking)
```sparql
SELECT ?depName
WHERE {
  ?module struct:moduleName "Jido.Agent.Lifecycle" ;
          struct:aliasesModule ?dep .
  ?dep struct:moduleName ?depName .
}
```

### Step 3: Find similar test patterns
```sparql
SELECT ?moduleName
WHERE {
  ?module a struct:Module ;
          struct:moduleName ?moduleName .
  FILTER(CONTAINS(?moduleName, "Test") && CONTAINS(?moduleName, "Agent"))
}
```

---

## Query Result Processing Tips for LLMs

### Extracting Patterns

When results show multiple modules with similar structures:
```
moduleName: Jido.Actions.Iterator    | run/2, enqueue/2
moduleName: Jido.Actions.Enumerable  | run/2, enqueue/2  
moduleName: Jido.Actions.While       | run/2, enqueue/2, on_after_run/1
```

The LLM should recognize:
- `run/2` is the standard entry point
- `enqueue/2` is a common private helper
- Some actions have lifecycle hooks like `on_after_run/1`

### Inferring Conventions

From dependency queries:
```
moduleName: Jido.Agent.Server | use GenServer
moduleName: Jido.Agent.Server | alias Jido.Agent.Server.State
moduleName: Jido.Agent.Server | alias Jido.Agent.Server.Signal
```

The LLM infers:
- Server submodules are aliased, not used
- The main behavior (GenServer) is `use`d
- Internal modules follow `Jido.Agent.Server.X` naming

### Building Context Blocks

Combine query results into structured context:

```
## Module: Jido.Agent.Server.Runtime
Dependencies: Directive, Callback, Output, Router, State, Error, Instruction, Signal
Public API: process_signals_in_queue/1
Private helpers: process_signal/2, execute_signal/2, route_signal/2, ...
Pattern: Internal server component, no GenServer, pure functions
```

This context block helps the LLM generate consistent code.

---

## Anti-Patterns to Avoid

### Don't over-query
Bad: Running 20 queries to understand one module
Good: Use comprehensive queries that return related data together

### Don't ignore conventions
Bad: Creating `Jido.FileActions` when pattern is `Jido.Actions.X`
Good: Query patterns first, then follow them

### Don't assume from one example
Bad: Seeing one Action has 3 clauses for `run/2`, assuming all do
Good: Query multiple examples to understand variation

